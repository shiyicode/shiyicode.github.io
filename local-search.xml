<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>初识云函数</title>
    <link href="/posts/36144.html"/>
    <url>/posts/36144.html</url>
    
    <content type="html"><![CDATA[<h2 id="什么是云函数"><a href="#什么是云函数" class="headerlink" title="什么是云函数"></a>什么是云函数</h2><p>云函数提供了一种<strong>直接在云上运行，无状态的、短暂的、由事件触发的代码</strong>的能力。</p><h3 id="云函数与轻服务的关系"><a href="#云函数与轻服务的关系" class="headerlink" title="云函数与轻服务的关系"></a>云函数与轻服务的关系</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/559a24346c6a176d6955e79eb96fa629.png"></p><p>ServerLess，即无服务器架构，也叫轻服务，它包含两个部分，如下：</p><ol><li><p>函数即服务（FaaS: Function as a Service）</p><p>函数即服务提供的是计算能力。原有的计算能力，无论是容器也好，虚拟机也好都承载在一定的操作系统之上，函数即服务把计算能力进行了进一步抽象。</p></li><li><p>后端及服务（BaaS: Backend as a Service）</p><p>后端即服务，比如对象存储，数据库应用，缓存服务，我们也可以称之为Serverless，因为这些服务也能够在云上提供开通即服务，开通即使用的能力。在使用这些产品时同样不需要关注它的服务器是什么样的，它的服务器部署在哪里，而是服务开通就可以使用了，后面的运维工作都交给了云，所以不用感知它的最底层服务器。</p></li></ol><p>云函数，就是FaaS模式的具体实现。同样，对象存储、数据库应用、缓存服务等，是BaaS模式的具体实现。<strong>对于轻服务，BaaS和FaaS缺一不可。</strong></p><h3 id="云函数对比传统服务"><a href="#云函数对比传统服务" class="headerlink" title="云函数对比传统服务"></a>云函数对比传统服务</h3><h4 id="服务粒度"><a href="#服务粒度" class="headerlink" title="服务粒度"></a>服务粒度</h4><p><img src="https://img-blog.csdnimg.cn/img_convert/b4f9d6a7fc2f93155193a933ba0c8d53.png"></p><ul><li>Monolith：单体应用</li><li>MicroService：微服务</li><li>Function：云函数</li></ul><p>一个单体应用可以按业务模块拆分成多个微服务，一个微服务也可以按使用场景拆分成多个云函数。比如一个广告微服务，至少可以拆分出实时竞价、展示计数、报表查询等云函数。也就是说，云函数和微服务中的API是同一粒度的。但不同于API，每个云函数都是独立部署，按需执行。</p><h4 id="服务架构"><a href="#服务架构" class="headerlink" title="服务架构"></a>服务架构</h4><p><img src="https://img-blog.csdnimg.cn/img_convert/68029b5d68321884b5e37692dd2f729a.png"></p><h3 id="云函数的特点"><a href="#云函数的特点" class="headerlink" title="云函数的特点"></a>云函数的特点</h3><ul><li><strong>零运维</strong>：不再需要管理底层资源的服务器</li><li><strong>秒级部署</strong>：运行无状态，轻易实现快速迭代</li><li><strong>自动触发</strong>：完全由事件触发，空闲时没有资源在运行</li><li><strong>聚焦代码逻辑</strong>：开发者只关心最核心的代码片段，跳过复杂的、无聊的其他工作</li><li><strong>无穷弹性计算能力</strong>：根据请求自动平行调整服务资源，拥有近乎无限的扩容能力</li></ul><h2 id="如何使用云函数"><a href="#如何使用云函数" class="headerlink" title="如何使用云函数"></a>如何使用云函数</h2><h3 id="微信云函数功能的构成"><a href="#微信云函数功能的构成" class="headerlink" title="微信云函数功能的构成"></a>微信云函数功能的构成</h3><ol><li>逻辑代码（目前只支持js）</li><li>触发器：包含定时触发、事件触发（目前仅支持定时触发）</li><li>设置项<ul><li>运行环境（目前只有NodeJs 8.9）</li><li>资源配置（根据指定的内存分配计算资源，CPU按比例自动分配）</li><li>超时时间（函数超过该时间仍未结束时，将会被强制中断，不能大于20s）</li><li>环境变量（可以使用键/值对的形式定义可从函数代码访问的环境变量。增强云函数的可定制性）</li></ul></li><li>相关支持<ul><li>测试（即时在线测试，构造Json参数，获取测试结果）</li><li>日志（包含请求ID，返回结果，运行时间，占用内存）</li><li>监控（可以查看云函数的调用次数、运行时间、错误次数）</li></ul></li></ol><h3 id="常见使用架构"><a href="#常见使用架构" class="headerlink" title="常见使用架构"></a>常见使用架构</h3><ul><li>一个云函数处理一个任务，高度解耦</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/b627f755fb66aea11d19ab60731a8bcc.png"></p><ul><li>尝试将请求归类，一个云函数处理某一类的请求，比如有专门负责处理用户的，或者专门处理支付的云函数。</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/a11704b6acf12567bfd1f30429aa51af.png"></p><ul><li>只有一个云函数，云函数里有一个分派任务的路由管理，将不同的任务分配给不同的本地函数处理。也可以是分配给其它的云函数或是其它执行单元。</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/c8fc7ff2790ea3390cc0ee4ae71430f3.png"></p><h3 id="什么场景可以用"><a href="#什么场景可以用" class="headerlink" title="什么场景可以用"></a>什么场景可以用</h3><p>理论上，只要符合下列条件，任何现有业务模块都可以改造成云函数的方式：</p><ul><li>触发响应：双向通信的场景，本质都可以用一方轮询来解决。</li><li>无状态：所有的状态，都可以下沉至BaaS。</li></ul><p><strong>可以用 ≠ 适合用，需要衡量 -&gt; 改造的代价 vs 云函数带来的收益。</strong></p><h3 id="什么场景适合用"><a href="#什么场景适合用" class="headerlink" title="什么场景适合用"></a>什么场景适合用</h3><ul><li>事件驱动及响应式架构</li><li>流量突发场景</li><li>请求对延时要求不高</li><li>低频请求</li><li>单项任务资源要求低</li></ul><h3 id="微信云函数使用的痛点"><a href="#微信云函数使用的痛点" class="headerlink" title="微信云函数使用的痛点"></a>微信云函数使用的痛点</h3><ol><li>报错信息不够友好；</li><li>开发者不能设置阈值从而自动伸缩；</li><li>触发器不够丰富。</li></ol><h2 id="为什么要用云函数"><a href="#为什么要用云函数" class="headerlink" title="为什么要用云函数"></a>为什么要用云函数</h2><h3 id="使用云函数的好处"><a href="#使用云函数的好处" class="headerlink" title="使用云函数的好处"></a>使用云函数的好处</h3><ol><li>简单易用：自动并快速扩缩容；</li><li>稳定可靠：高可用部署、与其他计算服务结合使服务更健壮；</li><li>高效开发：加速开发，简化运维；</li><li>节省成本：不需为空闲资源付费；</li><li>简化管理：可视化管理、简化安全配置。</li></ol><h3 id="使用云函数的缺陷"><a href="#使用云函数的缺陷" class="headerlink" title="使用云函数的缺陷"></a>使用云函数的缺陷</h3><ol><li>需要对业务进行很细粒度的拆分，难以进行或成本太高；</li><li>不适合长时间运行应用；</li><li>对第三方服务依赖过高。</li></ol><p>由于这些局限性，Serverless架构不会成为复杂应用的架构首选，相反，它应该是后端小程序的未来。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://developers.weixin.qq.com/miniprogram/dev/wxcloud/basis/getting-started.html">微信公众平台-小程序-云开发</a></li><li><a href="https://segmentfault.com/a/1190000016206163">Serverless架构详解：开发者如何专注于业务代码本身？</a></li><li><a href="https://juejin.im/post/5a4a5800f265da43294e6631">所谓Serverless，你理解对了吗？</a></li><li><a href="http://www.alloyteam.com/2018/09/13430/">云开发初探 —— 更简便的小程序开发模式丨掘金</a></li><li><a href="https://main.qcloudimg.com/raw/document/product/pdf/583_9197_cn.pdf">腾讯云-无服务器云函数-产品简介-产品文档</a></li><li><a href="https://segmentfault.com/a/1190000014160652">当我们聊Serverless时你应该知道这些</a></li></ul><hr>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>go包管理工具-glide使用方法及踩坑记录</title>
    <link href="/posts/54720.html"/>
    <url>/posts/54720.html</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>大学以来一直想做一个OJ，终于可以开始，而且是用新学的Go来写，心里还是挺兴奋的。<br>项目启动，要搭架子，第一件事，当然是选择一个包管理工具。Go的包管理还是挺混乱的，没有一个能像Java的Maven一样足够强大&amp;一统天下，尽管优秀的第三方工具已有十来种，且官方也开始着手开发(快统一江湖吧)。<br>(ps:虽然包管理很让人糟心，但这并不能影响我对这门语言的热爱)</p><h1 id="glide"><a href="#glide" class="headerlink" title="glide"></a>glide</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go get github.com/Masterminds/glide<br></code></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>进入项目文件夹。！记住，项目必须放在src下，否则会出现很多问题，包括其他包管理工具！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> <span class="hljs-variable">$GOPATH</span>/src/your_project<br></code></pre></td></tr></table></figure><p>创建glide.yaml文件，并进行相应配置选项</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">glide init<br></code></pre></td></tr></table></figure><p>修改glide.yaml，如果是刚创建的空项目，可以略过这一步。</p><blockquote><p>默认，glide.yaml生成会加入所有import语句的包路径，那么也就包含我们项目内部的包路径，因此我们需要将它们删掉，并对这类import增加过滤规则。</p></blockquote><p>安装glide.yaml配置的包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">glide install<br></code></pre></td></tr></table></figure><p>到这一步，我们的项目初始化就完成了，后续的操作就不再赘述了。</p><h3 id="glide-yml文件"><a href="#glide-yml文件" class="headerlink" title="glide.yml文件"></a>glide.yml文件</h3><blockquote><p>此处摘自<a href="http://blog.csdn.net/chenqijing2/article/details/55050843">Golang包管理工具Glide，你值得拥有</a></p></blockquote><p><code>glide.yml</code>是 <code>glide</code> 包管理的配置文件。下面我们对<code>glide.yml</code>的相关元素进行说明。</p><p>这里是一个完整的<code>glide.yml</code>文件：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-attribute">package</span>: github.com/Masterminds/glide<br><span class="hljs-attribute">homepage</span>: <span class="hljs-attribute">https</span>:<span class="hljs-comment">//masterminds.github.io/glide</span><br><span class="hljs-attribute">license</span>: MIT<br><span class="hljs-attribute">owners</span>:<br>- <span class="hljs-attribute">name</span>: Matt Butcher<br>  <span class="hljs-attribute">email</span>: technosophos<span class="hljs-variable">@gmail</span>.com<br>  <span class="hljs-attribute">homepage</span>: <span class="hljs-attribute">http</span>:<span class="hljs-comment">//technosophos.com</span><br>- <span class="hljs-attribute">name</span>: Matt Farina<br>  <span class="hljs-attribute">email</span>: matt<span class="hljs-variable">@mattfarina</span>.com<br>  <span class="hljs-attribute">homepage</span>: <span class="hljs-attribute">https</span>:<span class="hljs-comment">//www.mattfarina.com</span><br><span class="hljs-attribute">ignore</span>:<br>- appengine<br><span class="hljs-attribute">excludeDirs</span>:<br>- node_modules<br><span class="hljs-attribute">import</span>:<br>- <span class="hljs-attribute">package</span>: gopkg.in/yaml.v2<br>- <span class="hljs-attribute">package</span>: github.com/Masterminds/vcs<br>  <span class="hljs-attribute">version</span>: ^<span class="hljs-number">1.2</span>.<span class="hljs-number">0</span><br>  <span class="hljs-attribute">repo</span>:    git<span class="hljs-variable">@github</span>.<span class="hljs-attribute">com</span>:Masterminds/vcs<br>  <span class="hljs-attribute">vcs</span>:     git<br>- <span class="hljs-attribute">package</span>: github.com/codegangsta/cli<br>  <span class="hljs-attribute">version</span>: f89effe81c1ece9c5b0fda359ebd9cf65f169a51<br>- <span class="hljs-attribute">package</span>: github.com/Masterminds/semver<br>  <span class="hljs-attribute">version</span>: ^<span class="hljs-number">1.0</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">testImport</span>:<br>- <span class="hljs-attribute">package</span>: github.com/arschles/assert<br></code></pre></td></tr></table></figure><p>这些元素是：</p><ul><li><code>package</code>：顶部的 package 是它所在GOPATH的位置，glide 将从该位置下开始导包。</li><li><code>homepage</code>：该项目的详情页面。</li><li><code>license</code>：许可证标识，可以是<a href="http://spdx.org/licenses/">SPDX license</a>字符串或文件路径。</li><li><code>owners</code>：项目的所有者信息，便于接受漏洞信息。</li><li><code>ignore</code>：忽略导入的包，注意是包而不是目录。</li><li><code>excludeDirs</code>：排除扫描依赖的目录。</li><li><code>import</code>：import 的包列表： <ul><li><code>package</code>：导入包的名称，必填。软件包名称遵循go工具所用的相同模式。这意味着：<br>1、映射到VCS远程位置的软件包名称以<code>.git</code>，<code>.bzr</code>，<code>.hg</code>或<code>.svn</code>结尾。 例如，example.com/foo/pkg.git/subpkg。<br>2、GitHub, BitBucket, Launchpad, IBM Bluemix Services, and Go on Google Source是特殊情况，不需要 VCS 扩展。</li><li><code>version</code>：可以为semantic version, semantic version range, branch, tag 或者 commit id。</li><li><code>repo</code>：如果包名称不是repo位置或这是一个私人存储库，它可以去这里。 该软件包将从repo签出并放在软件包名称指定的位置。 这允许使用fork。</li><li><code>vcs</code>：要使用的VCS，如<code>git</code>，<code>hg</code>，<code>bzr</code>或<code>svn</code>。仅当无法从名称中检测到类型时才需要。例如，以<code>.git</code>或GitHub结尾的仓库可以被检测为Git。 对于Bitbucket的repo，我们可以联系API来发现类型。</li><li><code>subpackages</code>：在存储库中使用的包的记录。这不包括存储库中的所有包，而是包括正在使用的包。</li><li><code>os</code>：用于过滤的操作系统的列表。如果设置它将比较当前运行时操作系统与指定的操作系统，并且只有获取匹配的依赖。如果未设置过滤，则跳过。这些名称与构建标志和GOOS环境变量中使用的名称相同。</li><li><code>arch</code>：用于过滤的体系结构列表。如果设置它将比较当前运行时架构与指定的架构，并且只有在匹配时获取依赖关系。如果未设置过滤，则跳过。名称与构建标志和GOARCH环境变量中使用的名称相同。</li></ul></li><li><code>testImport</code>：在导入中未列出的测试中使用的软件包列表。每个包具有与导入下列出的相同的详细信息。</li></ul><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ol><li>项目必须在GOPATH/src内部，强调一下<code>src</code>。</li></ol><h1 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h1><p>我使用的时候是用gin框架当例子来测试，每次install都失败，原因都是一样，有的包出错，无法下载：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">golang.org/x/sys/unix<br></code></pre></td></tr></table></figure><p>后来在网上看到其他道友大多也都遇到过类似的问题。<br>其实是因为Google的原因，go get不能直接访问到golang.org/x这的模块。</p><p>解决方案如下<br>通过github其他路径下获取golang,org/x的镜像文件，并通过软链接的方式，加入到本地golang.org/x中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/golang/net.git <span class="hljs-variable">$GOPATH</span>/src/github.com/golang/net<br><br>git <span class="hljs-built_in">clone</span> https://github.com/golang/sys.git <span class="hljs-variable">$GOPATH</span>/src/github.com/golang/sys<br><br>git <span class="hljs-built_in">clone</span> https://github.com/golang/tools.git <span class="hljs-variable">$GOPATH</span>/src/github.com/golang/tools<br><br>ln -s <span class="hljs-variable">$GOPATH</span>/src/github.com/golang <span class="hljs-variable">$GOPATH</span>/src/golang.org/x<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>glide</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSDNtoHexo迁移脚本</title>
    <link href="/posts/14430.html"/>
    <url>/posts/14430.html</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这一阵子，刚换了落脚地儿，没想好该去折腾什么，恰好看到可以用<code>git page</code>搭建一个博客，就搞了搞。关于主题啊，配置啊什么的，网上都有好多，偏偏迁移这个事儿挺麻烦，幸好有找到一<a href="https://github.com/gaocegege/csdn-blog-export">前辈的脚本</a>，可以将CSDN的博客导出为markdown格式，但是其导出来的md文件并不能直接用hexo，想要显示的好一些还需要再用脚本将它二次润色。<br>本人重写了润色的脚本，并增加了对CSDN的分类的爬取，将其作为hexo md文件里面的标签。<br>记录于此，方便大家。</p><p>还有，欢迎访问我的新博客 <a href="http://shiyi.fightcoder.com/">shiyi.fightcoder.com</a></p><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>###python 2.7<br>这个就不说了，os-x，linux都是自带的，window的话自己下个就完了。</p><h3 id="BeautifulSouphttps"><a href="#BeautifulSouphttps" class="headerlink" title="BeautifulSouphttps"></a>BeautifulSouphttps</h3><p>去<a href="https://www.crummy.com/software/BeautifulSoup/">BeautifulSoup官网</a>下载源码包，解压后进入BeautifulSoup文件夹下执行下面命令即可。</p><blockquote><p>python setup.py install</p></blockquote><h3 id="html2text"><a href="#html2text" class="headerlink" title="html2text"></a>html2text</h3><p>下载源码包：<a href="https://pypi.python.org/packages/22/c0/2d02a1fb9027f54796af2c2d38cf3a5b89319125b03734a9964e6db8dfa0/html2text-2016.9.19.tar.gz#md5=d6b07e32ed21f186496f012691e02dd5">html2text-2016.9.19.tar.gz</a>。解压后进入html2text-2016.9.19文件夹下执行下面命令即可。(和上面是一样的)</p><blockquote><p>python setup.py install</p></blockquote><h2 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h2><h3 id="CSDN转MarkDown"><a href="#CSDN转MarkDown" class="headerlink" title="CSDN转MarkDown"></a>CSDN转MarkDown</h3><p>因为代码篇幅问题，请点击<a href="https://coding.net/u/to_be_better/p/blog/git/blob/master/csdn2mark/main.py">CSDN转MD脚本</a>自行拷贝到本地，运行下面命令</p><blockquote><p>python main.py -u 你的CSDN用户名<br>它会将你的CSDN所有的文章全部爬取并在本地以md格式保存。</p></blockquote><h3 id="MarkDown润色使其符合Hexo"><a href="#MarkDown润色使其符合Hexo" class="headerlink" title="MarkDown润色使其符合Hexo"></a>MarkDown润色使其符合Hexo</h3><p>跟上一步一样，请点击<a href="https://coding.net/u/to_be_better/p/blog/git/blob/master/csdn2mark/change.py">MarkDown润色脚本</a>自行拷贝。没问题的话代码开头是下面这样的，按着下面的提示进行更改，然后执行就好了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python</span><br><span class="hljs-comment"># -*- coding: UTF-8 -*-</span><br><br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> re<br><span class="hljs-keyword">import</span> urllib2<br><span class="hljs-comment">#解析博文HTML，获取博文时间、标题标签</span><br><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup<br><span class="hljs-comment">#解决中文编码问题</span><br><span class="hljs-keyword">import</span> codecs<br><br><span class="hljs-comment">#########</span><br><span class="hljs-comment">#htmlpre根据各自的csdn填写对应的。</span><br><span class="hljs-comment">#########</span><br><span class="hljs-comment">#mdPath填写上一步生成的md的所在路径，小白的话就请写绝对路径吧。</span><br><span class="hljs-comment">#########</span><br>htmlpre = <span class="hljs-string">&quot;http://blog.csdn.net/to_be_better/article/details/&quot;</span><br>mdPath = <span class="hljs-string">&#x27;csdn_md/&#x27;</span><br>mdPosts = os.listdir(mdPath)<br><br><span class="hljs-keyword">for</span> postName <span class="hljs-keyword">in</span> mdPosts:<br>    <span class="hljs-keyword">if</span> postName.endswith(<span class="hljs-string">&#x27;.md&#x27;</span>):<br><br></code></pre></td></tr></table></figure><p>这个脚本的功能就是去爬取对应文章的时间和分类，将这些信息对应填写到md的头部，使其符合hexo的标准，最终的结果是如下的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python">---<br>title: <span class="hljs-number">51</span>Nod <span class="hljs-number">1022</span> 石子归并 V2 (划分型dp四边形不等式优化)<br>date: <span class="hljs-number">2015</span><span class="hljs-number">-12</span><span class="hljs-number">-03</span> <span class="hljs-number">03</span>:<span class="hljs-number">34</span><br>tags: [动态规划]<br>category: 大学时期CSDN<br>comment: true---<br>石子归并以前做过好几次，是经典划分型dp题之一，一直用的O(n3)的正常dp方法，也从未想过该怎么去优化它。<br><br>直到昨天做这道题，n的范围由往常的<span class="hljs-number">100</span>改为了<span class="hljs-number">1000</span>，老方法<br>一直超时，苦不堪言，搜到有个四边形不等式的优化方法，看帖子，画式子，拉着学长帮忙推导，总算是大概弄明白了一点。<br><br>dp(i,j) = min(dp(i,k)+  dp(k+<span class="hljs-number">1</span>,j)  ) + w(i,j);(i &lt; j, i&lt;=k&lt;j)<br><br>dp(i,j)  = MAX;(i&gt;j)<br><br>dp(i,j)  = <span class="hljs-number">0</span>;(i=j)<br><br>此处省略后面内容。。。。。。。。。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux上定时器的实现</title>
    <link href="/posts/20429.html"/>
    <url>/posts/20429.html</url>
    
    <content type="html"><![CDATA[<h2 id="方法1-使用sleep或者usleep"><a href="#方法1-使用sleep或者usleep" class="headerlink" title="方法1. 使用sleep或者usleep"></a>方法1. 使用sleep或者usleep</h2><p>这种方法很简单，这里就不具体描述，它的缺点也很明确：精度不够，特别是在系统负载比较大时，会发生超时现象。</p><h2 id="方法2-使用信号量SIGALRM-alarm"><a href="#方法2-使用信号量SIGALRM-alarm" class="headerlink" title="方法2. 使用信号量SIGALRM + alarm()"></a>方法2. 使用信号量SIGALRM + alarm()</h2><p>alarm也称为闹钟函数，alarm()用来设置在经过参数seconds指定的秒数后传送信号SIGALRM给目前的进程。如果参数seconds为0，则之前设<br>置的闹钟会被取消，并将剩下的时间返回。要注意的是，一个进程只能有一个闹钟时间，如果在调用alarm之前已设置过闹钟时间，则任何以前的闹钟时间都被新值所代替。<br>那么我们可以使用signal函数设定SIGALRM的处理函数，然后使用alarm定时发送SIGALRM来达到我们的目的。</p><pre><code class="hljs">#include &lt;stdio.h&gt;#include &lt;signal.h&gt;#include &lt;unistd.h&gt;void timer(int sig)&#123;    if(SIGALRM == sig)    &#123;        printf(&quot;timer\n&quot;);        alarm(1);    &#125;    return;&#125;int main()&#123;    signal(SIGALRM, timer);    alarm(1);    getchar();    return 0;&#125;</code></pre><p>这里只是简单的实现了一下，所以是无线循环定时，完善很容易。<br>这个方法很方便，实现也很简单，但是也有缺点，就是精度不能小于1秒。</p><h2 id="方法3-select-多线程"><a href="#方法3-select-多线程" class="headerlink" title="方法3. select+多线程"></a>方法3. select+多线程</h2><p>原理很简单，利用select()方法的第5个参数，第一个参数设置为0，三个文件描述符集都设置为NULL，第5个参数为时间结构体，设置为我们想要定时的事件频率<br>即可。</p><pre><code class="hljs">#include &lt;iostream&gt;#include &lt;pthread.h&gt;#include &lt;functional&gt;#include &lt;time.h&gt;#include &lt;sys/select.h&gt;#include &lt;unistd.h&gt;class Timer&#123;public:    Timer() = default;    Timer(int sec, int usec, int count, const std::function&lt;void()&gt; &amp;callback)    : sec_(sec), usec_(usec), count_(count), callback_(callback)&#123;    &#125;    void startTimer()&#123;        pthread_create(&amp;thread_, NULL, work, this);    &#125;    void endTimer()&#123;        //终止线程        pthread_cancel(thread_);        //回收线程资源        pthread_join(thread_, NULL);    &#125;private:    //解决类成员函数不能作为pthread_create函数参数的问题    static void* work(void* timer)&#123;        static_cast&lt;Timer*&gt;(timer)-&gt;workTimer();    &#125;    void workTimer()&#123;        for(int i=0; i&lt;count_; i++)&#123;            struct timeval tempval;            tempval.tv_sec = sec_;            tempval.tv_usec = usec_;            select(0, NULL, NULL, NULL, &amp;tempval);            callback_();        &#125;    &#125;    int sec_;    int usec_;    int count_;    std::function&lt;void()&gt; callback_;    pthread_t thread_;&#125;;int main()&#123;    Timer a(1,0,10,[]()&#123;std::cout&lt;&lt;&quot;timer a&quot;&lt;&lt;std::endl;&#125;);    a.startTimer();    Timer b(2,0,5,[]()&#123;std::cout&lt;&lt;&quot;timer b&quot;&lt;&lt;std::endl;&#125;);    b.startTimer();    getchar();    return 0;&#125;</code></pre><p>运行结果：<br>![这里写图片描述](<a href="http://img.blog.csdn.net/20170302230249299?watermark/2/text/aHR0cDo">http://img.blog.csdn.net/20170302230249299?watermark/2/text/aHR0cDo</a><br>vL2Jsb2cuY3Nkbi5uZXQvdG9fYmVfYmV0dGVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFC<br>MA==/dissolve/70/gravity/SouthEast)</p>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux系统编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>对比高性能I/O设计模式-Reactor/Proactor</title>
    <link href="/posts/609.html"/>
    <url>/posts/609.html</url>
    
    <content type="html"><![CDATA[<p>通常，I/O复用机制都需要事件分享器。分享器对象可将来自事件源的I/O事件分离出来，并分发到对应的Read/Write事件处理器。开发人员预先注册需要处理的<br>事件及该事件对应的事件处理器。<br>Reactor和Proactor都涉及到了事件分享器，不同的是，Reactor是基于同步I/O的，而Proactor是与异步I/O相关。</p><p>在Reactor模式中，事件分离器等待某个事件或者某个操作的状态发生，比如文件描述符可读写或是socket可读写，事件分离器就将这个时间传给事先注册的事件处<br>理器(事件处理函数或者回调函数)，由后者来做实际的读写操作。</p><p>而在Proactor模式中，事件处理器直接发起一个异步读写操作，发起时，需要提供用于存放读到数据的缓存区、读的数据大小。以及这个请求完成后的回调函数等信息。<br>事件分离器收到请求后，默默等待这个请求的完成，然后转发完成事件给对应的事件处理器。这种异步模式的典型实现是基于操作系统底层异步API的，所以我们可以称之为“<br>系统级别”的或者“真正意义上”的异步，因为具体的读写操作是由操作系统来代劳的。</p><p>我们用读操作来举例，更好的理解Reactor和Proactor两种模式的区别。<br>Reactor：</p><ul><li>某个事件处理器宣称它对某个socket上的读事件很感兴趣(发起读请求)</li><li>事件分离器等待这个事件的发生</li><li>事件发生时，事件分离器被唤醒，然后通知先前那个事件处理者</li><li>事件处理者接到通知，于是去那个socket上读数据，如果需要，它再次宣称对这个socket上的读事件感兴趣，一直重复上面的步骤</li></ul><p>Proactor(系统级别异步)：</p><ul><li>事件处理者直接发起一个写请求，这个时候，事件处理者不关心读事件，它只是发请求而已，发完之后就不管具体的事了，，只等着系统帮他搞定之后给他的回话。</li><li>事件分离者等待着这个读事件的完成，与此同时，系统已经在一边开始干活了，它从目标socket读取数据，放入用户提供的缓存区中，完成后，通知事件分离者</li><li>事件分离者通知事件处理者，读事件已经完成</li><li>事件处理者会从它所提供的缓存区中获得它想要读的数据，按照自己我需要进行处理。如果需要，它可以像之前一样继续发起一个操作请求，无论是写操作还是读操作，和上面的几个步骤一样</li></ul><p>然而，并不是所有的操作系统都为底层异步提供健壮的支持，比如许多Unix系统。</p><p>正如上面所提到过的，真正的异步模式需要操作系统级别的支持。由于事件处理者及操作系统交互的差异，为Reactor何Proactor设计一种通用统一的外部接口是<br>非常困难的。因此，大多网络库或是开发框架都是在两种模式之一，唯一一个包含两者的ACE，也是为Window准备了ACE<br>Proactor、为Unix系列提供了ACE Reactor，并且两者的代码分别独立维护。</p><p>为了解决这个情况，我们可以将Reactor稍做调整，模拟成异步的Proactor模型(主要是在事件分离器里完成本该事件处理者做的实际读写工作，我们称这种方法<br>为“模拟异步”)。</p><p>Proactor(模拟异步)：</p><ul><li>事件处理者宣告对读事件感兴趣，并提供用于存储读出的结果的缓存区、读的数据长度等参数</li><li>事件分离器等待，当事件到来时，分离器被唤醒，并去执行非阻塞的读操作，读取完毕后，通知事件处理者。</li><li>事件处理者这时会被通知读操作完成，并且已经获得了想要获取的数据。</li></ul><p>我们看到，通过为分离者添加一些功能，就可以让Reactor模式转换为Proactor模式。所有这些被执行的操作，其实是和Reactor模式应用时完全一致的。<br>我们只是把工作打散分配给不同的角色去完成而已。这样并不会有额外的开销，也不会有性能的损失。<br>我们再来对比一下Reactor和模拟的Proactor两个过程。</p><p>Reactor：</p><ul><li>等待事件</li><li>发“已经可读”事件给实现注册的事件处理者或者回调</li><li>读数据</li><li>处理数据</li></ul><p>Proactor：</p><ul><li>等待事件</li><li>读数据</li><li>发“数据已经读取完毕”事件给实现注册的事件处理器或者回调</li><li>处理数据</li></ul><p>在没有底层异步I/O<br>API支持的操作系统，这种方法可以帮我们隐藏掉socket接口的差异，提供一个完全可用并且统一的“异步接口”。这样我们就可以开发真正平台独立的通用接口了。</p><p>参考博客：<br><a href="http://blog.jobbole.com/59676/"> http://blog.jobbole.com/59676/ </a><br><a href="https://www.zhihu.com/question/26943938/answer/35034068"> https://www.zhihu.com/question/26943938/answer/35034068</a></p>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>服务器开发</tag>
      
      <tag>Linux网络编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>游戏服务器和一般服务器对比，有何特别？</title>
    <link href="/posts/3361.html"/>
    <url>/posts/3361.html</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在中国的互联网诸多业务领域中，游戏一直是充当“现金牛”而存在的。但是，在游戏服务器端开发领域中的很多重要问题，并没有被明确的分辨出其特异性，从而得到专门的对<br>待。我们不管是在业界开源领域，还是内部分享中，很少会有专门针对游戏业务特征进行专门设计的组件、类库或者框架。我们从游戏的客户端方面来看，一款专业的游戏客户端<br>引擎，已经是游戏开发的标配，比如最早的Flash<br>Builder，到后期的Cocos2d-X，Unity，Unreal；但是服务器端，我们几乎找不到同样重量级的产品。</p><h2 id="游戏服务器和一般服务器的区别"><a href="#游戏服务器和一般服务器的区别" class="headerlink" title="游戏服务器和一般服务器的区别"></a>游戏服务器和一般服务器的区别</h2><p>在游戏服务器端开发所有要面对的问题中，有两个是最核心和最普遍的：一是和客户端的通讯；二是游戏登录用户的数据处理。对于和客户端通讯的这个问题，大量的游戏开发者<br>会使用“通用”的开源组件，比如Protocol<br>Buffer，Thrift，Jetty，Node.js等等通信或RPC框架。虽然针对游戏，还是要做大量的改造，但一般都有很多现成的代码可供修改。</p><p>在一般的互联网应用中，我们一般认为服务都是通过请求-响应的方式来完成的。而在游戏业务领域中，请求-响应可以看成是一种类型的通讯方式，但还有另外一种重要的通讯<br>模型，就是“数据同步”方式：游戏中某个角色的HP、位置坐标改变了，需要在客户端和服务器之间、客户端和客户端之间同步。这造成了一般情况下通信协议的大量增加。</p><p>对于第二个问题，不管是memcache还是MySQL，或者是Redis，都不能完全满足游戏开发者的需求。很多团队尝试过各种组合和修改，试图创造出利用现有开源<br>软件，建设既能迎合灵活的需求变化，又具备低延迟和高可用的数据处理系统，但最后这些努力基本上都很难圆满成功。因此我们在游戏服务器端代码中，还是充斥着大量的内存<br>、缓存管理，数据同步、落地等等代码。而且每个游戏都要重新去写一遍这些类似的功能，不能不说一种浪费。</p><p>如果我们要想出一种能满足“游戏”这个业务领域的数据系统设计，那么就一定要搞清楚为什么在如此之多的开源项目和游戏团队中，没能实现完美契合的原因。</p><h3 id="电子商务-一般互联网业务的C-S通讯流程"><a href="#电子商务-一般互联网业务的C-S通讯流程" class="headerlink" title="电子商务/一般互联网业务的C-S通讯流程"></a>电子商务/一般互联网业务的C-S通讯流程</h3><p>基于WebService类型的通讯模型，现在基本已经成为互联网开源组件的标准。由此而诞生的RESTful<br>API，或者各种RPC模型，其实都是基于这样的客观事实：<br>![这里写图片描述](<a href="http://bbs.gameres.com/data/attachment/forum/201609/28/11164011ymvy">http://bbs.gameres.com/data/attachment/forum/201609/28/11164011ymvy</a><br>03v1a91zy3.jpg)</p><ul><li><p>用户主动请求，服务器产生回应。典型的就是网页的点击、表单的提交。</p></li><li><p>主动通知的消息，仅仅是提示用户发起查询请求。比如在APP按钮上的小红点，消息页的数字提示等等，这些主动通知都是为了通知用户去刷新页面。</p></li></ul><p>![游戏服务器和一般服务器对比，有何特别？ …](<a href="http://bbs.gameres.com/data/attachment/forum/201609">http://bbs.gameres.com/data/attachment/forum/201609</a><br>/28/111640s3tf1zrfx3xr5ovp.jpg)</p><h3 id="游戏类业务的通信流程"><a href="#游戏类业务的通信流程" class="headerlink" title="游戏类业务的通信流程"></a>游戏类业务的通信流程</h3><p>游戏中的通信，一般和操作有关。这些操作一般分为两类：</p><ul><li><p>UI面板类操作</p></li><li><p>战斗场景操作</p></li></ul><p>这两者的最大区别，就是UI面板类操作一般无需让其他玩家看见。而战斗场景操作则需要广播给所有玩家看到。</p><p>![这里写图片描述](<a href="http://bbs.gameres.com/data/attachment/forum/201609/28/11164086n6b6">http://bbs.gameres.com/data/attachment/forum/201609/28/11164086n6b6</a><br>g18622zwaf.jpg)<br>![这里写图片描述](<a href="http://bbs.gameres.com/data/attachment/forum/201609/28/111641rayh26">http://bbs.gameres.com/data/attachment/forum/201609/28/111641rayh26</a><br>grdjt72lrw.jpg)</p><p>在第二种情况下，一般就不是客户端主动发起，而是服务器端直接推送实际数据，然后客户端直接显示这些数据。这个模式和简单的“推送”还不一样，而应该更进一步，是一种<br>从服务器端发起的，向客户端“同步”数据的请求。</p><p>因此，一个好的游戏服务器端框架，应该是能同时支持请求-响应模型和“推送同步”模型的。</p><h3 id="电子商务-一般互联网类业务的数据处理流程"><a href="#电子商务-一般互联网类业务的数据处理流程" class="headerlink" title="电子商务/一般互联网类业务的数据处理流程"></a>电子商务/一般互联网类业务的数据处理流程</h3><p>Memcache、Redis、MySQL在一般互联网业务中的应用非常广泛。而且基本上能很好的应对各种常见的应用场景，包括类似BBS的社区、新闻门户、电子商务<br>类系统。在企业内部信息系统中（Intranet），这一类数据软件也能发挥非常好的功效。由于电子商务类是其中最复杂的系统，所以我在这里以此为例说明，一般数据处<br>理的流程是如何的。</p><p>![这里写图片描述](<a href="http://bbs.gameres.com/data/attachment/forum/201609/28/11164109w8k0">http://bbs.gameres.com/data/attachment/forum/201609/28/11164109w8k0</a><br>802e0li008.jpg)</p><p>假设我们浏览了一个网店，选中了一个商品，点击了下单这个流程，实际上需要的后台流程可能是下图所示：</p><p>![](<a href="http://bbs.gameres.com/data/attachment/forum/201609/28/111641yg8vvs0y6gn7g">http://bbs.gameres.com/data/attachment/forum/201609/28/111641yg8vvs0y6gn7g</a><br>yh7.gif)</p><p>从上面的分析大概可以总结出几个特点：</p><p>一、忍受延迟：每个操作的延迟要求较低，操作频率不会太高。一般我们页面在5秒内打开，都不会引起太多客户的抗议。所以，就算我们处理一个请求的时候，后台进行多次的<br>进程间调用，产生的延迟和带宽消耗也是可以忍受的。</p><p>二、在线交互少：互联网业务大多数是基于浏览器的，所以在线用户之间很少实时交互。</p><p>三、数据分散：一般来说，互联网应用的数据可以在多个不同的业务系统中共用，但是需要专门的业务模块来做管理，以维持数据的一致性。</p><p>四、数据变更面广：系统需要持续处理很多数据变更，互联网业务有很大一部分数据是来源于普通用户、网络编辑、店主等等使用者，在使用的过程中，他们会大量的修改系统所<br>存储的数据。</p><p>以上四个特点，导致了我们一般会把后台要处理的数据，分别用Cache系统和DB系统来处理。并且，我们一般会按业务功能划分模块，同时也划分业务系统。由于延迟和在<br>线交互的需求较弱，所以使用大量进程来做模块隔离，依然是非常可行的，总体来说，就是一种比较“分散”的数据使用方式。</p><h3 id="游戏类业务的数据处理流程"><a href="#游戏类业务的数据处理流程" class="headerlink" title="游戏类业务的数据处理流程"></a>游戏类业务的数据处理流程</h3><p>在各种游戏中，MMORPG是数据处理最为复杂的一类，也是最典型的一种“重服务器端”的游戏类型，因此可以作为游戏业务中通用性的参考标准。在MMORPG中，我们<br>可以发现，数据的处理需求，和一般互联网业务大相径庭，它体现出的是一种明显的“集中”式的数据处理需求。我们可以从一般MMORPG的服务器架构中体现出来：</p><p>![](<a href="http://bbs.gameres.com/data/attachment/forum/201609/28/111641ezyefv6z6hq4y">http://bbs.gameres.com/data/attachment/forum/201609/28/111641ezyefv6z6hq4y</a><br>23v.gif)</p><p>在游戏业务中，一般我们都会发现以下的特点：</p><p>一、延迟敏感：游戏中用户会产生大量操作，都要求“实时”进行反馈，所以一般都不能忍受1秒以上的延迟，在大量动作类型的游戏中，一般都会要求服务器的反馈时延在50<br>ms左右。因此游戏开发者都习惯于尽量减少后台进程间的交互，尽管这对提高系统吞吐量很不利。所以大部分游戏服务器端都有一个所谓“GameServer”，里面运行<br>了游戏70%以上的功能。</p><p>二、大量实时交互：在线游戏的特点，就是很多玩家可以通过服务器“看见”彼此，能实时的互动。因此我们必须要把用户的在线数据，集中到一起，才能提供互相操作的可能；<br>而且A用户操作B用户的数据，是最常见的数据操作，所谓战斗玩法，就是互相修改对方的数据的过程。</p><p>三、数据集中：游戏是一个几乎完全虚拟的世界，在游戏中的数据，实际上很少能在其他系统中产生价值。而游戏逻辑也禁止通过游戏以外的方式，修改游戏的数据。所以游戏中<br>的数据，一般都会集中存放在单独的数据库中。由于没有数据共用的需求，所以也不需要把GameServer里面集中的逻辑划分出很多单独的进程模块来。</p><p>四、数据变更少：实际上游戏的数据变更还是很快的，比如游戏中的每次中弹，都要减少HP的数值。但是游戏里的数据，一般都遵守这样一个规则：“变化越快的数据，重要性<br>越低”。也就是说，游戏中是可以容忍一定程度的数据不一致和不完整的。而游戏中的数据，一般会分成两类：玩家存档和游戏设置。对于玩家存档来说，其单条数据量一般不大<br>，但会有大量的记录数，因为每个玩家都会有一个存档。但是其读取、修改，一般很典型的和玩家的登录、登出、升级等业务逻辑密切关联，所以其缓存时机是比较容易根据业务<br>逻辑来把握的。而对于游戏设置数据来说，几乎只有升级游戏版本的时候才会修改，大部分运行时是只读的，其缓存简单的读入内存就解决问题了。</p><p>一般的缓存系统的特点在游戏中的问题</p><p>根据以上的分析，我们可以看到，普通的缓存系统，如memcache和Redis，实际上其特点是不太适合游戏业务的：</p><ul><li><p>一般跨进程的缓存系统，无法解决游戏要求的低延迟问题。级别是同机房，每次数据存取都需要10-20ms的时间，对于游戏战斗中大量的数据读、写来说，是很难接受的。（但是一些回合制战斗、低频操作还是有用的）</p></li><li><p>通用型的缓存系统或者数据库，一般都比较难集结多个进程，形成一个完整的数据存储网格。这让玩家间的互相交互产生了额外的难度，开发者必须先想办法确定玩家的数据在哪个后台进程上，然后才能去读写。一般的数据库或缓存系统，为了保证数据的一致性或者完整性，往往会需要牺牲一些分布式的能力。而这种牺牲在游戏业务中，其实是一种浪费，因为游戏的很多数据都无需这种能力。</p></li><li><p>通用性数据系统一般不依赖于特定的语言，所以很少能直接把某种“对象”存入到数据系统中。在游戏开发中，需要存储的数据结构数量往往是非常大量的：一个普通的游戏，基本上都会超过100种数据结构。对于每个数据结构，都去建表或者编写序列化/反序列化配置，是一种非常累人的工作。–明明在代码中，已经用编程语言定义了他们的结构，还要重复的搞一次。</p></li></ul><p>根据上面说的这些问题，我们实际上是需要另外一种完全不同设计思想的数据系统。</p><p>对于游戏业务来说，一个好用的数据系统，应该包括这样一些特点：</p><ul><li><p>可以利用GameServer进程内的内存进行自动化的缓存管理。由于GameServer进程往往集中了大部分的逻辑运算，所以大部分的数据缓存也应该在这个进程中，这样才能符合游戏所需的延迟要求。</p></li><li><p>自动进行数据落地和容灾管理。由于游戏数据中有大量的“过程数据”，所以其一致性和完整性要求会稍微低于其他业务，所以应该利用这一点，让GameServer本身也可以是分布式的程序，从而提高系统整体的吞吐量。</p></li><li><p>具备良好的编程易用性。最好是能直接存取编程中的对象，避免反复对数据结构的描述，节省大量的开发时间。</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>游戏服务器和普通互联网业务服务器端，最大的区别实际上就在于“状态”。游戏服务器的状态是实时快速变化的、可以容忍丢失的、需要大量广播同步的；普通互联网业务服务<br>器的状态一般是持久化的、不容忍丢失的、只和特定客户端相关的。所以一个好的游戏服务器框架，在通讯和数据这两个基本层面，会和一般我们所接触的开源组件有很大的差异<br>。这也是作为游戏服务器端开发者，需要去共同建设行业标准的地方。</p>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>游戏开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>各类游戏对应的服务端架构</title>
    <link href="/posts/22612.html"/>
    <url>/posts/22612.html</url>
    
    <content type="html"><![CDATA[<h2 id="卡牌、跑酷等弱交互服务端"><a href="#卡牌、跑酷等弱交互服务端" class="headerlink" title="卡牌、跑酷等弱交互服务端"></a>卡牌、跑酷等弱交互服务端</h2><p>卡牌跑酷类因为交互弱，玩家和玩家之间不需要实时面对面PK，打一下对方的离线数据，计算下排行榜，买卖下道具即可，所以实现往往使用简单的 HTTP服务器：</p><p>![这里写图片描述](<a href="http://img.blog.csdn.net/20170224223228952?watermark/2/text/aHR0cDo">http://img.blog.csdn.net/20170224223228952?watermark/2/text/aHR0cDo</a><br>vL2Jsb2cuY3Nkbi5uZXQvdG9fYmVfYmV0dGVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFC<br>MA==/dissolve/70/gravity/SouthEast)</p><p>登录时可以使用非对称加密（RSA, DH），服务器根据客户端uid，当前时间戳还有服务端私钥，计算哈希得到的加密 key 并发送给客户端。之后双方都用<br>HTTP通信，并用那个key进行RC4加密。客户端收到key和时间戳后保存在内存，用于之后通信，服务端不需要保存 key，因为每次都可以根据客户端传上来的<br>uid 和 时间戳 以及服务端自己的私钥计算得到。用模仿 TLS的行为，来保证多次 HTTP请求间的客户端身份，并通过时间戳保证同一人两次登录密钥不同。</p><p>每局开始时，访问一下，请求一下关卡数据，玩完了又提交一下，验算一下是否合法，获得什么奖励，数据库用单台 MySQL或者 MongoDB即可，后端的 Redi<br>s做缓存（可选）。如果要实现通知，那么让客户端定时15秒轮询一下服务器，如果有消息就取下来，如果没消息可以逐步放长轮询时间，比如30秒；如果有消息，就缩短轮<br>询时间到10秒，5秒，即便两人聊天，延迟也能自适应。</p><p>此类服务器用来实现一款三国类策略或者卡牌及酷跑的游戏已经绰绰有余，这类游戏因为逻辑简单，玩家之间交互不强，使用<br>HTTP来开发的话，开发速度快，调试只需要一个浏览器就可以把逻辑调试清楚了。</p><h2 id="类型2：第一代游戏服务器-1978"><a href="#类型2：第一代游戏服务器-1978" class="headerlink" title="类型2：第一代游戏服务器 1978"></a>类型2：第一代游戏服务器 1978</h2><p>1978年，英国著名的财经学校University of Essex的学生 Roy<br>Trubshaw编写了世界上第一个MUD程序《MUD1》，在University of Essex于1980年接入<br>ARPANET之后加入了不少外部的玩家，甚至包括国外的玩家。《MUD1》程序的源代码在<br>ARPANET共享之后出现了众多的改编版本，至此MUD才在全世界广泛流行起来。不断完善的 MUD1的基础上产生了开源的<br>MudOS（1991），成为众多网游的鼻祖：</p><p>![这里写图片描述](<a href="http://img.blog.csdn.net/20170224223334437?watermark/2/text/aHR0cDo">http://img.blog.csdn.net/20170224223334437?watermark/2/text/aHR0cDo</a><br>vL2Jsb2cuY3Nkbi5uZXQvdG9fYmVfYmV0dGVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFC<br>MA==/dissolve/70/gravity/SouthEast)</p><p>MUDOS采用 C语言开发，因为玩家和玩家之间有比较强的交互（聊天，交易，PK），MUDOS使用单线程无阻塞套接字来服务所有玩家，所有玩家的请求都发到同一个<br>线程去处理，主线程每隔1秒钟更新一次所有对象（网络收发，更新对象状态机，处理超时，刷新地图，刷新NPC）。</p><p>游戏世界采用房间的形式组织起来，每个房间有东南西北四个方向可以移动到下一个房间，由于欧美最早的网游都是地牢迷宫形式的，因此场景的基本单位被成为 “房间”。M<br>UDOS使用一门称为LPC的脚本语言来描述整个世界（包括房间拓扑，配置，NPC，以及各种剧情）。游戏里面的高级玩家（巫师），可以不断的通过修改脚本来为游戏添<br>加房间以及增加剧情。早年 MUD1上线时只有17个房间，Roy Trubshaw毕业以后交给他的师弟 Richard Battle，在 Richard<br>Battle手上，不断的添加各种玩法到一百多个房间，终于让 MUD发扬光大。</p><p>用户使用 Telnet之类的客户端用 Tcp协议连接到 MUDOS上，使用纯文字进行游戏，每条指令用回车进行分割。比如 1995年国内第一款<br>MUD游戏《侠客行》，你敲入：”go east”，游戏就会提示你：“后花园 -<br>这里是归云庄的后花园，种满了花草，几个庄丁正在浇花。此地乃是含羞草生长之地。这里唯一的出口是 north。这里有：花待 阿牧（A<br>mu），还有二位庄丁（Zhuang Ding）”，然后你继续用文字操作，查看阿牧的信息：“look a mu”，系统提示：“花待 阿牧（A mu）他是陆乘风<br>的弟子，受命在此看管含羞草。他看起来三十多岁，生得眉清目秀，端正大方，一表人才。他的武艺看上去【不是很高】，出手似乎【极轻】”。然后你可以选择击败他获得含羞<br>草，但是你吃了含羞草却又可能会中毒死亡。在早期网上资源贫乏的时候，这样的游戏有很强的代入感。</p><p>用户数据保存在文件中，每个用户登录时，从文本文件里把用户的数据全部加载进来，操作全部在内存里面进行，无需马上刷回磁盘。用户退出了，或者每隔5分钟检查到数据改<br>动了，都会保存会磁盘。这样的系统在当时每台服务器承载个4000人同时游戏，不是特别大的问题。从1991年的<br>MUDOS发布后，全球各地都在为他改进，扩充，退出新版本，随着 Windows图形机能的增强。1997游戏《UO》在<br>MUDOS的基础上为角色增加的x,y坐标，为每个房间增加了地图，并且为每个角色增加了动画，形成了第一代的图形网络游戏。</p><p>因为游戏内容基本可以通过 LPC脚本进行定制，所以MUDOS也成为名副其实的第一款服务端引擎，引擎一次性开发出来，然后制作不同游戏内容。后续国内的《万王之王<br>》等游戏，很多都是跟《UO》一样，直接在 MUDOS上进行二次开发，加入房间的地图还有角色的坐标等要素，该架构一直为国内的第一代<br>MMORPG提供了稳固的支持，直到 2003年，还有游戏基于 MUDOS开发。</p><p>虽然后面图形化增加了很多东西，但是这些MMORPG后端的本质还是<br>MUDOS。随着游戏内容的越来越复杂，架构变得越来越吃不消了，各种负载问题慢慢浮上水面，于是有了我们的第二代游戏服务器。</p><h2 id="类型3：第二代游戏服务器-2003"><a href="#类型3：第二代游戏服务器-2003" class="headerlink" title="类型3：第二代游戏服务器 2003"></a>类型3：第二代游戏服务器 2003</h2><p>2000年后，网游已经脱离最初的文字MUD，进入全面图形化年代。最先承受不住的其实是很多小文件，用户上下线，频繁的读取写入用户数据，导致负载越来越大。随着在<br>线人数的增加和游戏数据的增加，服务器变得不抗重负。同时早期 EXT磁盘分区比较脆弱，稍微停电，容易发生大面积数据丢失。因此第一步就是拆分文件存储到数据库去。</p><p>![这里写图片描述](<a href="http://img.blog.csdn.net/20170224223605113?watermark/2/text/aHR0cDo">http://img.blog.csdn.net/20170224223605113?watermark/2/text/aHR0cDo</a><br>vL2Jsb2cuY3Nkbi5uZXQvdG9fYmVfYmV0dGVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFC<br>MA==/dissolve/70/gravity/SouthEast)</p><p>此时游戏服务端已经脱离陈旧的 MUDOS体系，各个公司在参考 MUDOS结构的情况下，开始自己用 C在重新开发自己的游戏服务端。并且脚本也抛弃了<br>LPC，采用扩展性更好的 Python或者<br>Lua来代替。由于主逻辑使用单线程模型，随着游戏内容的增加，传统单服务器的结构进一步成为瓶颈。于是有人开始拆分游戏世界，变为下面的模型：</p><p>![这里写图片描述](<a href="http://img.blog.csdn.net/20170224223638801?watermark/2/text/aHR0cDo">http://img.blog.csdn.net/20170224223638801?watermark/2/text/aHR0cDo</a><br>vL2Jsb2cuY3Nkbi5uZXQvdG9fYmVfYmV0dGVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFC<br>MA==/dissolve/70/gravity/SouthEast)</p><p>游戏服务器压力拆分后得意缓解，但是两台游戏服务器同时访问数据库，大量重复访问，大量数据交换，使得数据库成为下一个瓶颈。于是形成了数据库前端代理（DB<br>Proxy），游戏服务器不直接访问数据库而是访问代理，再有代理访问数据库，同时提供内存级别的cache。早年<br>MySQL4之前没有提供存储过程，这个前端代理一般和<br>MySQL跑在同一台上，它转化游戏服务器发过来的高级数据操作指令，拆分成具体的数据库操作，一定程度上代替了存储过程：</p><p>![这里写图片描述](<a href="http://img.blog.csdn.net/20170224223734332?watermark/2/text/aHR0cDo">http://img.blog.csdn.net/20170224223734332?watermark/2/text/aHR0cDo</a><br>vL2Jsb2cuY3Nkbi5uZXQvdG9fYmVfYmV0dGVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFC<br>MA==/dissolve/70/gravity/SouthEast)</p><p>但是这样的结构并没有持续太长时间，因为玩家切换场景经常要切换连接，中间的状态容易错乱。而且游戏服务器多了以后，相互之间数据交互又会变得比较麻烦，于是人们拆分<br>了网络功能，独立出一个网关服务 Gate（有的地方叫 Session，有的地方叫 LinkSvr之类的，名字不同而已）：</p><p>![这里写图片描述](<a href="http://img.blog.csdn.net/20170224223806926?watermark/2/text/aHR0cDo">http://img.blog.csdn.net/20170224223806926?watermark/2/text/aHR0cDo</a><br>vL2Jsb2cuY3Nkbi5uZXQvdG9fYmVfYmV0dGVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFC<br>MA==/dissolve/70/gravity/SouthEast)</p><p>把网络功能单独提取出来，让用户统一去连接一个网关服务器，再有网关服务器转发数据到后端游戏服务器。而游戏服务器之间数据交换也统一连接到网管进行交换。这样类型的<br>服务器基本能稳定的为玩家提供游戏服务，一台网关服务1-2万人，后面的游戏服务器每台服务5k-<br>1w，依游戏类型和复杂度不同而已，图中隐藏了很多不重要的服务器，如登录和管理。这是目前应用最广的一个模型，到今天任然很多新项目会才用这样的结构来搭建。</p><p>人都是有惯性的，按照先前的经验，似乎把<br>MUDOS拆分的越开性能越好。于是大家继续想，网关可以拆分呀，基础服务如聊天交易，可以拆分呀，还可以提供web接口，数据库可以拆分呀，于是有了下面的模型：</p><p>![这里写图片描述](<a href="http://img.blog.csdn.net/20170224223843835?watermark/2/text/aHR0cDo">http://img.blog.csdn.net/20170224223843835?watermark/2/text/aHR0cDo</a><br>vL2Jsb2cuY3Nkbi5uZXQvdG9fYmVfYmV0dGVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFC<br>MA==/dissolve/70/gravity/SouthEast)</p><p>这样的模型好用么？确实有成功游戏使用类似这样的架构，并且发挥了它的性能优势，比如一些大型 MMORPG。但是有两个挑战：每增加一级服务器，状态机复杂度可能会<br>翻倍，导致研发和找bug的成本上升；并且对开发组挑战比较大，一旦项目时间吃紧，开发人员经验不足，很容易弄挂。</p><p>比如我见过某上海一线游戏公司的一个 RPG上来就要上这样的架构，我看了下他们团队成员的经验，问了下他们的上线日期，劝他们用前面稍微简单一点的模型。人家自信得<br>很，认为有成功项目是这么做的，他们也要这么做，自己很想实现一套。于是他们义无反顾的开始编码，项目做了一年多，然后，就没有然后了。</p><p>现今在游戏成功率不高的情况下，一开始上一套比较复杂的架构需要考虑投资回报率，比如你的游戏上线半年内 PCU会去到多少？如果一个 APRG游戏，每组服务器5千<br>人都到不了的话，那么选择一套更为贴近实际情况的结构更为经济。即使后面你的项目真的超过5千人朝着1万人目标奔的话，相信那个时候你的项目已经挣大钱了<br>，你数着钱加着班去逐步迭代，一次次拆分它，相信心里也是乐开花的。</p><p>上面这些类型基本都是从拆分 MUDOS开始，将<br>MUDOS中的各个部件从单机一步步拆成分布式。虽然今天任然很多新项目在用上面某一种类似的结构，或者自己又做了其他热点模块的拆分。因为他们本质上都是对<br>MUDOS的分解，故将他们归纳为第二代游戏服务器。</p><h2 id="类型4：第三代游戏服务器-2007"><a href="#类型4：第三代游戏服务器-2007" class="headerlink" title="类型4：第三代游戏服务器 2007"></a>类型4：第三代游戏服务器 2007</h2><p>从魔兽世界开始无缝世界地图已经深入人心，比较以往游戏玩家走个几步还需要切换场景，每次切换就要等待<br>LOADING个几十秒是一件十分破坏游戏体验的事情。于是对于 2005年以后的大型<br>MMORPG来说，无缝地图已成为一个标准配置。比较以往按照地图来切割游戏而言，无缝世界并不存在一块地图上面的人有且只由一台服务器处理了：</p><p>![这里写图片描述](<a href="http://img.blog.csdn.net/20170224224000477?watermark/2/text/aHR0cDo">http://img.blog.csdn.net/20170224224000477?watermark/2/text/aHR0cDo</a><br>vL2Jsb2cuY3Nkbi5uZXQvdG9fYmVfYmV0dGVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFC<br>MA==/dissolve/70/gravity/SouthEast)</p><p>每台 Node服务器用来管理一块地图区域，由 NodeMaster（NM）来为他们提供总体管理。更高层次的<br>World则提供大陆级别的管理服务。这里省略若干细节服务器，比如传统数据库前端，登录服务器，日志和监控等，统统用<br>ADMIN概括。在这样的结构下，玩家从一块区域走向另外一块区域需要简单处理一下：</p><p>![这里写图片描述](<a href="http://img.blog.csdn.net/20170224224040931?watermark/2/text/aHR0cDo">http://img.blog.csdn.net/20170224224040931?watermark/2/text/aHR0cDo</a><br>vL2Jsb2cuY3Nkbi5uZXQvdG9fYmVfYmV0dGVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFC<br>MA==/dissolve/70/gravity/SouthEast)</p><p>玩家1完全由节点A控制，玩家3完全由节点B控制。而处在两个节点边缘的2号玩家，则同时由A和B提供服务。玩家2从A移动到B的过程中，会同时向A请求左边的情况，<br>并向B请求右边的情况。但是此时玩家2还是属于A管理。直到玩家2彻底离开AB边界很远，才彻底交由B管理。按照这样的逻辑将世界地图分割为一块一块的区域，交由不同<br>的 Node去管理。</p><p>对于一个 Node所负责的区域，地理上没必要连接在一起，比如大陆的四周边缘部分和高山部分的区块人比较少，可以统一交给一个Node去管理，而这些区块在地理上并<br>没有联系在一起的必要性。一个 Node到底管理哪些区块，可以根据游戏实时运行的负载情况，定时维护的时候进行更改 NodeMaster 上面的配置。</p><p>于是碰到第一个问题是很多 Node服务器需要和玩家进行通信，需要问管理服务器特定UID为多少的玩家到底在哪台 Gate上，以前按场景切割的服务器这个问题不大<br>，问了一次以后就可以缓存起来了，但是现在服务器种类增加不少，玩家又会飘来飘去，按UID查找玩家比较麻烦；另外一方面 GATE需要动态根据坐标计算和哪些<br>Node通信，导致逻辑越来越厚，于是把：“用户对象”从负责连接管理的 GATE中切割出来势在必行于是有了下面的模型：</p><p>![这里写图片描述](<a href="http://img.blog.csdn.net/20170224224117349?watermark/2/text/aHR0cDo">http://img.blog.csdn.net/20170224224117349?watermark/2/text/aHR0cDo</a><br>vL2Jsb2cuY3Nkbi5uZXQvdG9fYmVfYmV0dGVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFC<br>MA==/dissolve/70/gravity/SouthEast)</p><p>网关服务器再次退回到精简的网络转发功能，而用户逻辑则由按照 UID划分的 OBJ服务器来承担，GATE是按照网络接入时的负载来分布，而<br>OBJ则是按照资源的编号（UID）来分布，这样和一个用户通信直接根据 UID计算出 OBJ服务器编号发送数据即可。而新独立出来的<br>OBJ则提供了更多高层次的服务：</p><ul><li>对象移动：管理具体玩家在不同的 Node所管辖的区域之间的移动，并同需要的 Node进行沟通。</li><li>数据广播：Node可以给每个用户设置若干 TAG，然后通知 Object Master 按照TAG广播。</li><li>对象消息：通用消息推送，给某个用户发送数据，直接告诉 OBJ，不需要直接和 GATE打交道。</li><li>好友聊天：角色之间聊天直接走 OBJ/OBJ MASTER。</li></ul><p>整个服务器主体分为三层以后，NODE专注场景，OBJ专注玩家对象，GATE专注网络。这样的模型在无缝场景服务器中得到广泛的应用。但是随着时间的推移，负载问题<br>也越来越明显，做个活动，远来不活跃的区域变得十分活跃，靠每周维护来调整还是比较笨重的，于是有了动态负载均衡。</p><p>动态负载均衡有两种方法，第一种是按照负载，由 Node Master 定时动态移动修改一下各个 Node的边界，而不同的玩家对象按照先前的方法从一台<br>Node上迁移到另外一台 Node上：</p><p>![这里写图片描述](<a href="http://img.blog.csdn.net/20170224224237256?watermark/2/text/aHR0cDo">http://img.blog.csdn.net/20170224224237256?watermark/2/text/aHR0cDo</a><br>vL2Jsb2cuY3Nkbi5uZXQvdG9fYmVfYmV0dGVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFC<br>MA==/dissolve/70/gravity/SouthEast)</p><p>这样 Node Master定时查找地图上的热点区域，计算新的场景切割方式，然后告诉其他服务器开始调整，具体处理方式还是和上面对象跨越边界移动的方法一样。</p><p>但是上面这种方式实现相对复杂一些，于是人们设计出了更为简单直接的一种新方法：</p><p>![这里写图片描述](<a href="http://img.blog.csdn.net/20170224224324803?watermark/2/text/aHR0cDo">http://img.blog.csdn.net/20170224224324803?watermark/2/text/aHR0cDo</a><br>vL2Jsb2cuY3Nkbi5uZXQvdG9fYmVfYmV0dGVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFC<br>MA==/dissolve/70/gravity/SouthEast)</p><p>还是将地图按照标准尺寸均匀切割成静态的网格，每个格子由一个具体的Node负责，但是根据负载情况，能够实时的迁移到其他<br>Node上。在迁移分为三个阶段：准备，切换，完成。三个状态由Node Master负责维护。准备阶段新的 Node开始同步老<br>Node上面该网格的数据，完成后告诉NM；NM确认OK后同时通知新旧 Node完成切换。完成切换后，如果 Obj服务器还在和老的 Node进行通信，老的<br>Node将会对它进行纠正，得到纠正的 OBJ将修正自己的状态，和新的 Node进行通信。</p><p>很多无缝动态负载均衡的服务端宣称自己支持无限的人数，但不意味着 MMORPG游戏的人数上限真的可以无限扩充，因为这样的体系会受制于网络带宽和客户端性能。带宽<br>决定了同一个区域最大广播上限，而客户端性能决定了同一个屏幕到底可以绘制多少个角色。</p><p>从无缝地图引入了分布式对象模型开始，已经完全脱离 MUDOS体系，成为一种新的服务端模型。又由于动态负载均衡的引入，让无缝服务器如虎添翼，容纳着超过上一代游<br>戏服务器数倍的人数上限，并提供了更好的游戏体验，我们称其为第三代游戏服务端架构。网游以大型多人角色扮演为开端，RPG网游在相当长的时间里一度占据90%以上，<br>使得基于 MMORPG的服务端架构得到了蓬勃的发展，然而随着玩家对RPG的疲惫，各种非MMORPG游戏如雨后春笋般的出现在人们眼前，受到市场的欢迎。</p><h2 id="类型5：战网游戏服务器"><a href="#类型5：战网游戏服务器" class="headerlink" title="类型5：战网游戏服务器"></a>类型5：战网游戏服务器</h2><p>经典战网服务端和 RPG游戏有两个区别：RPG是分区分服的，北京区的用户和广州区的用户老死不相往来。而战网，虽然每局游戏一般都是<br>8人以内，但全国只有一套服务器，所有的玩家都可以在一起游戏，而玩家和玩家之使用 P2P的方式连接在一起，组成一局游戏：</p><p>![这里写图片描述](<a href="http://img.blog.csdn.net/20170224224448023?watermark/2/text/aHR0cDo">http://img.blog.csdn.net/20170224224448023?watermark/2/text/aHR0cDo</a><br>vL2Jsb2cuY3Nkbi5uZXQvdG9fYmVfYmV0dGVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFC<br>MA==/dissolve/70/gravity/SouthEast)</p><p>玩家通过 Match Making 服务器使用：创建、加入、自动匹配、邀请 等方式组成一局游戏。服务器会选择一个人做 Host，其他人<br>P2P连接到做主的玩家上来。STUN是帮助玩家之间建立 P2P的牵引服务器，而由于 P2P联通情况大概只有 75%，实在联不通的玩家会通过<br>Forward进行转发。</p><p>大量的连接对战，体育竞技游戏采用类似的结构。P2P有网状模型（所有玩家互相连接），和星状模型（所有玩家连接一个主玩家）。复杂的游戏状态在网状模型下难以形成一<br>致，因此星状P2P模型经受住了历史的考验。除去游戏数据，支持语音的战网系统也会将所有人的语音数据发送到做主的那个玩家机器上，通过混音去重再编码的方式返回给所<br>有用户。</p><p>战网类游戏，以竞技、体育、动作等类型的游戏为主，较慢节奏的 RPG（包括ARPG）有本质上的区别，而激烈的游戏过程必然带来到较<br>RPG复杂的多的同步策略，这样的同步机制往往带来的是很多游戏结果由客户端直接计算得出，那在到处都是破解的今天，如何保证游戏结果的公正呢？</p><p>主要方法就是投票法，所有客户端都会独立计算，然后传递给服务器。如果结果相同就更新记录，如果结果不一致，会采取类似投票的方式确定最终结果。同时记录本剧游戏的所<br>有输入，在可能的情况下，找另外闲散的游戏客户端验算整局游戏是否为该结果。并且记录经常有作弊嫌疑的用户，供运营人员封号时参考。</p><h2 id="类型7：休闲游戏服务器"><a href="#类型7：休闲游戏服务器" class="headerlink" title="类型7：休闲游戏服务器"></a>类型7：休闲游戏服务器</h2><p>休闲游戏同战网服务器类似，都是全区架构，不同的是有房间服务器，还有具体的游戏服务器，游戏主体不再以玩家 P2P进行，而是连接到专门的游戏服务器处理：</p><p>![这里写图片描述](<a href="http://img.blog.csdn.net/20170224224617523?watermark/2/text/aHR0cDo">http://img.blog.csdn.net/20170224224617523?watermark/2/text/aHR0cDo</a><br>vL2Jsb2cuY3Nkbi5uZXQvdG9fYmVfYmV0dGVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFC<br>MA==/dissolve/70/gravity/SouthEast)</p><p>和战网一样的全区架构，用户数据不能象分区的 RPG那样一次性load到内存，然后在内存里面直接修改。全区架构下，为了应对一个用户同时玩几个游戏，用户数据需要<br>区分基本数据和不同的游戏数据，而游戏数据又需要区分积分数据、和文档数据。胜平负之类的积分可以直接提交增量修改，而更为普遍的文档类数据则需要提供读写令牌，写令<br>牌只有一块，读令牌有很多块。同帐号同一个游戏同时在两台电脑上玩时，最先开始的那个游戏获得写令牌，可以操作任意的用户数据。而后开始的那个游戏除了可以提交胜平负<br>积分的增量改变外，对用户数据采用只读的方式，保证游戏能运行下去，但是会提示用户，游戏数据锁定。</p><h2 id="类型8：现代动作类网游"><a href="#类型8：现代动作类网游" class="headerlink" title="类型8：现代动作类网游"></a>类型8：现代动作类网游</h2><p>从早期的韩国动作游戏开始，传统的战网动作类游戏和 RPG游戏开始尝试融合。单纯的动作游戏玩家容易疲倦，留存也没有 RPG那么高；而单纯<br>RPG战斗却又慢节奏的乏味，无法满足很多玩家激烈对抗的期望，于是二者开始融合成为新一代的：动作 + 城镇<br>模式。玩家在城镇中聚集，然后以开副本的方式几个人出去以动作游戏的玩法来完成各种 RPG任务。本质就是一套<br>RPG服务端+副本服务端。由于每次副本时人物可以控制在8人以内，因此可以获得更为实时的游戏体验，让玩家玩的更加爽快。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>说了那么多的游戏服务器类型，其实也差不多了，剩下的类型大家拼凑一下其实也就是这个样子而已。游戏服务端经历了那么多结构上的变迁，内部开发模式是否依然不变？究竟<br>是继续延续传统的开发方式？还是有了更多突破性的方法？经历那么多次架构变迁，后面是否有共通的逻辑？未来的发展还会存在哪些困难？游戏服务端开发如何达到最终的彼岸<br>？</p><p>转自 <a href="https://www.zhihu.com/question/29779732/answer/45791817"> 知乎：端游、手游服务端常用的架构是什么样的？</a></p>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>游戏开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TCP协议-TCP服务特点和头部结构</title>
    <link href="/posts/11603.html"/>
    <url>/posts/11603.html</url>
    
    <content type="html"><![CDATA[<h2 id="TCP服务特点"><a href="#TCP服务特点" class="headerlink" title="TCP服务特点"></a>TCP服务特点</h2><p>** 面向连接、基于字节流和可靠传输 ** 。</p><h3 id="TCP的面向连接是什么意思？"><a href="#TCP的面向连接是什么意思？" class="headerlink" title="TCP的面向连接是什么意思？"></a>TCP的面向连接是什么意思？</h3><p>通信双方都必须 ** 先建立连接 ** ，然后才能 ** 开始数据的读写 ** ，双方都必须为该连接分配必要的内核资源，以管理连接的状态和连接上数据的传输。<br>同时，TCP连接是全双工的，就是说， ** 双方数据的读写，可以通过一个连接进行，完成数据交换之后，通信双方都必须断开连接，以释放系统资源 **<br>。而且，TCP连接是一对一的，所以，基于广播和多播的应用程序不能使用TCP服务，而无连接协议UDP，倒非常适合广播和多播。</p><h3 id="字节流服务和通信报区别"><a href="#字节流服务和通信报区别" class="headerlink" title="字节流服务和通信报区别"></a>字节流服务和通信报区别</h3><p>主要体现在通信双方是否执行相同次数的读写操作。</p><p>![这里写图片描述](<a href="http://img.blog.csdn.net/20170220000621489?watermark/2/text/aHR0cDo">http://img.blog.csdn.net/20170220000621489?watermark/2/text/aHR0cDo</a><br>vL2Jsb2cuY3Nkbi5uZXQvdG9fYmVfYmV0dGVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFC<br>MA==/dissolve/70/gravity/SouthEast)</p><p>如图所示，当发送端应用程序同时执行多次写操作时，TCP模块必须先将这些数据放入发送缓冲区中，当TCP模块真正发送数据时，发送缓冲区中这些数据才会被封装成一个<br>或多个TCP报文段发出，简言之， ** TCP模块发出的报文段个数与发送端应用程序执行的写操作次数之间没有固定的数量关系 ** 。<br>同时，当接收端收到一个或多个TCP报文段后，TCP模块要将它们携带的应用数据根据的TCP报文段的序号依次放入接收缓冲区中，同时通知应用程序读取数据。接收端应<br>用程序可以将接收缓冲区中的数据一次读出，也可以多次读出，这取决于用户指定的应用程序读缓冲区大小，简言之， **<br>接收端应用程序执行的读操作次数与TCP模块接收到的TCP报文段个数也没有固定的数量关系。 **<br>总而言之就是， ** 发送端执行的写操作数量和接收端执行的读操作数量之间没有任何的数量关系 ** 。<br>通信双方数据传输是没有边界的，这也就是TCP的字节流的概念。<br>![这里写图片描述](<a href="http://img.blog.csdn.net/20170220000632880?watermark/2/text/aHR0cDo">http://img.blog.csdn.net/20170220000632880?watermark/2/text/aHR0cDo</a><br>vL2Jsb2cuY3Nkbi5uZXQvdG9fYmVfYmV0dGVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFC<br>MA==/dissolve/70/gravity/SouthEast)<br>而UDP的数据报截然相反，发送端应用程序每执行一次写操作，接收端应用程序都必须执行一次对应的读操作。否则，就会发生丢包。并且，如果用户没有指定足够的应用数据<br>缓冲区来读取数据报，那么UDP数据报就会发生截断。</p><h3 id="TCP的可靠传输是由何支撑的："><a href="#TCP的可靠传输是由何支撑的：" class="headerlink" title="TCP的可靠传输是由何支撑的："></a>TCP的可靠传输是由何支撑的：</h3><h4 id="发送应答机制"><a href="#发送应答机制" class="headerlink" title="** 发送应答机制 **"></a>** 发送应答机制 **</h4><p>发送端发送的每个TCP报文段都必须得到接收端的应答，才认为这个TCP报文段传输成功。</p><h4 id="超时重传机制"><a href="#超时重传机制" class="headerlink" title="** 超时重传机制 **"></a>** 超时重传机制 **</h4><p>发送端在发出一个TCP报文段之后，就开始定时，如果在定时时间内没有收到应答，就会重新发送这个报文段。<br>同时，TCP报文段最终是以IP数据报发送的，而IP数据报到达接收端时可能乱序、重复，TCP协议还会对接收到的TCP报文段重排、整理，再交付给应用程序。<br>而UDP数据报服务则不可靠，需要上层协议处理数据的确认和超时重传。</p><h2 id="TCP头部结构"><a href="#TCP头部结构" class="headerlink" title="TCP头部结构"></a>TCP头部结构</h2><p>通过了解TCP头部结构，我们可以认识到传输层在TCP协议栈中的作用。<br>TCP头部信息用于指定通信源端端口，目标端端口，管理连接等这些任务。如下图所示：<br>![这里写图片描述](<a href="http://img.blog.csdn.net/20170220000451567?watermark/2/text/aHR0cDo">http://img.blog.csdn.net/20170220000451567?watermark/2/text/aHR0cDo</a><br>vL2Jsb2cuY3Nkbi5uZXQvdG9fYmVfYmV0dGVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFC<br>MA==/dissolve/70/gravity/SouthEast)</p><h4 id="32位序号"><a href="#32位序号" class="headerlink" title="** 32位序号 **"></a>** 32位序号 **</h4><blockquote><p>在一次TCP通信，从连接建立到释放连接的整个过程中，在某一个传输方向上的字节流的每个字节的编号就是由这个32位序号确认的。<br>在两个主机通信时，第一次发送的TCP报文段中，32位序号为系统给出的随机值，我们称它为初始序号(ISN)，在该传输方向上，后续的TCP报文段中，序号，将被系<br>统设置为ISN+该报文段所携带数据的第一个字节在整个字节流中位置的偏移。<br>另外一个传输方向上，亦然。</p></blockquote><h4 id="32位确认号"><a href="#32位确认号" class="headerlink" title="** 32位确认号 **"></a>** 32位确认号 **</h4><blockquote><p>TCP报文段中，发送方不仅携带自己的数据序号，还携带对通信另一方所发送的数据的确认。</p></blockquote><h4 id="4位头部长度"><a href="#4位头部长度" class="headerlink" title="** 4位头部长度 **"></a>** 4位头部长度 **</h4><blockquote><p>标识该TCP头部有多少个4字节，最大值是15，所以TCP头部最大长度是60个字节。</p></blockquote><h4 id="6位标志字段"><a href="#6位标志字段" class="headerlink" title="** 6位标志字段 **"></a>** 6位标志字段 **</h4><ul><li>** URG ** ：紧急指针是否有效。</li><li>** ACK ** ：确认号是否有效（我们称携带ACK标志的TCP报文段为确认报文段）。</li><li>** PSH ** ：push字段，提示接收端程序应该立即从TCP接收缓冲区中读走数据，为接收后续数据腾出空间，因为应用程序如果不把这些数据读走，这些数据会一直停留在TCP接收缓冲区中，这样会占用很大的内核资源。</li><li>** RST ** ：要求对方重新建立连接（复位报文段）</li><li>** SYN ** ：表示请求建立一个连接（同步报文段）</li><li>** FIN ** ：通知对方关闭连接（结束报文段）</li><li>** 16位窗口大小 **</li></ul><blockquote><p>是TCP流量控制的手段。这里的窗口指接收通报窗口（Receiver<br>window），提示本端TCP接收缓冲区还能容纳多少字节数据，这样对方就可以控制数据发送的速度。</p></blockquote><ul><li>16位校验和</li></ul><blockquote><p>由发送端填充，接收端对TCP报文段执行CRC算法，来检验数据是否损坏。该检验不仅包括头部，也包括数据部分。</p></blockquote><ul><li>16位紧急指针</li></ul><blockquote><p>表示最后一个紧急数据的下一字节序号。</p></blockquote><p>![这里写图片描述](<a href="http://img.blog.csdn.net/20170220000541380?watermark/2/text/aHR0cDo">http://img.blog.csdn.net/20170220000541380?watermark/2/text/aHR0cDo</a><br>vL2Jsb2cuY3Nkbi5uZXQvdG9fYmVfYmV0dGVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFC<br>MA==/dissolve/70/gravity/SouthEast)</p><h4 id="40选项"><a href="#40选项" class="headerlink" title="40选项"></a>40选项</h4><p>kind类型 length总长度 info具体信息（常见TCP选项具体信息如下）</p><p>![这里写图片描述](<a href="http://img.blog.csdn.net/20170220022113004?watermark/2/text/aHR0cDo">http://img.blog.csdn.net/20170220022113004?watermark/2/text/aHR0cDo</a><br>vL2Jsb2cuY3Nkbi5uZXQvdG9fYmVfYmV0dGVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFC<br>MA==/dissolve/70/gravity/SouthEast)</p><blockquote><p>0： ** 选项表结束选项 **<br>1： ** 空操作选项 ** 。无特殊含义，一般用于将TCP选项的总长度填充为4字节的整数倍。<br>2： ** 最大报文段长度选项 ** 。连接初始化时，通信双方使用该选项来协商最大报文段长度。TCP模块通常将最大报文段长度设为MTU-40，这里的40指2<br>0字节的TCP头部和20字节的TCP头部，这样一来，携带TCP报文段的IP数据报的长度就不会超过MTU。<br>** ps：MTU即 _ 最大传输单元 _ ，该参数通常与通信接口有关（网络接口卡、串口等）。 **<br>3： ** 窗口扩大因子选项 ** 。TCP连接初始化时，通信双方使用该选项协商接收通道窗口扩大因子的大小。因为在TCP协议中，接收通道窗口的大小是用16位<br>表示的，也就是65535个字节，但实际上TCP模块允许的接收通道窗口远不止这个数目，比这个大是为了提高通信的吞吐量，窗口扩大因子就是为了解决这个问题。<br>如果窗口大小位N，而窗口扩大因子为M，那么窗口实际大小就是N*(2^M)。窗口扩大因子选项只能出现在同步报文段中，当连接建立成功之后，该值将固定不变。<br>4： ** 选择性确认(SACK)选项 ** 。当TCP报文段发生丢失时，TCP模块就会重传最后被确认的TCP报文段之后的所有报文段，但这样的话，原先已经成<br>功发送的报文段也可能重复发送，就降低了TCP模块的性能。选择定确认选项就是为了解决这个问题，它让TCP模块儿只重新发送丢失的TCP报文段。<br>5： ** SACK实际工作的选项 ** 。告诉发送端，本端已经收到的不连续的数据块，从而让发送端根据此选项重新发送丢失的数据块。其中块左边沿表示不连续块的<br>第一个数据的序号，而块右边沿则表示不连续块的最后一个数据的序号的下一个序号。这样一对参数（块左边沿和块右边沿）之间的数据是没有收到的。因为一个块信息占用8字<br>节，所以TCP头部选项中实际上最多可以包含4个这样的不连续数据块（考虑选项类型和长度占用的2字节）。<br>8： ** 时间戳选项 ** 。提供比较准确的计算通信双方之间的回路时间的方法。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux内存管理机制</title>
    <link href="/posts/23478.html"/>
    <url>/posts/23478.html</url>
    
    <content type="html"><![CDATA[<p>在Linux中经常发现空闲内存很少，似乎所有的内存都被系统占用了，表面感觉是内存不够用了，其实不然。这是Linux内存管理的一个优秀特性，主要特点是，无论物<br>理内存有多大，Linux 都将其充份利用，将一些程序调用过的硬盘数据读入内存（buffer/cache），利用内存读写的高速特性来提高Linux系统的数据访<br>问性能。在这方面，区别于Windows的内存管理。本文从Linux的内存管理机制入手，简单介绍linux如何使用内存、监控内存，linux与windows内<br>存管理上的区别简介，linux内存使用的一大特点（buffer/cache的异同）。</p><h2 id="一、Linux内存管理机制"><a href="#一、Linux内存管理机制" class="headerlink" title="一、Linux内存管理机制"></a>一、Linux内存管理机制</h2><h3 id="物理内存和虚拟内存"><a href="#物理内存和虚拟内存" class="headerlink" title="物理内存和虚拟内存"></a>物理内存和虚拟内存</h3><p>我们知道，直接从物理内存读写数据要比从硬盘读写数据要快的多，因此，我们希望所有数据的读取和写入都在内存完成，而内存是有限的，这样就引出了物理内存与虚拟内存的<br>概念。</p><p>物理内存就是系统硬件提供的内存大小，是真正的内存，相对于物理内存，在linux下还有一个虚拟内存的概念，虚拟内存就是为了满足物理内存的不足而提出的策略，它是<br>利用磁盘空间虚拟出的一块逻辑内存，用作虚拟内存的磁盘空间被称为交换空间（Swap Space）。</p><p>作为物理内存的扩展，linux会在物理内存不足（注意这一条件，这一条件的量化分析请参考 <a href="https://www.douban.com/note/349467816/"><br>https://www.douban.com/note/349467816/</a> ）时，使用交换分区的虚拟内存，更详细的说，就是内核会将暂时不用的内存块信<br>息写到交换空间，这样以来，物理内存得到了释放，这块内存就可以用于其它目的，当需要用到原始的内容时，这些信息会被重新从交换空间读入物理内存。</p><p>Linux的内存管理采取的是分页存取机制（详细可参考 <a href="http://www.linuxeye.com/Linux/1931.html"> http://www.linuxeye.com/Linux/1931.html</a> ），为了保证物<br>理内存能得到充分的利用，内核会在适当的时候将物理内存中不经常使用的数据块自动交换到虚拟内存中，而将经常使用的信息保留到物理内存。</p><p>要深入了解linux内存运行机制，需要知道下面提到的几个方面：Linux系统会根据系统配置不时地进行页面交换操作，以保持一定量的空闲物理内存，有些配置下即使<br>并没有什么事情需要内存，Linux也会交换出暂时不用的内存页面。这可以避免等待交换所需的时间。相关的配置有/etc/sysctl.conf中的vm.swap<br>piness配置（配制方法请参考 <a href="http://www.vcaptain.com/?id=17"> http://www.vcaptain.com/?id=17</a> ），该参数的作用简单描述就是“当 swappiness 内容的值为 0<br>时，表示最大限度地使用物理内存，物理内存使用完毕后，才会使用 swap 分区；当 swappiness 内容的值为 100 时，表示积极地使用 swap<br>分区，并且把内存中的数据及时地置换到 swap 分区。Linux 系统初始安装完成时，其默认值为 60, 这表示空闲物理内存少于 60%<br>时开始启用内存置换算法，将内存中不常使用的数据置换到 swap 分区。”（具体如何起作用请参考 <a href="https://www.douban.com/note/349467816/"><br>https://www.douban.com/note/349467816/</a> ）</p><p>Linux 进行页面交换是有条件的，不是所有页面在不用时都交换到虚拟内存，linux内核根据”最近最经常使用“算法，仅仅将一些不经常使用的页面文件交换到虚拟<br>内存，有时我们会看到这么一个现象：linux物理内存还有很多，但是交换空间也使用了很多。其实，这并不奇怪，例如：一个占用很大内存的进程运行时，需<br>要耗费很多内存资源，此时就会有一些不常用页面文件被交换到虚拟内存中，但后来这个占用很多内存资源的进程结束并释放了很多内存时，刚才被交换出去的页面<br>文件并不会自动的交换进物理内存，除非有这个必要，那么此刻系统物理内存就会空闲很多，同时交换空间也在被使用，就出现了刚才所说的现象了。关于这点，不<br>用担心什么，只要知道是怎么一回事就可以了。<br>交换空间的页面在使用时会首先被交换到物理内存，如果此时没有足够的物理内存来容纳这些页<br>面，它们又会被马上交换出去，如此以来，虚拟内存中可能没有足够空间来存储这些交换页面，最终会导致linux出现假死机、服务异常等问题，linux虽<br>然可以在一段时间内自行恢复，但是恢复后的系统已经基本不可用了。</p><p>分配太多的Swap空间会浪费磁盘空间，而Swap空间太少，则系统会发生错误。<br>如果系统的物理内存用光了，系统就会跑得很慢，但仍能运行；如果Swap空间用光了，那么系统就会发生错误。例如，Web服务器能根据不同的请求数量衍生<br>出多个服务进程（或线程），如果Swap空间用完，则服务进程无法启动，通常会出现“application is out of<br>memory”的错误，严重时会造成服务进程的死锁。因此Swap空间的分配是很重要的。</p><p>因此，合理规划和设计Linux内存的使用，是非常重要的。</p><h2 id="二、linux和windows内存管理的区别"><a href="#二、linux和windows内存管理的区别" class="headerlink" title="二、linux和windows内存管理的区别"></a>二、linux和windows内存管理的区别</h2><p>Linux 优先使用物理内存，当物理内存还有空闲时，linux是不会释放内存的，即时占用内存的程序已经被关闭了（这部分内存就用来做缓存了）。也就是说，即时你<br>有很大的内存,用过一段时间后，也会被占满。这样做的好处是，启动那些刚开启过的程序、或是读取刚存取过得数据会比较快，对于服务器很有好处。<br>windows则总是给内存留下一定的空闲空间，即时内存有空闲也会让程序使用一些虚拟内存，这样做的好处是，启动新的程序比较快，直接分给它些空闲<br>内存就可以了，而linux下呢？由于内存经常处于全部被使用的状态，则要先清理出一块内存，再分配给新的程序使用，因此，新程序的启动会慢一些。</p><h2 id="三、buffers与cached"><a href="#三、buffers与cached" class="headerlink" title="三、buffers与cached"></a>三、buffers与cached</h2><p>异同点</p><p>在Linux<br>操作系统中，当应用程序需要读取文件中的数据时，操作系统先分配一些内存，将数据从磁盘读入到这些内存中，然后再将数据分发给应用程序；当需要往文件中写<br>数据时，操作系统先分配内存接收用户数据，然后再将数据从内存写到磁盘上。然而，如果有大量数据需要从磁盘读取到内存或者由内存写入磁盘时，系统的读写性<br>能就变得非常低下，因为无论是从磁盘读数据，还是写数据到磁盘，都是一个很消耗时间和资源的过程，在这种情况下，Linux引入了buffers和<br>cached机制。</p><p>buffers与cached都是内存操作，用来保存系统曾经打开过的文件以及文件属性信息，这样当操作系统需要读取某些文件时，会首先在buffers<br>与cached内存区查找，如果找到，直接读出传送给应用程序，如果没有找到需要数据，才从磁盘读取，这就是操作系统的缓存机制，通过缓存，大大提高了操<br>作系统的性能。但buffers与cached缓冲的内容却是不同的。</p><p>buffers是用来缓冲块设备做的，它只记录文件系统的元数据（metadata）以及 tracking in-flight pages，而cached是用来<br>给文件做缓冲。更通俗一点说：buffers主要用来存放目录里面有什么内容，文件的属性以及权限等等。而cached直接用来记忆我们打开过的文件和程序。</p><p>内存释放</p><p>linux系统中/proc是一个虚拟文件系统，我们可以通过对它的读写操作做为与kernel实体间进行通信的一种手段。也就是说可以通过修改/proc中的文件，<br>来对当前kernel的行为做出调整。那么我们可以通过调整/proc/sys/vm/drop_caches来释放内存。</p><h2 id="四、Linux-进程在内存数据结构"><a href="#四、Linux-进程在内存数据结构" class="headerlink" title="四、Linux 进程在内存数据结构"></a>四、Linux 进程在内存数据结构</h2><p>可以看到一个可执行程序在存储（没有调入内存）时分为代码段，数据段，未初始化数据段三部分：</p><ul><li><p>代码段：存放CPU执行的机器指令。通常代码区是共享的，即其它执行程序可调用它。假如机器中有数个进程运行相同的一个程序，那么它们就可以使用同一个代码段。</p></li><li><p>数据段：存放已初始化的全局变量，静态变量（包括全局和局部的），常量。static全局变量和static函数只能在当前文件中被调用。</p></li><li><p>未初始化数据区（uninitializeddata segment,BSS)：存放全局未初始化的变量。BSS的数据在程序开始执行之前被初始化为0或NULL。<br>代码区所在的地址空间最低，往上依次是数据区和BSS区，并且数据区和BSS区在内存中是紧挨着的。。<br>可执行程序在运行时又多出了两个区域：栈段（Stack）和堆段(Heap)。</p></li><li><p>栈区:由编译器自动释放，存放函数的参数值，局部变量等。每当一个函数被调用时，该函数的返回类型和一些调用的信息被存储到栈中。然后这个被调用的函数再为它的自动变量和临时变量在栈上分配空间。每调用一个函数一个新的栈就会被使用。栈区是从高地址位向低地址位增长的，是一块连续的内在区域，最大容量是由系统预先定义好的，申请的栈空间超过这个界限时会提示溢出，用户能从栈中获取的空间较小。</p></li><li><p>堆段:用于存放进程运行中被动态分配的内存段，位于BSS和栈中间的地址位。由程序员申请分配（malloc)和释放（free）。堆是从低地址位向高地址位增长，采用链式存储结构。频繁地malloc/free造成内存空间的不连续，产生碎片。当申请堆空间时库函数按照一定的算法搜索可用的足够大的空间。因此堆的效率比栈要低的多。</p></li></ul><p>这个5中内存区域中数据段、BSS和堆通常是被连续存储的——内存位置上是连续的，而代码段和栈往往会被独立存放。有趣的是堆和栈两个区域关系很“暧昧”，他们一个向<br>下“长”（i386体系结构中栈向下、堆向上），一个向上“长”，相对而生。但你不必担心他们会碰头，因为他们之间间隔很大（到底大到多少，你可以从下面的例子程序计<br>算一下），绝少有机会能碰到一起。</p><p>下图简要描述了进程内存区域的分布：<br>![这里写图片描述](<a href="http://img.blog.csdn.net/20170216040311862?watermark/2/text/aHR0cDo">http://img.blog.csdn.net/20170216040311862?watermark/2/text/aHR0cDo</a><br>vL2Jsb2cuY3Nkbi5uZXQvdG9fYmVfYmV0dGVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFC<br>MA==/dissolve/70/gravity/SouthEast)</p><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>Linux操作系统的内存运行原理，很大程度上是根据服务器的需求来设计的，例如系统的缓冲机制会把经常使用到的文件和数据缓存在cached<br>中，linux总是在力求缓存更多的数据和信息，这样再次需要这些数据时可以直接从内存中取，而不需要有一个漫长的磁盘操作，这种设计思路提高了系统的整 体性能。</p>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux网络编程</tag>
      
      <tag>Linux系统编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TCP建立连接为什么是三次握手，为什么不是两次或四次?</title>
    <link href="/posts/60892.html"/>
    <url>/posts/60892.html</url>
    
    <content type="html"><![CDATA[<h3 id="什么是三次握手"><a href="#什么是三次握手" class="headerlink" title="什么是三次握手"></a>什么是三次握手</h3><p>学过网络编程的人，应该都知道TCP建立连接的三次握手，下面简单描述一下这个过程。<br>![这里写图片描述](<a href="http://img.blog.csdn.net/20170209153734959?watermark/2/text/aHR0cDo">http://img.blog.csdn.net/20170209153734959?watermark/2/text/aHR0cDo</a><br>vL2Jsb2cuY3Nkbi5uZXQvdG9fYmVfYmV0dGVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFC<br>MA==/dissolve/70/gravity/SouthEast)</p><blockquote><p>** 如图所示 **<br>** 第一次握手 ** ：客户端发送TCP包，置SYN标志位为1，将初始序号X，保存在包头的序列号(Seq)里。<br>** 第二次握手 ** ：服务端回应确认包，置SYN标志位为1，置ACK为X+1，将初始序列号Y，保存在包头的序列号里。<br>** 第三次握手 ** ：客户端对服务端的确认包进行确认，置SYN标志位为0，置ACK为Y+1，置序列号为Z。</p></blockquote><h3 id="为什么不是两次"><a href="#为什么不是两次" class="headerlink" title="为什么不是两次"></a>为什么不是两次</h3><p>我们先来将三次握手这个过程捋一遍。(S-服务端，C-客户端)</p><blockquote><p>第一次握手后，S可以确认自己收报文与C发报文的功能都正常，而C呢，它什么都不能确认。<br>第二次握手后，C可以确认自己的收发报文与S的收发报文功能都正常，也就是认为连接已建立。<br>那么第三次呢，S也可以确认双方能够正常通信。</p></blockquote><p>假想一下，如果我们去掉了第三次呢？<br>因为我们不进行第三次握手，所以在S对C的请求进行回应(第二次握手)后，就会理所当然的认为连接已建立，而如果C并没有收到S的回应呢？此时，C仍认为连接未建立，<br>S会对已建立的连接保存必要的资源，如果大量的这种情况，S会崩溃。<br>** 因此第三次握手是必要的。 **</p><h3 id="为什么不是四次"><a href="#为什么不是四次" class="headerlink" title="为什么不是四次"></a>为什么不是四次</h3><p>首先，如果乐于思考的同学应该会对上面有这样的疑问：</p><pre><code class="hljs">既然没法确认第二次的握手，C是否可以收到，那么怎么确定第三次握手S就可以收到呢？</code></pre><p>不错，这根本没法确定，因为完全可靠的通信协议是根本不存在的，我们任何的通信协议都是在接受这样的现实情况之上进行的。<br>而三次握手后，C和S至少可以确认之前的通信情况，但无法确认之后的情况。<br>在这个道理上说，无论是四次还是五次或是更多次都是徒劳的。</p>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>三步实现自动注册工厂替代switch语句(c++)</title>
    <link href="/posts/34435.html"/>
    <url>/posts/34435.html</url>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>在学长博客里看到了使用自动注册工厂替代switch语句的文章，想到可以将其用到自己的项目里，就照猫画虎学习着也实现了一个。<br>这里并不是用其替代创建派生类的传统Factory，而是为了替代服务器中的业务逻辑处理。<br>记得以前实现的第一个服务器项目：聊天室，里面在解包后，是一长串的switch语句，根据包里类型标志，来决定该如何处理，写起来舒服，可看起来，包括后期维护，实<br>在是太不方便，因为想使用自动注册工厂这种模式来解决这个问题。</p><pre><code class="hljs">我这里的自动注册工厂是针对服务器项目收到包之后进行逻辑处理的语句冗余问题。但思路与代码基本适用于绝大多数需要使用自动注册工厂的情况。</code></pre><h3 id="以前的方式"><a href="#以前的方式" class="headerlink" title="以前的方式"></a>以前的方式</h3><pre><code class="hljs">switch(type)&#123;    case 1:        do_login();    case 2:        do_register();    case 3:        do_something();    case ...    ........&#125;</code></pre><p>显然，在业务逻辑并不多的时候，这样的方式也无伤大雅，那么假设业务逻辑很多呢，switch语句该有多长，无论是维护还是阅读都很不便。<br>那么，我们来看下一种方式。</p><h3 id="自动注册工厂"><a href="#自动注册工厂" class="headerlink" title="自动注册工厂"></a>自动注册工厂</h3><h4 id="逻辑处理基类"><a href="#逻辑处理基类" class="headerlink" title="逻辑处理基类"></a>逻辑处理基类</h4><p>这里只简单的实现了基本的构造函数，和逻辑处理函数</p><pre><code class="hljs">class action&#123;public:    action()    &#123;        std::cout&lt;&lt;&quot;action&quot;&lt;&lt;std::endl;    &#125;    virtual void doAction()    &#123;        std::cout&lt;&lt;&quot;doAction&quot;&lt;&lt;std::endl;    &#125;&#125;;</code></pre><h4 id="登陆逻辑处理派生类"><a href="#登陆逻辑处理派生类" class="headerlink" title="登陆逻辑处理派生类"></a>登陆逻辑处理派生类</h4><pre><code class="hljs">class login_action : public action &#123;public:    login_action()    &#123;        std::cout&lt;&lt;&quot;login_action&quot;&lt;&lt;std::endl;    &#125;    void doAction()    &#123;        std::cout&lt;&lt;&quot;do_login_action&quot;&lt;&lt;std::endl;    &#125;&#125;;REGISTER_ACTION(login_action, &quot;login_action&quot;);</code></pre><h4 id="注册逻辑处理派生类"><a href="#注册逻辑处理派生类" class="headerlink" title="注册逻辑处理派生类"></a>注册逻辑处理派生类</h4><pre><code class="hljs">class register_action : public action&#123;public:    register_action()    &#123;        std::cout&lt;&lt;&quot;register_action&quot;&lt;&lt;std::endl;    &#125;    void doAction()    &#123;        std::cout&lt;&lt;&quot;do_register_action&quot;&lt;&lt;std::endl;    &#125;&#125;;REGISTER_ACTION(register_action, &quot;register_action&quot;);</code></pre><h4 id="工厂类"><a href="#工厂类" class="headerlink" title="工厂类"></a>工厂类</h4><p>这个类是我们自动注册工厂的核心类。</p><h5 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h5><p>首先，我们要将其设计为单例模式，为了规范，我们将其拷贝构造函数和移动构造函数都设置为私有的，令其不可拷贝与构造，类似于boost::noncopyable。<br>并定义一个私有变量，为map类型，键为string，值为可返回一个派生类对象的function。<br>如下:</p><pre><code class="hljs">&#123;public:private:    factory() = default;    factory(const factory&amp;) = delete;    factory(factory&amp;&amp;) = delete;    static factory &amp;get()    &#123;        static factory instance;        return instance;    &#125;    std::map&lt;std::string, std::function&lt;action*(void)&gt;&gt; m_map;&#125;;</code></pre><h5 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h5><p>在factory内实现一个内部类Register，便于扩展，我将其设置为了模板类型。<br>为什么要设置为内部类呢，因为设置为内部类我们就可以使用外部类的私有成员(我们为规范，将map设置为私有的)，同时也因为其与工厂类本身就是一体，写在一起也更合<br>逻辑。<br>构造函数：传入一个标志key，将其作为键写入map，值为一个lambda表达式，返回一个派生类对象指针。</p><pre><code class="hljs">    template &lt;typename F&gt;    struct Register    &#123;        Register(const std::string&amp; key)        &#123;            factory::get().m_map.emplace(key, []&#123;                return new F();            &#125;);        &#125;        template&lt;typename... Args&gt;        Register(const std::string&amp; key, Args... args)        &#123;            factory::get().m_map.emplace(key, [&amp;]&#123;                return new F(args...);            &#125;);        &#125;    &#125;;注：emplace操作是C++11新特性，新引入的的三个成员emlace_front、empace 和 emplace_back,这些操作构造而不是拷贝元素到容器中，这些操作分别对应push_front、insert 和push_back，允许我们将元素放在容器头部、一个指定的位置和容器尾部。(目的是减少一次拷贝)</code></pre><h5 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h5><p>使用宏来简化工厂注册步骤</p><pre><code class="hljs">#define REGISTER_ACTION_NAME(T) msg_name_##T##_#define REGISTER_ACTION(T, key, ...) \static factory::Register&lt;T&gt; REGISTER_ACTION_NAME(T)(key,##__VA_ARGS__)注:##起将左右字符衔接的作用   __VA_ARGS__ 是一个可变参数的宏，很少人知道这个宏，这个可变参数的宏是新的C99规范中新增的。   宏前面加上##的作用在于，当可变参数的个数为0时，这里的##起到把前面多余的&quot;,&quot;去掉的作用</code></pre><h4 id="工厂类完整代码"><a href="#工厂类完整代码" class="headerlink" title="工厂类完整代码"></a>工厂类完整代码</h4><pre><code class="hljs">class factory&#123;public:    template &lt;typename F&gt;    struct Register    &#123;        Register(const std::string&amp; key)        &#123;            factory::get().m_map.emplace(key, []&#123;                return new F();            &#125;);        &#125;        template&lt;typename... Args&gt;        Register(const std::string&amp; key, Args... args)        &#123;            factory::get().m_map.emplace(key, [&amp;]&#123;                return new F(args...);            &#125;);        &#125;    &#125;;    static action* produce(const std::string&amp; key)    &#123;        auto map = factory::get().m_map;        if(map.find(key) == map.end())        &#123;            throw std::invalid_argument(&quot;error&quot;);        &#125;        return map[key]();    &#125;private:    factory() = default;    factory(const factory&amp;) = delete;    factory(factory&amp;&amp;) = delete;    static factory &amp;get()    &#123;        static factory instance;        return instance;    &#125;    std::map&lt;std::string, std::function&lt;action*(void)&gt;&gt; m_map;&#125;;#define REGISTER_ACTION_NAME(T) msg_name_##T##_#define REGISTER_ACTION(T, key, ...) \static factory::Register&lt;T&gt; REGISTER_ACTION_NAME(T)(key,##__VA_ARGS__)</code></pre><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><pre><code class="hljs">int main()&#123;    action *login = factory::produce(&quot;login_action&quot;);    action *rter = factory::produce(&quot;register_action&quot;);    login-&gt;doAction();    rter-&gt;doAction();    delete(login);    delete(rter);&#125;</code></pre><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>![这里写图片描述](<a href="http://img.blog.csdn.net/20170101220315638?watermark/2/text/aHR0cDo">http://img.blog.csdn.net/20170101220315638?watermark/2/text/aHR0cDo</a><br>vL2Jsb2cuY3Nkbi5uZXQvdG9fYmVfYmV0dGVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFC<br>MA==/dissolve/70/gravity/SouthEast)</p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>我们在学习中可能业务逻辑并不会太多，也就是说，switch语句并不会影响什么，但我们应当在一开始时就养成这么一个好的习惯，用最好的方式去实现自己想要的功能。</p>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>clion配置cmake添加boost库</title>
    <link href="/posts/22771.html"/>
    <url>/posts/22771.html</url>
    
    <content type="html"><![CDATA[<p>今天发现xcode在文件名修改之后，该文件内补全就失效，网上寻法多次无果，无奈转向clion。<br>因为clion的项目构建是基于cmake的，想使用boost等第三方库就需要对其进行配置，故将配置内容保存于此。</p><pre><code class="hljs">cmake_minimum_required(VERSION 3.6)#设置项目名称project(demo)set(CMAKE_CXX_STANDARD 11)set(BOOST_ROOT &quot;/usr/local/include/boost&quot;)#添加头文件搜索路径include_directories(/usr/local/include)#添加库文件搜索路径link_directories(/usr/local/lib)#用于将当前目录下的所有源文件的名字保存在变量 DIR_SRCS 中aux_source_directory(. DIR_SRCS)add_executable(demo $&#123;DIR_SRCS&#125;)#在这里根据名字boost_thread去寻找libboost_thread.a文件target_link_libraries(demo boost_thread boost_system)</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Boost.Asio网络库之io_service分析</title>
    <link href="/posts/888.html"/>
    <url>/posts/888.html</url>
    
    <content type="html"><![CDATA[<h3 id="io-service概述"><a href="#io-service概述" class="headerlink" title="io_service概述"></a>io_service概述</h3><p>几乎绝大多数用到Boost.Asio的代码里都会出现这样一个类： ** io_service **<br>。它应该算是Asio库里的核心类了，其本质是一个任务队列，但又不仅仅是个任务队列。</p><h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><p>io_service是个接口类(ps:这里解释一下，这里说接口类并不是指类似java的interface类，而是指其是对下层类做了一个包装，全部功能都是调用<br>下层类来完成)。</p><pre><code class="hljs">class io_service : private noncopyable&#123;private:     typedef detail::io_service_impl impl_type;    ...&#125;</code></pre><p>上述代码中的impl_type即是我们所说的下层类，io_service的所有操作都是由它代为执行的。<br>这么说，为了实现跨平台，我们在io_service提供统一的操作接口，而不管平台的差异，impl_type的实现上分为两部分，</p><pre><code class="hljs">window系平台：win_iocp_io_service非window系平台：task_io_service</code></pre><p>使用宏定义根据平台来决定将哪个类作为具体执行类，见源码</p><pre><code class="hljs">#if defined(BOOST_ASIO_HAS_IOCP)    typedef class win_iocp_io_service io_service_impl;    class win_iocp_overlapped_ptr;#else    typedef class task_io_service io_service_impl;#endif</code></pre><p>代码一目了然，不做赘述。<br>之前也学习过跨平台游戏引擎cocos2dx的部分源码，发现跨平台的开源库几乎都是类似的思想，用宏定义做到根据平台不同使用不同类来执行功能，在此之上提供接口，<br>屏蔽平台差异。<br>我们这里只讨论task_io_service对应的功能。</p><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>上面我们说过，io_service类的本质是一个任务队列，所谓任务队列，其实就是一个队列容器而已，其内部元素为void型的函数，我们将这些函数抽象看待为任务<br>。(ps:既然是任务队列的模式，就当然会有锁的存在，而这个锁也被许多asio的使用者看做是眼中钉肉中刺，)<br>io_service提供了不少方法，在这里我们具体讨论最常用也是最核心的三个方法</p><h3 id="run，run-one"><a href="#run，run-one" class="headerlink" title="run，run_one"></a>run，run_one</h3><p>run函数的功能是：执行队列的所有任务直到全部完成。<br>它应该是使用的最多的一个函数，因为当我们使用io_service注册异步事件后，需要执行run函数阻塞执行任务，否则程序可能会在任务未完成时就结束。<br>我们来看看其源码</p><pre><code class="hljs">std::size_t task_io_service::run(boost::system::error_code&amp; ec)&#123;    ec = boost::system::error_code();    if (outstanding_work_ == 0)    &#123;        stop();        return 0;    &#125;    thread_info this_thread;    this_thread.private_outstanding_work = 0;    thread_call_stack::context ctx(this, this_thread);    mutex::scoped_lock lock(mutex_);    std::size_t n = 0;    for (; do_run_one(lock, this_thread, ec); lock.lock())        if (n != (std::numeric_limits&lt;std::size_t&gt;::max)())            ++n;    return n;&#125;</code></pre><p>outstanding_work_是一个原子变量，通过对它的值的修改来控制run函数是否直接结束。</p><p>run_one由名字就可想而知了，它只执行任务队列里的一个任务。<br>在执行任务时，如果有空闲线程，直接使用该线程去执行任务(领导者追随者模式)，如果没有且监听事件的线程正在运行，则将阻塞时间变为0，即边监听边执行，待任务执行<br>完毕在阻塞在epoll_wait上。当任务执行完后，再将监听模式改为阻塞。</p><h3 id="poll，poll-one"><a href="#poll，poll-one" class="headerlink" title="poll，poll_one"></a>poll，poll_one</h3><p>这两组函数和run/run_one函数的功能完全一样，只是run/run_one函数执行是阻塞的，而poll函数是非阻塞的，所以在 **<br>使用poll函数时要特别注意变量或对象的生命周期 ** 。</p><h4 id="post"><a href="#post" class="headerlink" title="post"></a>post</h4><h4 id="stop"><a href="#stop" class="headerlink" title="stop"></a>stop</h4><p>退出，停止工作</p><h3 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h3>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>服务器开发</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IDEA tomcat三步实现热部署</title>
    <link href="/posts/446.html"/>
    <url>/posts/446.html</url>
    
    <content type="html"><![CDATA[<h3 id="添加Artifacts选项"><a href="#添加Artifacts选项" class="headerlink" title="添加Artifacts选项"></a>添加Artifacts选项</h3><p>![这里写图片描述](<a href="http://img.blog.csdn.net/20161218015953248?watermark/2/text/aHR0cDo">http://img.blog.csdn.net/20161218015953248?watermark/2/text/aHR0cDo</a><br>vL2Jsb2cuY3Nkbi5uZXQvdG9fYmVfYmV0dGVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFC<br>MA==/dissolve/70/gravity/SouthEast)<br>添加Artifacts选项，XXXwar 和 XXXwar exploded二选一，若要热部署须选后者。</p><h3 id="设置tomcat部署方案"><a href="#设置tomcat部署方案" class="headerlink" title="设置tomcat部署方案"></a>设置tomcat部署方案</h3><p>![这里写图片描述](<a href="http://img.blog.csdn.net/20161218020604209?watermark/2/text/aHR0cDo">http://img.blog.csdn.net/20161218020604209?watermark/2/text/aHR0cDo</a><br>vL2Jsb2cuY3Nkbi5uZXQvdG9fYmVfYmV0dGVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFC<br>MA==/dissolve/70/gravity/SouthEast)</p><h3 id="设置tomcat服务选项"><a href="#设置tomcat服务选项" class="headerlink" title="设置tomcat服务选项"></a>设置tomcat服务选项</h3><p>![这里写图片描述](<a href="http://img.blog.csdn.net/20161218015626508?watermark/2/text/aHR0cDo">http://img.blog.csdn.net/20161218015626508?watermark/2/text/aHR0cDo</a><br>vL2Jsb2cuY3Nkbi5uZXQvdG9fYmVfYmV0dGVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFC<br>MA==/dissolve/70/gravity/SouthEast)</p><ol><li>On ‘Update’ action设置每次默认Run选项为Redeploy重新部署（相比重新启动要快一些了，但速度还是不太理想）</li></ol><p>On frame deactivation设置为Updata classes and<br>resources（每次切换桌面&lt;比如切换到浏览器&gt;都会更新类和资源），这样我们在更改jsp文件后，只需切换到浏览器，自动就会进行更新了，感觉很爽</p><ol start="2"><li>添加build选项</li></ol><h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><p>上面本人已通过对springMVC控制层进行更改及jsp更改尝试，亲测可行，至于spring的配置更改等等是否有效，还没有尝试，不敢妄言。</p>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringMVC基于注解进行URL映射</title>
    <link href="/posts/29527.html"/>
    <url>/posts/29527.html</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>![这里写图片描述](<a href="http://img.blog.csdn.net/20161215024919504?watermark/2/text/aHR0cDo">http://img.blog.csdn.net/20161215024919504?watermark/2/text/aHR0cDo</a><br>vL2Jsb2cuY3Nkbi5uZXQvdG9fYmVfYmV0dGVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFC<br>MA==/dissolve/70/gravity/SouthEast)<br>自己之前写了好几个web程序，都遵从这样的方式：地址栏输入的url，后台一定存在对应的servlet。<br>然而某天看着自己博客地址，链接由域名和自己用户名(如上图所示)，就忍不住开始想了，csdn那么多用户，总不可能有那么多servlet吧。<br>一定是进行了某种映射，于是去查了些资料，知道了如何去实现这样的效果。</p><h3 id="使用url映射的好处"><a href="#使用url映射的好处" class="headerlink" title="使用url映射的好处"></a>使用url映射的好处</h3><p>先说说好处，知道好处才有力气用。<br>1、缩短url，隐藏实际路径提高安全性 。<br>2、易于用户记忆和键入。<br>3、易于被搜索引擎收录。<br>4、保证用户的书签保存以及友情链接长期有效。(因为外现的url并不存在，实际更新维护时不会对虚拟url产生影响)</p><p>第一：易扩展，如上面说的用户名作为url的一部分，既方便用户记忆，代码结构也更直观<br>第二：便于搜索引擎对链接</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>步入主题，我们来看看SpringMVC怎样进行URL映射</p><h4 id="普通映射"><a href="#普通映射" class="headerlink" title="普通映射"></a>普通映射</h4><pre><code class="hljs">@RequestMapping(value = &quot;abcde&quot;)public String shi()&#123;    return &quot;&quot;;&#125;</code></pre><h4 id="多个url映射"><a href="#多个url映射" class="headerlink" title="多个url映射"></a>多个url映射</h4><pre><code class="hljs">@RequestMapping(value = &#123;&quot;abcde&quot;, &quot;fgh&quot;&#125;)public String shi()&#123;    return &quot;&quot;;&#125;</code></pre><h4 id="获取路径变量的url映射"><a href="#获取路径变量的url映射" class="headerlink" title="获取路径变量的url映射"></a>获取路径变量的url映射</h4><pre><code class="hljs">@RequestMapping(value = &quot;/&#123;name&#125;&quot;)    @ResponseBody    public Map shi(@PathVariable String name)    &#123;        HashMap s = new HashMap();        s.put(&quot;aaa&quot;, name);        return yi(name);    &#125;</code></pre><h4 id="基于通配风格的url映射"><a href="#基于通配风格的url映射" class="headerlink" title="基于通配风格的url映射"></a>基于通配风格的url映射</h4><h4 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h4><p>? 表示匹配一个字符，不能为空<br>比如@RequestMapping(value = “/a?”)</p><pre><code class="hljs">匹配：localhost:8080/aalocalhost:8080/ab  等等</code></pre><ul><li>表示匹配任意个字符但不能跨/</li></ul><p>比如@RequestMapping(value = “/a*”)</p><pre><code class="hljs">匹配：localhost:8080/aalocalhost:8080/abclocalhost:8080/acdelocalhost:8080/acde/  等等不能匹配localhost::8080/acde/s</code></pre><p>** 表示匹配任意个字符并且无/的限制</p><p>比如@RequestMapping(value = “/a/**”)</p><pre><code class="hljs">匹配：localhost:8080/aalocalhost:8080/abclocalhost:8080/acde/saflocalhost:8080/acde/saf/asf  等等</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web开发</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringMVC返回json数据(@ResponseBody注解的使用)</title>
    <link href="/posts/30797.html"/>
    <url>/posts/30797.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>最近开始了一个web项目，深深感觉到web方面知识的混杂，越来越明白java为什么可以流行这么多年了，库啊，框架啊，一抓一大把，要多方便有多方便，开发效<br>率提升太高了。</p></blockquote><p>最初使用SpringMVC时，为其ModelAndView可以直接返回页面和数据感觉爽到不行，但是当只想返回数据而不返回页面时，该怎么办呢，难道还要每次自己<br>进行json格式转化吗，太麻烦了。</p><p>用ModelAndView显然不行，因为其必须要附带视图页面，如果没有，则会报下面错误。<br>![这里写图片描述](<a href="http://img.blog.csdn.net/20161215022056123?watermark/2/text/aHR0cDo">http://img.blog.csdn.net/20161215022056123?watermark/2/text/aHR0cDo</a><br>vL2Jsb2cuY3Nkbi5uZXQvdG9fYmVfYmV0dGVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFC<br>MA==/dissolve/70/gravity/SouthEast)</p><p>怎么办呢，我们可以使用@ResponseBody注解，方便的返回json数据<br>它会将内容或对象进行合适的格式转换作为 HTTP 响应正文返回</p><p>具体使用方法如下：</p><h3 id="库依赖"><a href="#库依赖" class="headerlink" title="库依赖"></a>库依赖</h3><pre><code class="hljs">&lt;!-- json --&gt;        &lt;dependency&gt;          &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;            &lt;artifactId&gt;jackson-core&lt;/artifactId&gt;            &lt;version&gt;$&#123;jackson.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;            &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;            &lt;version&gt;$&#123;jackson.version&#125;&lt;/version&gt;        &lt;/dependency&gt;</code></pre><h3 id="xml配置"><a href="#xml配置" class="headerlink" title="xml配置"></a>xml配置</h3><p>启动注解<br><code>&lt;mvc:annotation-driven/&gt;</code></p><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><p>controller</p><pre><code class="hljs">@RequestMapping(&quot;c&quot;)    @ResponseBody    public String d()    &#123;        HashMap s = new HashMap();        s.put(&quot;aaa&quot;, &quot;你好啊&quot;);        return s;    &#125;</code></pre><h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p>![这里写图片描述](<a href="http://img.blog.csdn.net/20161215022007607?watermark/2/text/aHR0cDo">http://img.blog.csdn.net/20161215022007607?watermark/2/text/aHR0cDo</a><br>vL2Jsb2cuY3Nkbi5uZXQvdG9fYmVfYmV0dGVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFC<br>MA==/dissolve/70/gravity/SouthEast)</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>如果返回的对象里的属性必须拥有get方法，因为要进行数据转化直接返回string时，不会进行json格式的转化</p>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web开发</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>boost:asio信号量signal_set源码分析及使用</title>
    <link href="/posts/10773.html"/>
    <url>/posts/10773.html</url>
    
    <content type="html"><![CDATA[<p>首先我们先看signal_set.hpp，可以看到下面代码</p><pre><code class="hljs">#include &lt;boost/asio/detail/config.hpp&gt;#include &lt;boost/asio/basic_signal_set.hpp&gt;namespace boost &#123;namespace asio &#123;/// Typedef for the typical usage of a signal set.typedef basic_signal_set&lt;&gt; signal_set;&#125; // namespace asio&#125; // namespace boost</code></pre><p>显然，我们使用的signal_set实际上是一个基础模板类basic_signal_set&lt;&gt;<br>再次跳转basic_signal_set.hpp</p><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><pre><code class="hljs">    explicit basic_signal_set(boost::asio::io_service&amp; io_service) : basic_io_object&lt;SignalSetService&gt;(io_service)    basic_signal_set(boost::asio::io_service&amp; io_service, int signal_number_1)    basic_signal_set(boost::asio::io_service&amp; io_service, int signal_number_1, int signal_number_2)    basic_signal_set(boost::asio::io_service&amp; io_service, int signal_number_1, int signal_number_2, int signal_number_3) : basic_io_object&lt;SignalSetService&gt;(io_service)</code></pre><p>显而易见，三个构造函数，都接受一个io_service和信号量的值，唯一区别就是信号量的数量不同。<br>一开始看到，奇怪为什么不弄个可变参数模板呢，不是更好，看到下面也就释然了，因为类signal_set已经提供了add函数来增加信号量，这里构造函数数量1~3<br>只是为更方便而已，至于参数模板，实际是完全没有必要的。</p><h3 id="为什么都要实现两种呢"><a href="#为什么都要实现两种呢" class="headerlink" title="为什么都要实现两种呢"></a>为什么都要实现两种呢</h3><p>两个函数：<br>add向集合中添加信号量<br>remove删除信号量</p><pre><code class="hljs">    void add(int signal_number)    &#123;        boost::system::error_code ec;        this-&gt;service.add(this-&gt;implementation, signal_number, ec);        boost::asio::detail::throw_error(ec, &quot;add&quot;);    &#125;    boost::system::error_code add(int signal_number, boost::system::error_code&amp; ec)    &#123;        return this-&gt;service.add(this-&gt;implementation, signal_number, ec);    &#125;    void remove(int signal_number)    boost::system::error_code remove(int signal_number,    boost::system::error_code&amp; ec)</code></pre><p>我们很容易发现，两个函数唯一的区别就是对错误的处理的方式b：错误码和异常抛出。<br>因此我们可以通过对错误码判断和捕获异常来进行错误处理。<br>我们的程序有同步和异步两种模式，在同步模式下，无论用哪种都可以，但在异步模式下，程序不会抛出异常，所以就只能使用错误码了。</p><h3 id="清空和取消的区别"><a href="#清空和取消的区别" class="headerlink" title="清空和取消的区别"></a>清空和取消的区别</h3><pre><code class="hljs">    void clear()    boost::system::error_code clear(boost::system::error_code&amp; ec)    void cancel()    boost::system::error_code cancel(boost::system::error_code&amp; ec)</code></pre><p>从字面意思我们很容易感觉到他们的区别，何谓清空，清空就是没有了，而取消不代表没有。(ps:光看命名就能猜的八九不离十的代码，可谓好代码)<br>仔细的看了代码：<br>clear: 清空(删除)集合中的所有信号量，并删除所有通知队列里的事件，如果集合本身为空，则抛出错误。<br>cancel:不改变集合中的信号量，向所有与信号有关的操作抛出错误码来终止其操作。</p><h2 id="async-wait"><a href="#async-wait" class="headerlink" title="async_wait"></a>async_wait</h2><pre><code class="hljs">template &lt;typename SignalHandler&gt;BOOST_ASIO_INITFN_RESULT_TYPE(SignalHandler, void (boost::system::error_code, int))async_wait(BOOST_ASIO_MOVE_ARG(SignalHandler) handler)&#123;    // If you get an error on the following line it means that your handler does    // not meet the documented type requirements for a SignalHandler.    BOOST_ASIO_SIGNAL_HANDLER_CHECK(SignalHandler, handler) type_check;    return this-&gt;service.async_wait(this-&gt;implementation, BOOST_ASIO_MOVE_CAST(SignalHandler)(handler));&#125;</code></pre><p>这个函数很重要，因为我们对signal_set的主要使用要靠这个函数。<br>该函数接受一个 void (boost::system::error_code, int)) 类型的函数句柄，随后会在所监听的信号发生时调用此函数。<br>函数内部实现，只有两句话</p><pre><code class="hljs">BOOST_ASIO_SIGNAL_HANDLER_CHECK(SignalHandler, handler) type_check;</code></pre><p>对函数进行类型检查，这个宏写的很复杂，看了好一会儿，坦白说，知晓其功能，但不明白每一句的意思，找时间要好好把这里钻个透。</p><pre><code class="hljs">return this-&gt;service.async_wait(this-&gt;implementation, BOOST_ASIO_MOVE_CAST(SignalHandler)(handler));</code></pre><p>尾递归委托下层接口完成任务。</p><h2 id="使用例子"><a href="#使用例子" class="headerlink" title="使用例子"></a>使用例子</h2><pre><code class="hljs">////  main.cpp//  AsioServer////  Created by shiyi on 2016/12/10.//  Copyright © 2016年 shiyi. All rights reserved.//#include &lt;iostream&gt;#include &lt;boost/asio.hpp&gt;#include &lt;boost/bind.hpp&gt;#include &lt;boost/thread.hpp&gt;using namespace boost;void signal_handler(const boost::system::error_code&amp; err, int signal)&#123;    switch (signal) &#123;        case SIGINT:            std::cout &lt;&lt; &quot;SIGNINT&quot; &lt;&lt; std::endl;            break;        case SIGTERM:            std::cout &lt;&lt; &quot;SIGNTERM&quot; &lt;&lt; std::endl;            break;        default:            break;    &#125;&#125;int main(int argc, const char * argv[]) &#123;    asio::io_service service;    asio::signal_set sigset(service, SIGINT, SIGTERM);    sigset.async_wait(signal_handler);    boost::system::error_code ec;    service.run(ec);    if(ec)    &#123;        std::cout &lt;&lt; boost::system::system_error(ec).what() &lt;&lt; std::endl;    &#125;    std::cout &lt;&lt; &quot;End&quot; &lt;&lt; std::endl;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>服务器开发</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>shared_ptr智能指针模板类的简单实现(c++11)</title>
    <link href="/posts/32049.html"/>
    <url>/posts/32049.html</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>最近突然萌生把stl常用的库都通通自己过一遍的想法，算是对泛型编程的一次学习，也深入理解stl，还是对c++11知识的练习，就从智能指针开始吧。<br>另外，c++11让c++程序变得简洁优雅了许多，对这门语言有点爱不释手了。</p></blockquote><h2 id="智能指针原理"><a href="#智能指针原理" class="headerlink" title="智能指针原理"></a>智能指针原理</h2><blockquote><p>通过使用引用计数的方式来自动的对动态申请的内存进行释放，保证指针的生存期和安全性。<br>对智能指针初始化的时候，会将引用计数初始为1，之后每次拷贝或移动赋值时，都对其引用计数加1.<br>而在其生存期结束，要进行析构时，对其进行引用计数减一，如果引用计数为0，则释放原指针保存的空间。<br>以前总疑惑 ** 指向同一空间的智能指针也是不同的对象，怎么在一个智能指针析构时对指向同一位置的所有智能指针进行操作呢 ** 。<br>其实这个问题很简单， ** 如果引用计数的变量的空间是动态申请的呢，每个智能指针只保存其指针，那么一个智能指针析构时操作就很容易做到影响所有其他智能指针了。<br>**</p></blockquote><h2 id="智能指针需要哪些组成部分"><a href="#智能指针需要哪些组成部分" class="headerlink" title="智能指针需要哪些组成部分"></a>智能指针需要哪些组成部分</h2><h3 id="模拟指针行为"><a href="#模拟指针行为" class="headerlink" title="模拟指针行为"></a>模拟指针行为</h3><p>智能指针，当然是模拟指针行为的类，所以我们要对解引用运算符和箭头运算符进行重载</p><pre><code class="hljs"> T&amp; operator*();//解引用重载 T* operator-&gt;();</code></pre><h4 id="箭头运算符重载的特殊性"><a href="#箭头运算符重载的特殊性" class="headerlink" title="箭头运算符重载的特殊性"></a>箭头运算符重载的特殊性</h4><p>c++primer第五版上关于箭头运算符的原话是</p><blockquote><p>和大多数其他运算符一样(尽管这么做不太好)，我们能令operator*完成任何我们指定的操作。箭头运算符则不是这样，它永远 **<br>不能丢掉成员访问这个最基本的含义 ** 。当我们重载箭头时，可以改变的是从哪个对象当中获取成员，而 ** 箭头获取成员 ** 这一事实则永远不变</p></blockquote><p>也就是说，比如我们定义智能指针p；<br>那么在进行*p操作时，等同于对T&amp;操作<br>而p-&gt;abcde操作时，等于(*p)-&gt;abcde;</p><h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><h3 id="拷贝构造函数和拷贝赋值运算符重载"><a href="#拷贝构造函数和拷贝赋值运算符重载" class="headerlink" title="拷贝构造函数和拷贝赋值运算符重载"></a>拷贝构造函数和拷贝赋值运算符重载</h3><p>我们的引用计数更改就是在上述函数内完成的，当然需要自定义。<br>我在此三者基础上，还增加实现了移动赋值的两个函数，搞得有点像标准的三五法则了。<br>其实不然，因为我们这个程序所有传参中均不涉及深拷贝，所以我们并不需要用移动赋值，此处我只是以学习为目的，想使用右值引用和完美转发而已，读者切勿多想。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="hljs">////  Shared_ptr.hpp//  demo////  Created by shiyi on 2016/12/10.//  Copyright © 2016年 shiyi. All rights reserved.//#ifndef Shared_ptr_Hpp#define Shared_ptr_Hpp#include &lt;stdio.h&gt;#include &lt;iostream&gt;using namespace std;template &lt;typename T&gt;class Shared_ptr&#123;private:    size_t* m_count;    T* m_ptr;public:    //构造函数    Shared_ptr() : m_ptr(nullptr), m_count(new size_t)    &#123;&#125;    Shared_ptr( T* ptr ) : m_ptr(ptr), m_count(new size_t)    &#123;        cout&lt;&lt;&quot;空间申请：&quot;&lt;&lt;ptr&lt;&lt;endl;        *m_count = 1;    &#125;    //析构函数    ~Shared_ptr()    &#123;        --(*m_count);        if(*m_count == 0)        &#123;            cout&lt;&lt;&quot;空间释放：&quot;&lt;&lt;m_ptr&lt;&lt;endl;            delete m_ptr;            delete m_count;            m_ptr = nullptr;            m_count = nullptr;        &#125;    &#125;    //拷贝构造函数    Shared_ptr( const Shared_ptr&amp; ptr )    &#123;        m_count = ptr.m_count;        m_ptr = ptr.m_ptr;        ++(*m_count);    &#125;    //拷贝赋值运算符    void operator=( const Shared_ptr&amp; ptr )    &#123;        Shared_ptr(std::move(ptr));    &#125;    //移动构造函数    Shared_ptr( Shared_ptr&amp;&amp; ptr ) : m_ptr(ptr.m_ptr), m_count(ptr.m_count)    &#123;        ++(*m_count);    &#125;    //移动赋值运算符    void operator=( Shared_ptr&amp;&amp; ptr )    &#123;        Shared_ptr(std::move(ptr));    &#125;    //解引用运算符    T&amp; operator*()    &#123;        return *m_ptr;    &#125;    //箭头运算符    T* operator-&gt;()    &#123;        return m_ptr;    &#125;    //重载布尔值操作    operator bool()    &#123;        return m_ptr == nullptr;    &#125;    T* get()    &#123;        return m_ptr;    &#125;    size_t use_count()    &#123;        return *m_count;    &#125;    bool unique()    &#123;        return *m_count == 1;    &#125;    void swap( Shared_ptr&amp; ptr )    &#123;        std::swap(*this, ptr);    &#125;&#125;;#endif /* Shared_ptr_Hpp */</code></pre><h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><pre><code class="hljs">#include &quot;Shared_ptr.hpp&quot;using namespace std;int main()&#123;    Shared_ptr&lt;int&gt; p1(new int);    *p1 = 222;    cout&lt;&lt;&quot;值：&quot;&lt;&lt;*p1&lt;&lt;&quot; 引用计数：&quot;&lt;&lt;p1.use_count()&lt;&lt;endl;    &#123;        Shared_ptr&lt;int&gt; p2(p1);        *p2 = 333;        cout&lt;&lt;&quot;值：&quot;&lt;&lt;*p2&lt;&lt;&quot; 引用计数：&quot;&lt;&lt;p1.use_count()&lt;&lt;endl;        Shared_ptr&lt;int&gt; p3(p2);        *p3 = 444;        cout&lt;&lt;&quot;值：&quot;&lt;&lt;*p3&lt;&lt;&quot; 引用计数：&quot;&lt;&lt;p1.use_count()&lt;&lt;endl;    &#125;    cout&lt;&lt;&quot;引用计数：&quot;&lt;&lt;p1.use_count()&lt;&lt;endl;    Shared_ptr&lt;string&gt; q1(new string(&quot;我是string1&quot;));    cout&lt;&lt;(*(q1)).c_str()&lt;&lt;endl;    Shared_ptr&lt;string&gt; q2(new string(&quot;我是string2&quot;));    q2.swap(q1);    cout&lt;&lt;(*(q1)).c_str()&lt;&lt;endl;    return 0;&#125;</code></pre><h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><p>![这里写图片描述](<a href="http://img.blog.csdn.net/20161211044721300?watermark/2/text/aHR0cDo">http://img.blog.csdn.net/20161211044721300?watermark/2/text/aHR0cDo</a><br>vL2Jsb2cuY3Nkbi5uZXQvdG9fYmVfYmV0dGVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFC<br>MA==/dissolve/70/gravity/SouthEast)</p>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>boost:asio网络库初学之echo服务器客户端实现</title>
    <link href="/posts/21818.html"/>
    <url>/posts/21818.html</url>
    
    <content type="html"><![CDATA[<h2 id="为什么想起来学网络库呢"><a href="#为什么想起来学网络库呢" class="headerlink" title="为什么想起来学网络库呢"></a>为什么想起来学网络库呢</h2><p>前一阵在网上看到这么一段话</p><blockquote><p>select 实在是太慢了.</p></blockquote><blockquote></blockquote><blockquote><p>在这种背景下, IBM 老大哥带领着MS老弟先搞了 IOCP . 然而开源的人有开源的做法, 在 NIH 综合症的影响下, BSD 的人敢为天下所不齿,<br>发明了 Kqueue. 同样在 NIH 综合症影响下, Linux 的一群 M* 的猴子捣鼓出了 epoll.</p></blockquote><blockquote></blockquote><blockquote><p>分裂, 让人头疼.</p></blockquote><blockquote></blockquote><blockquote><p>于是程序员们急需一个上天入地无所不能的法宝的法宝, 把这3家法宝给统御起来。</p></blockquote><p>实在太符合我的心情了，我就很需要这样一个法宝，让自己舒服一点。因为是macos系统，类Unix，在服务器开发方面，linux有的基本都有，差不多是一致的，但<br>就是没有Epoll！！！，这就有些麻烦了，上一次写网关服务器时候，开发过程是这样的：<br>用sublime远程连接云服务器，<br>再用终端ssh运行调试，<br>就这样循环往复，再加上还没有补全，适应了xcode的舒服，所以痛苦ing。</p><h2 id="说重点，为什么选择asio呢"><a href="#说重点，为什么选择asio呢" class="headerlink" title="说重点，为什么选择asio呢"></a>说重点，为什么选择asio呢</h2><blockquote><p>1.asio属于boost的一部分，有可能被加入c++标准库，其代码质量稳定性及可靠性已不言而喻。<br>2.还是c++的原因，其源码使用了大多c++11特性，想在对其源码的学习过程中，对自己的c++知识进行一次加深和巩固<br>3.其主要针对于异步Proactor模式，而此模式相比较Reactor模式，学习难度稍高，所以想借着学习库使用的同时，能对其源码进行学习，提高事件驱动编程的<br>能力。<br>4.当然是跨平台了。</p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><pre><code class="hljs">////  main.cpp//  AsioClient////  Created by shiyi on 2016/12/10.//  Copyright © 2016年 shiyi. All rights reserved.//#include &lt;iostream&gt;#include &lt;boost/asio.hpp&gt;#include &lt;boost/bind.hpp&gt;using namespace boost;int main(int argc, const char * argv[]) &#123;    asio::io_service service;//创建调度器    asio::ip::tcp::socket sock(service);//创建socket    asio::ip::tcp::endpoint ep(asio::ip::address::from_string(&quot;127.0.0.1&quot;), 6666);//创建目标地址对象    //异步连接    sock.async_connect(ep, [](const boost::system::error_code &amp;error)&#123;        if(error)        &#123;            std::cout &lt;&lt; error.message() &lt;&lt; std::endl;            return;        &#125;        std::cout &lt;&lt; &quot;connect succeed&quot; &lt;&lt; std::endl;    &#125;);    //如果不进行run调用的话，程序会直接结束，所以这里会等待async_connect结束，    //因此上面connect同步还是异步其实是一样的    service.run();    char data[512];    boost::system::error_code ec;    size_t len;    while(true)    &#123;        std::cin &gt;&gt; data;        //发送 如果不传入 ec(error_code)参数，则出错时会抛出异常，此时可以用try-catch进行捕获，如果也没捕获，程序会直接终止        len = sock.write_some(asio::buffer(data), ec);        if(ec)        &#123;            std::cout &lt;&lt; boost::system::system_error(ec).what() &lt;&lt; std::endl;            break;        &#125;        //接收        len = sock.read_some(asio::buffer(data), ec);        if(ec)        &#123;            std::cout &lt;&lt; boost::system::system_error(ec).what() &lt;&lt; std::endl;            break;        &#125;        std::cout &lt;&lt; data &lt;&lt; std::endl;    &#125;    return 0;&#125;</code></pre><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><pre><code class="hljs">////  main.cpp//  AsioServer////  Created by shiyi on 2016/12/10.//  Copyright © 2016年 shiyi. All rights reserved.//#include &lt;iostream&gt;#include &lt;boost/asio.hpp&gt;#include &lt;boost/bind.hpp&gt;#include &lt;boost/thread.hpp&gt;using namespace boost;using socket_ptr = boost::shared_ptr&lt;asio::ip::tcp::socket&gt;;//包装socket类型的智能指针void client_session(socket_ptr sock)&#123;    auto ep = sock-&gt;local_endpoint();    std::cout&lt;&lt;ep.address().to_string()&lt;&lt;&quot;连接&quot;&lt;&lt;std::endl;    char data[512];    boost::system::error_code ec;    size_t len;    while(true)    &#123;        len = sock-&gt;read_some(asio::buffer(data), ec);        if(ec)        &#123;            std::cout &lt;&lt; boost::system::system_error(ec).what() &lt;&lt; std::endl;            break;        &#125;        len = sock-&gt;write_some(asio::buffer(data), ec);        if(ec)        &#123;            std::cout &lt;&lt; boost::system::system_error(ec).what() &lt;&lt; std::endl;            break;        &#125;    &#125;    std::cout&lt;&lt;ep.address().to_string()&lt;&lt;&quot;关闭&quot;&lt;&lt;std::endl;&#125;int main(int argc, const char * argv[]) &#123;    asio::io_service service;//创建调度器    asio::ip::tcp::endpoint ep(asio::ip::address::from_string(&quot;127.0.0.1&quot;), 6666);    asio::ip::tcp::acceptor apt(service, ep);//创建连接器    while(true)    &#123;        socket_ptr sock(new asio::ip::tcp::socket(service));        apt.accept(*sock);//接收新的连接        boost::thread(boost::bind(client_session, sock));//开辟线程去处理该连接上的事务    &#125;&#125;</code></pre><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><h3 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h3><p>![这里写图片描述](<a href="http://img.blog.csdn.net/20161210185739981?watermark/2/text/aHR0cDo">http://img.blog.csdn.net/20161210185739981?watermark/2/text/aHR0cDo</a><br>vL2Jsb2cuY3Nkbi5uZXQvdG9fYmVfYmV0dGVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFC<br>MA==/dissolve/70/gravity/SouthEast)</p><h3 id="服务端-1"><a href="#服务端-1" class="headerlink" title="服务端"></a>服务端</h3><p>![这里写图片描述](<a href="http://img.blog.csdn.net/20161210185752888?watermark/2/text/aHR0cDo">http://img.blog.csdn.net/20161210185752888?watermark/2/text/aHR0cDo</a><br>vL2Jsb2cuY3Nkbi5uZXQvdG9fYmVfYmV0dGVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFC<br>MA==/dissolve/70/gravity/SouthEast)</p>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>服务器开发</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mac Boost安装及使用(命令行和Xcode)</title>
    <link href="/posts/17125.html"/>
    <url>/posts/17125.html</url>
    
    <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol><li>下载boost安装包<br>官网下载地址<br><a href="https://sourceforge.net/projects/boost/files/boost/1.62.0/"> https://sourceforge.net/projects/boost/files/boost/1.62.0/</a></li></ol><p>2.解压并进入boost_1_62_0文件夹<br>3.执行boostrap.sh</p><blockquote><p>./boostrap.sh</p></blockquote><p>4.上一步执行成功后会生成b2脚本，执行它<br>./b2</p><blockquote><p>执行完毕后，头文件在boost_1_62_0/boost文件夹下<br>库文件在boost_1_62_0/stage/lib文件夹下</p></blockquote><blockquote></blockquote><blockquote><p>也可以直接执行<br>./b2 install<br>执行完毕后头文件在/usr/local/include下<br>库文件在/usr/local/lib下</p></blockquote><ol><li>至此安装完成</li></ol><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="测试程序"><a href="#测试程序" class="headerlink" title="测试程序"></a>测试程序</h3><p>直接包含一个头文件编译看是否通过即可</p><pre><code class="hljs">#include &lt;boost/asio.hpp&gt;int main()&#123;&#125;</code></pre><h3 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h3><p>g++使用第三方库编译是如下命令</p><pre><code class="hljs">    g++ a.cpp  -I 头文件路径 -L 库文件路径 -l 动态链接库</code></pre><p>对应到我们这里应该是</p><pre><code class="hljs">    g++ a.cpp  -I /usr/local/include -L /usr/local/lib -l boost_system -l boost_thread</code></pre><p>** 必须要加，-l boost_system -l boost_thread，否则会报错 **</p><blockquote></blockquote><blockquote><pre><code class="hljs">  Undefined symbols for architecture x86_64:</code></pre></blockquote><blockquote></blockquote><blockquote><p>“boost::system::system_category()”, referenced from:<br>boost::asio::error::get_system_category() in a-0e6774.o<br>___cxx_global_var_init.2 in a-0e6774.o<br>“boost::system::generic_category()”, referenced from:<br>___cxx_global_var_init in a-0e6774.o<br>___cxx_global_var_init.1 in a-0e6774.o<br>ld: symbol(s) not found for architecture x86_64<br>clang: error: linker command failed with exit code 1 (use -v to see<br>invocation)</p></blockquote><h3 id="Xcode"><a href="#Xcode" class="headerlink" title="Xcode"></a>Xcode</h3><ol><li>点击【项目工程文件】-》【Targets】-》【BuildSetting】-》【Search Paths】-》【Header Search Paths】输入 ** 头文件 ** 路径</li><li>点击【项目工程文件】-》【Targets】-》【BuildSetting】-》【Search Paths】-》【Library Search Paths】输入 ** 库文件 ** 路径</li><li>点击【项目工程文件】-》【Targets】-》【BuildSetting】-》【Linking】-》【Other Linker Flags】输入链接选项，输入-l boost_system -l boost_thread</li></ol><h3 id="大功告成"><a href="#大功告成" class="headerlink" title="大功告成"></a>大功告成</h3>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Boost</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>8086汇编初学之贪吃蛇</title>
    <link href="/posts/51226.html"/>
    <url>/posts/51226.html</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一直没想过要去学习汇编，觉得需要用汇编的场合无非三种：<br>1. 与硬件结合很紧密高级语言做不到<br>2. 时空效率要求甚高算法层面已不能优化到<br>3. 逆向破解等只能用某些途径看其汇编指令<br>其余情况下，用汇编无异于有炮不用偏用鸟枪。<br>本来准备等自己需求以上场合时再去学，但因为学校举办的汇编比赛，计算机学院都要参加，也算是一个由头，于是开始了我的第一个汇编程序。</p><h2 id="运行效果"><a href="#运行效果" class="headerlink" title="运行效果"></a>运行效果</h2><p>代码只有400行，功能很简略，实现了最基本的游戏流程，看运行效果<br>![这里写图片描述](<a href="http://img.blog.csdn.net/20161208122620511?watermark/2/text/aHR0cDo">http://img.blog.csdn.net/20161208122620511?watermark/2/text/aHR0cDo</a><br>vL2Jsb2cuY3Nkbi5uZXQvdG9fYmVfYmV0dGVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFC<br>MA==/dissolve/70/gravity/SouthEast)</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本质上用汇编去写一个贪吃蛇和用其他语言去实现没什么区别，不过是换一种方式表达，当然，是一种更加麻烦的方式。<br>以前用c++实现过 <a href="http://blog.csdn.net/to_be_better/article/details/51058164"> C++贪吃蛇</a> 和 <a href="http://blog.csdn.net/to_be_better/article/details/51055813"> C++俄罗斯方块</a><br>。所以对于这类小游戏，该怎么切是知道了，剩下的事就是找家伙了。</p><blockquote><p>要实现这类简易的小游戏，需要二点：<br>1. 定时器<br>2. 非阻塞接收按键<br>有上面两者便可以搞定一切。<br>但在汇编下，为这两点，耽搁了不少时间。不对，是三点，还有 ** 生成随机数 ** (原本很容易的事都变得麻烦了起来)。</p></blockquote><h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><blockquote><p>事实上，查了很多资料，但还是不知道怎样去实现定时器，所以这个需求只能变通的解决。<br>用空循环来控制时间。</p></blockquote><h3 id="非阻塞接受按键"><a href="#非阻塞接受按键" class="headerlink" title="非阻塞接受按键"></a>非阻塞接受按键</h3><pre><code class="hljs">getInput:    mov al, 0    mov ah, 1    int 16h;查看键盘缓冲区是否有数据    cmp ah, 1;ah为0表示有，否则没有    je getInputEnd    mov al, 0    mov ah, 0    int 16h;从缓冲区读取数据    ;此时值已经在ax里了，做你想做的getInputEnd:    ret</code></pre><h3 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h3><pre><code class="hljs">    mov ax, 0h;间隔定时器    out 43h, al;通过端口43h    in al, 40h;    in al, 40h;    in al, 40h;访问3次，保证随机性    ;如果对范围并不需要精确，可以直接与运算来获得，    ;否则，用div取余    mov bl, 18    div bl    mov al, ah    mov ah, 0;此时ax的值就是0~18的</code></pre><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="hljs">assume cs:code,ds:data,ss:stackdata segment    sfood dw 0    sdct dw 0    sbody dw 400 dup(0)data endsstack segment    dw 20 dup(0)stack endscode segmentstart:    mov ax, data    mov ds, ax    mov ax, stack    mov ss, ax    mov sp, 20    mov ax, 0b800h    mov es, ax    mov si, 4 ;保存数据段偏移量    mov cx, 4;初始蛇长度    mov ax, 0A04h    s:;初始化蛇        mov ds:[si], ax        add si, 2        inc al        loop s    mov ax, 4d00h;向右    mov ds:[2], ax;初始化方向    call clearBg;清屏    call outBg;输出地图边框    call outBody;输出蛇    call creatFood;输出食物    mov cx, 30    Game:        push cx        call updateBody        mov cx, 0Fh        aaaa1:            push cx            mov cx, 0FFFh            bbbb:                push cx                call getInput                pop cx                loop bbbb            pop cx            loop aaaa1        ;jmp GameEnd        jmp Game    GameEnd:    ;退出        ;call outBody        mov ax, 4c00h        int 21hupdateBody:    mov ax, ds:[2]    mov di, si    sub di, 2    cmp ax, 4800h    je shang    mov ax, ds:[2]    cmp ax, 5000h    je xia    mov ax, ds:[2]    cmp ax, 4b00h    je zuo    mov ax, ds:[2]    cmp ax, 4d00h    je you    shang:        mov ax, ds:[di]        sub ah, 1        jmp checkBody    xia:        mov ax, ds:[di]        add ah, 1        jmp checkBody    zuo:        mov ax, ds:[di]        sub al, 1        jmp checkBody    you:        mov ax, ds:[di]        add al, 1        ;mov ds:[di], ax        jmp checkBodycheckBody:    push ax    ;判断蛇头是否碰到地图边界    cmp ah, 0    je GameEnd    cmp ah, 20    je GameEnd    cmp al, 0    je GameEnd    cmp al, 20    je GameEnd    ;判断蛇头是否碰到蛇身    mov cx, si    sub cx, 6    mov di, 4    s0:        mov bx, ds:[di]        cmp bx, ax        je GameEnd        add di, 2        sub cx, 1        loop s0    pop ax    ;判断蛇头是否吃到食物    mov bx, ds:[0]    cmp ax, bx    je addBody    jmp updateStartupdateStart:    mov cx, si    sub cx, 6    mov di, 4    push ax    mov dl, &#39; &#39;;字符    mov dh, 0;颜色    mov bx, ds:[di]    call outStr    s5:        mov dx, ds:[di+2]        mov ds:[di], dx        add di, 2        sub cx, 1        loop s5    mov dl, &#39; &#39;;字符    mov dh, 71h;颜色    mov bx, ds:[di]    call outStr    pop ax    mov ds:[di], ax    mov dl, &#39; &#39;;字符    mov dh, 44h;颜色    mov bx, ds:[di]    call outStrupdateEnd:    retaddBody:    mov dl, &#39; &#39;;字符    mov dh, 71h;颜色    mov bx, ds:[di]    call outStr    mov ax, ds:[0]    mov ds:[si], ax    mov dl, &#39; &#39;;字符    mov dh, 44h;颜色    mov bx, ds:[si]    call outStr    add si, 2    call creatFood    jmp updateEndgetInput:;获取键盘输入    mov al, 0    mov ah, 1    int 16h;接收键盘    cmp ah, 1    je getInputEnd    mov al, 0    mov ah, 0    int 16h;    mov cx, ax;键盘值在ax    ;判断输入    cmp cx, 4800h    je gshang    cmp cx, 5000h    je gxia    cmp cx, 4b00h    je gzuo    cmp cx, 4d00h    je gyou    jmp getInputEnd    gshang:        mov ax, ds:[2]        cmp ax, 5000h        je getInputEnd        jmp fx    gxia:        mov ax, ds:[2]        cmp ax, 4800h        je getInputEnd        jmp fx    gzuo:        mov ax, ds:[2]        cmp ax, 4d00h        je getInputEnd        jmp fx    gyou:        mov ax, ds:[2]        cmp ax, 4b00h        je getInputEnd        jmp fx    fx:;更改方向标志        mov ds:[2], cx    getInputEnd:        ret;结束outBody:    mov cx, si    sub cx, 6    mov di, 4    s1:        mov ax, ds:[di]        mov dl, &#39; &#39;;字符        mov dh, 71h;颜色        mov bl, al;列        mov bh, ah;行        call outStr        add di, 2        sub cx, 1        loop s1    mov dl, &#39; &#39;    mov dh, 44h    mov ax, ds:[di]    mov bl, al    mov bh, ah    call outStr    retoutBg:    mov dl, &#39; &#39;;字符    mov dh, 71h;颜色    mov bl, 0;列    mov bh, 0;行    mov cx, 20    row:        push cx        push bx        call outStr;上边界        pop bx        push bx        add bh, 20        call outStr;下边界        pop bx        inc bl;列加1        pop cx        loop row    mov bl, 0;    mov bh, 0;    mov cx, 21    col:        push cx        push bx        call outStr;左边界        pop bx        push bx        add bl, 20        call outStr;右边界        pop bx        inc bh;行加1        pop cx        loop col    retoutStr: ;在指定位置输出字符    mov al, 80    mul bh;行乘以80    mov bh, 0    add bl, bl;    add ax, bx;加上列即为偏移量    push si    mov si, ax    add si, si    mov es:[si], dl    mov es:[si+1], dh    mov es:[si+2], dl    mov es:[si+3], dh    pop si    retcreatFood:;生成食物    call getFoodPosition    mov dl, &#39; &#39;    mov dh, 071h    mov bx, ds:[0]    call outStr    retgetFoodPosition:;获取食物位置    f1:        call getRand        mov ds:[0], al        call getRand        mov ds:[1], al        mov cx, si        sub cx, 4        mov di, 4        s11:            mov ax, ds:[di]            cmp ax, ds:[0]            je f1            add di, 2            sub cx, 1            loop s11    retgetRand:;获取随机数 范围1~19    mov ax, 0h;间隔定时器    out 43h, al;通过端口43h    in al, 40h;    in al, 40h;    in al, 40h;访问3次，保证随机性    mov bl, 18    div bl    mov al, ah    mov ah, 0    inc al    retclearBg:    ;清屏    mov ax, 3h    int 10h    retcode endsend start</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>游戏开发</tag>
      
      <tag>汇编</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux服务器开发之网关服务器的实现</title>
    <link href="/posts/36868.html"/>
    <url>/posts/36868.html</url>
    
    <content type="html"><![CDATA[<h2 id="什么是网关服务器"><a href="#什么是网关服务器" class="headerlink" title="什么是网关服务器"></a>什么是网关服务器</h2><blockquote><p>初学linux服务器开发时，我们的服务器是很简单的，只需要一个程序完成与客户端的连接，接收客户端数据，数据处理，向客户端发送数据。<br>但是在处理量很大的情况下，一台机器不能满足我们的需求，此时我们应该怎么办。<br>我们可以将服务端的任务分摊到多台机器上完成，见下图<br><img src="http://img.blog.csdn.net/20161205173743104" alt="这里写图片描述"></p></blockquote><blockquote></blockquote><blockquote><p>从图中可见，此时整个服务端主要分为了三部分。<br>** 网关服务器：负责连接客户端与逻辑服务器，在两者间完成数据转发，使用负载均衡算法保证每个逻辑服务器的工作量均衡，以及进行数据加密。 **<br>** 逻辑服务器：负责业务逻辑的处理，与网关服务器进行数据交互，同时与数据库服务器进行数据交互。 **<br>** 数据库服务器：数据存储与读取的具体执行者。 **</p></blockquote><h2 id="实现网关服务器需要考虑哪些问题"><a href="#实现网关服务器需要考虑哪些问题" class="headerlink" title="实现网关服务器需要考虑哪些问题"></a>实现网关服务器需要考虑哪些问题</h2><h3 id="效率问题"><a href="#效率问题" class="headerlink" title="效率问题"></a>效率问题</h3><blockquote><p>当我们需要用到网关服务器来负载均衡时，我可以假定我们需要处理的客户端请求是很多的(当然，我这里只是为了学习，具体业务并不需要)，也就是说我们需要高并发，<br>高效处理。<br>因为网关服务器在客户端和逻辑服务器间相当于纽带的作用，所有的数据包都要从此经过，所以我们的网关服务器必须要保证可以 ** 高效的处理大量连接上的事件 **<br>。</p></blockquote><h3 id="安全问题"><a href="#安全问题" class="headerlink" title="安全问题"></a>安全问题</h3><blockquote><p>如上所说，如果网关服务器被恶意发起连接，一旦挂掉，我们的全部服务都会终止，因此我们必须要对这种情况进行处理。同时，还有与客户端交互时的数据加密，这个事也<br>是要交给网关服务器来进行的。逻辑服务器一般都会与网关服务器配置于同一个局域网，所以通常不需要考虑数据的加密。</p></blockquote><h3 id="对连接的标识"><a href="#对连接的标识" class="headerlink" title="对连接的标识"></a>对连接的标识</h3><blockquote><p>逻辑服务器和客户端都会连接在网关服务器上，而网关服务器需要对其sockfd进行标识，要知晓究竟谁是服务器，谁是客户端，而且要对客户端的连接加一条可检索属<br>性(比如用户名).<br>为什么呢？因为对于客户端发送过来的数据，我们无论转到哪个逻辑服务器上都可以，而逻辑服务器返回的数据，我们需要知道要将该数据返回给哪个客户端，逻辑服务器并不能<br>知道每个客户端的sockfd是多少。</p></blockquote><h3 id="下面我们着重聊聊效率问题："><a href="#下面我们着重聊聊效率问题：" class="headerlink" title="下面我们着重聊聊效率问题："></a>下面我们着重聊聊效率问题：</h3><h4 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h4><blockquote></blockquote><p>我们不会去为每个sockfd都分配一个线程去服务它，我们更需要有一个线程可以去监听所有的fd上的事件，如果发生，我们再去分配线程去处理他。这就是多路复用。<br>多路复用有select poll<br>epoll，几乎凡是知道多路复用的人都知道epoll的高效。因为其底层红黑树，以及回调机制，是我们最好的选择(在大量连接，活跃量不高的情况下)。<br>而epoll分两种工作模式，LT和ET，LT模式下，epoll只是一个高效的poll，ET模式下会更高效。事实上众多的第三方库都使用的是LT模式，说白了就是<br>性价比，LT已经很高效，而改用ET模式，除了效率会更高，也会给编写带来一些复杂性以及产生一些头疼的问题，而处理这些特殊情况也需要时间，处理方式不当的话反而还<br>不如LT，所以，总而言之，性价比不高。(本人为了学习，此处使用的et模式)。</p><h4 id="非阻塞"><a href="#非阻塞" class="headerlink" title="非阻塞"></a>非阻塞</h4><blockquote><p>每个连接的sockfd，我们都有两种操作其的方式，阻塞和非阻塞，阻塞意味着我们此刻必须对sockfd进行等待，就是说我们不能去干别的事，这显然不可以。因<br>此，在以高并发为目标的服务器程序里，非阻塞是我们唯一的选择。<br>并且，et模式下，必须非阻塞，不然会产生套接字饿死的情况。<br>非阻塞模式下，我们还需要一样东西，就是缓冲区，因为你并不能保证你接受到的数据就是完整的。</p></blockquote><h4 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h4><p>这里使用的是多线程Reacter半同步半异步模式。<br>主线程负责监听以及接收新的连接，维护一个任务队列，其余线程从任务队列里获取任务并完成，同时也将新的任务添加进任务队列。</p><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><blockquote><p>总体分为以下部分</p></blockquote><h3 id="main-h"><a href="#main-h" class="headerlink" title="main.h"></a>main.h</h3><blockquote><p>程序主线程：监听fd绑定、监听，epoll监听</p></blockquote><h3 id="Connection-h"><a href="#Connection-h" class="headerlink" title="Connection.h"></a>Connection.h</h3><blockquote><p>客户端和逻辑服务器的连接的封装<br>实现对连接的操作：<br>HandleRead()读, HandleWrite()写, Worker()数据处理,<br>shutdown()连接关闭,getData()从用户缓冲区获取数据,puttData()将数据写入用户缓冲区</p></blockquote><h3 id="ThreadPool-h"><a href="#ThreadPool-h" class="headerlink" title="ThreadPool.h"></a>ThreadPool.h</h3><blockquote><p>线程池的封装</p></blockquote><h3 id="SyncQueue-h"><a href="#SyncQueue-h" class="headerlink" title="SyncQueue.h"></a>SyncQueue.h</h3><blockquote><p>任务队列的封装<br>实现队列的添加取出，以及同步加锁等处理</p></blockquote><h3 id="Buffer-h"><a href="#Buffer-h" class="headerlink" title="Buffer.h"></a>Buffer.h</h3><blockquote><p>用户缓存区的封装</p></blockquote><h3 id="BaseFunc-h"><a href="#BaseFunc-h" class="headerlink" title="BaseFunc.h"></a>BaseFunc.h</h3><blockquote><p>基本函数的封装：如 setNoBlocking(), addFd()…</p></blockquote><h3 id="Util-h"><a href="#Util-h" class="headerlink" title="Util.h"></a>Util.h</h3><blockquote><p>工具类</p></blockquote><h2 id="正确性测试结果"><a href="#正确性测试结果" class="headerlink" title="正确性测试结果"></a>正确性测试结果</h2><p><img src="http://img.blog.csdn.net/20161205214912642" alt="这里写图片描述"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="main-cpp"><a href="#main-cpp" class="headerlink" title="main.cpp"></a>main.cpp</h3><pre><code class="hljs">////  GataMain.cpp//  QuoridorServer////  Created by shiyi on 2016/12/2.//  Copyright © 2016年 shiyi. All rights reserved.//#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;fcntl.h&gt;#include &lt;sys/socket.h&gt;#include &lt;sys/types.h&gt;#include &lt;signal.h&gt;#include &lt;string.h&gt;#include &lt;sys/epoll.h&gt;#include &lt;unistd.h&gt;#include &lt;assert.h&gt;#include &lt;sys/wait.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;functional&gt;#include &quot;Util.h&quot;#include &quot;ThreadPool.h&quot;#include &quot;Connection.h&quot;#include &quot;BaseFunc.h&quot;static const char *IP = &quot;10.105.44.34&quot;;// static const char *IP = &quot;127.0.0.1&quot;;// static const char *IP = &quot;182.254.243.29&quot;;static const int PORT = 11111;//处理的最大连接数static const int USER_PROCESS = 655536;//epoll能监听的最大事件static const int MAX_EVENT_NUMBER = 10000;//信号通信的管道static int sigPipefd[2];//信号回调函数static void sigHandler(int sig)&#123;    int saveErrno = errno;    send(sigPipefd[1], (char*)&amp;sig, 1, 0);    errno = saveErrno;&#125;//添加信号回调static void addSig(int sig, void(handler)(int), bool restart = true)&#123;    struct sigaction sa;    memset(&amp;sa, 0, sizeof(sa));    sa.sa_handler = handler;    if(restart)        sa.sa_flags |= SA_RESTART;    sigfillset(&amp;sa.sa_mask);    if(-1 == sigaction(sig, &amp;sa, NULL))        Util::outError(&quot;sigaction&quot;);&#125;static int setupSigPipe()&#123;    //新建epoll监听表和事件管道    int epollfd = epoll_create(USER_PROCESS);    if(epollfd == -1)        Util::outError(&quot;epoll_create&quot;);    int ret = socketpair(PF_UNIX, SOCK_STREAM, 0, sigPipefd);    assert(ret == 0);    //将写设置为非阻塞    setNoBlocking(sigPipefd[1]);    addFd(epollfd, sigPipefd[0], EPOLLIN | EPOLLET);    setNoBlocking(sigPipefd[0]);    //设置信号处理函数    addSig(SIGCHLD, sigHandler);    addSig(SIGTERM, sigHandler);    addSig(SIGINT, sigHandler);    addSig(SIGPIPE, sigHandler);    return epollfd;&#125;int main()&#123;    int ret;    //构造协议地址结构    struct sockaddr_in address;    bzero(&amp;address, sizeof(address));    address.sin_family = PF_INET;    inet_pton(PF_INET, IP, &amp;address.sin_addr);    address.sin_port = htons(PORT);    int listenfd = socket(PF_INET, SOCK_STREAM, 0);    assert( listenfd &gt;= 0 );    int opt = 1;    if(setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, (void*)&amp;opt, sizeof(int)) &lt; 0)    &#123;        perror(&quot;setsockopt&quot;);        exit(1);    &#125;    ret = bind(listenfd, (struct sockaddr*)&amp;address, sizeof(address));    if(ret == -1)    &#123;        perror(&quot;bind&quot;);    &#125;    if(listen(listenfd, 1000) &lt; 0)    &#123;        perror(&quot;listen&quot;);        exit(1);    &#125;    Connection *users = new Connection[USER_PROCESS];    ThreadPool threadPool;    //统一事件源    int epollfd = setupSigPipe();    epoll_event events[MAX_EVENT_NUMBER];    // addFd(epollfd, listenfd, EPOLLIN | EPOLLET);    addFd(epollfd, listenfd, EPOLLIN);    // setNoBlocking(m_listenfd);    bool isRunning = true;    while(isRunning)    &#123;        int num = epoll_wait(epollfd, events, MAX_EVENT_NUMBER, -1);        //如果错误原因不是被中断，则循环退出        if((num &lt; 0) &amp;&amp; (errno != EINTR))        &#123;            Util::outError(&quot;epoll_wait failure&quot;);            break;        &#125;        for(int i=0; i&lt;num; i++)        &#123;            int sockfd = events[i].data.fd;            //处理新的请求            if(sockfd == listenfd)            &#123;                //连接新的请求                struct sockaddr_in clientAddr;                socklen_t clientLen = sizeof(clientAddr);                int connfd = accept(listenfd, (struct sockaddr*)&amp;clientAddr, &amp;clientLen);                if(connfd &lt; 0)                &#123;                    Util::outError(&quot;accept&quot;);                    break;                &#125;                Util::outMsg(&quot;accept a new client : %d %s\n&quot;, connfd, inet_ntoa(clientAddr.sin_addr));                addFd(epollfd, connfd, EPOLLIN | EPOLLET | EPOLLONESHOT);                setNoBlocking(connfd);                //初始化客户端链接                users[connfd].init(epollfd, connfd, clientAddr);            &#125;            //处理信号            else if((sockfd == sigPipefd[0]) &amp;&amp; (events[i].events &amp; EPOLLIN))            &#123;                char sigMsg[1024];                int ret = recv(sockfd, sigMsg, sizeof(sigMsg), 0);                if(ret &lt;= 0)                &#123;                    continue;                &#125;                for(int j=0; j&lt;ret; j++)                &#123;                    //循环处理每个信号                    switch(sigMsg[j])                    &#123;                        case SIGCHLD:                        &#123;                            break;                        &#125;                        case SIGTERM:                        case SIGINT:                        &#123;                            //退出                            Util::outMsg(&quot;程序退出\n&quot;);                            isRunning = false;                            break;                        &#125;                    &#125;                &#125;            &#125;            //处理读事件            else if(events[i].events &amp; EPOLLIN)            &#123;                //向任务队列添加读任务                threadPool.AddTask(std::bind(&amp;Connection::HandleRead, users+sockfd));            &#125;            //处理写事件            else if(events[i].events &amp; EPOLLOUT)            &#123;                // cout&lt;&lt;&quot;hello&quot;&lt;&lt;sockfd&lt;&lt;endl;                threadPool.AddTask(std::bind(&amp;Connection::HandleWrite, users+sockfd));            &#125;        &#125;    &#125;    delete[] users;    close(sigPipefd[0]);    close(sigPipefd[1]);    close(epollfd);    return 0;&#125;</code></pre><h3 id="Connection-h-1"><a href="#Connection-h-1" class="headerlink" title="Connection.h"></a>Connection.h</h3><pre><code class="hljs">////  Connection.h//  QuoridorServer////  Created by shiyi on 2016/12/2.//  Copyright © 2016年 shiyi. All rights reserved.//#ifndef Connection_H#define Connection_H#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;atomic&gt;#include &lt;fcntl.h&gt;#include &lt;sys/socket.h&gt;#include &lt;sys/types.h&gt;#include &lt;signal.h&gt;#include &lt;string.h&gt;#include &lt;sys/epoll.h&gt;#include &lt;unistd.h&gt;#include &lt;assert.h&gt;#include &lt;stdlib.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;errno.h&gt;#include &lt;map&gt;#include &quot;Buffer.h&quot;#include &quot;Util.h&quot;#include &quot;BaseFunc.h&quot;#include &quot;json/json.h&quot;const std::string serverIP[] = &#123;    &quot;127.0.0.1&quot;,    &quot;182.254.243.29&quot;&#125;;const size_t BUFFER_SIZE = 65535;class Connection&#123;public:    static std::vector&lt;Connection*&gt; serverConnVt;    static std::map&lt;string, Connection*&gt; clientConnMap;    static int serverIdx;    static Connection* getServerConn()    &#123;        int size = serverConnVt.size();        if(size == 0)            return NULL;        serverIdx = (serverIdx+1)%size;        return serverConnVt[serverIdx];    &#125;    Connection() : m_writeing(true), m_epollfd(-1), m_sockfd(-1)    &#123;&#125;    ~Connection()&#123;&#125;    //初始化连接    void init(int epollfd, int sockfd, const sockaddr_in&amp; clientAddr)    &#123;        //初始化读写缓冲区        m_inBuff.init();        m_outBuff.init();        m_epollfd = epollfd;        m_sockfd = sockfd;        m_writeing = true;        m_address = clientAddr;        m_username = &quot;&quot;;        m_type = -1;        std::string sip(inet_ntoa(clientAddr.sin_addr));        for(auto&amp; ip : serverIP)        &#123;            if(ip.compare(0, sip.size(), sip) == 0)            &#123;                m_type = 1;                serverConnVt.push_back(this);                cout&lt;&lt;sip&lt;&lt;&quot;是服务端&quot;&lt;&lt;endl;                break;            &#125;        &#125;        if(m_type != 1)        &#123;            char t[10];            sprintf(t, &quot;%d&quot;, m_sockfd);            m_username = t;            //存入客户端映射表            clientConnMap.insert(pair&lt;string, Connection*&gt;(m_username, this));        &#125;    &#125;    void HandleRead()    &#123;        cout&lt;&lt;&quot;read&quot;&lt;&lt;endl;        while(true)        &#123;            char buf[BUFFER_SIZE];            int ret = recv(m_sockfd, buf, BUFFER_SIZE, 0);            if(ret &lt; 0)            &#123;                //缓冲区内容已读完                if((errno == EAGAIN) || (errno == EWOULDBLOCK))                &#123;                    modFd(m_epollfd, m_sockfd, EPOLLIN | EPOLLET | EPOLLONESHOT);                    break;                &#125;                //其他错误直接断开连接                Util::outError(&quot;HandleRead&quot;);                shutdown();                return;            &#125;            //断开连接            else if(ret == 0)            &#123;                shutdown();                return;            &#125;            else            &#123;                //将读取的内容加入缓冲区                m_inBuff.PutData(buf, ret);            &#125;        &#125;        worker();    &#125;    void HandleWrite()    &#123;        cout&lt;&lt;&quot;write&quot;&lt;&lt;endl;        //更改临界值        if(!m_writeing)        &#123;            //休眠等待            usleep(1000);            //下次再来            modFd(m_epollfd, m_sockfd, EPOLLIN | EPOLLOUT | EPOLLET | EPOLLONESHOT);            return;        &#125;        m_writeing = false;        //取出数据        char buf[BUFFER_SIZE];        int len = m_outBuff.GetDataAll(buf);        int n = len;        while (n &gt; 0)        &#123;            int ret = send(m_sockfd, buf+len-n, n, 0);            if (ret &lt; n)            &#123;                if (ret == -1 &amp;&amp; errno != EAGAIN)                &#123;                    Util::outError(&quot;write error&quot;);                &#125;                break;            &#125;            n -= ret;        &#125;        //n=0表示数据全部写完，删除写事件        if(n == 0)        &#123;            modFd(m_epollfd, m_sockfd, EPOLLIN | EPOLLET | EPOLLONESHOT);        &#125;        else        &#123;            modFd(m_epollfd, m_sockfd, EPOLLIN | EPOLLOUT | EPOLLET | EPOLLONESHOT);        &#125;        //恢复临界值        m_writeing = true;    &#125;    void clientWork()    &#123;        //解析        //取出数据        char buf[BUFFER_SIZE];        int len = getData(buf);        //解密buf        printf(&quot;recv from %d :%s\n&quot;, m_sockfd, buf);        std::string recvUser;        Json::Reader reader;        Json::Value inRoot;        Json::Value outRoot;        if(reader.parse(buf, inRoot))        &#123;            Json::Value data = inRoot[&quot;data&quot;];            outRoot[&quot;data&quot;] = data;            outRoot[&quot;user&quot;] = m_username;        &#125;        Connection* toConn = getServerConn();        if(toConn-&gt;m_sockfd == -1)        &#123;            printf(&quot;无可用逻辑服务器\n&quot;);            return;        &#125;        //生成json字符串        std::string outStr = outRoot.toStyledString();        len = outStr.size();        printf(&quot;send to %d :%s\n&quot;, toConn-&gt;m_sockfd, outStr.c_str());        memcpy(buf, &amp;len, 4);        memcpy(buf+4, outStr.c_str(), len);        toConn-&gt;putData(buf, len+4);        modFd(m_epollfd, toConn-&gt;m_sockfd, EPOLLIN | EPOLLOUT | EPOLLET | EPOLLONESHOT);    &#125;    void serverWork()    &#123;        //解析        //取出数据        char buf[BUFFER_SIZE];        int len = getData(buf);        //解密buf        printf(&quot;recv from %d :%s\n&quot;, m_sockfd, buf);        std::string toUser;        Json::Reader reader;        Json::Value inRoot;        Json::Value outRoot;        if(reader.parse(buf, inRoot))        &#123;            toUser = inRoot[&quot;user&quot;].asString();            Json::Value data = inRoot[&quot;data&quot;];            outRoot[&quot;data&quot;] = data;        &#125;        auto iter = clientConnMap.find(toUser);        if(iter == clientConnMap.end())        &#123;            printf(&quot;客户端%s不存在\n&quot;, toUser.c_str());            return;        &#125;        Connection* toConn = (*iter).second;        //生成json字符串        std::string outStr = outRoot.toStyledString();        len = outStr.size();        printf(&quot;send to %d :%s\n&quot;, toConn-&gt;m_sockfd, outStr.c_str());        memcpy(buf, &amp;len, 4);        memcpy(buf+4, outStr.c_str(), len);        toConn-&gt;putData(buf, len+4);        modFd(m_epollfd, toConn-&gt;m_sockfd, EPOLLIN | EPOLLOUT | EPOLLET | EPOLLONESHOT);    &#125;    int getData(char *buf)    &#123;        return m_inBuff.GetData(buf);    &#125;    void putData(char *buf, int len)    &#123;        while(!m_writeing)            usleep(1000);        m_writeing = false;        m_outBuff.PutData(buf, len);        m_writeing = true;    &#125;    void worker()    &#123;        //serverWork();        if(m_type == 1)        &#123;            cout&lt;&lt;&quot;workerServer&quot;&lt;&lt;endl;            serverWork();        &#125;        else        &#123;            cout&lt;&lt;&quot;workerClient&quot;&lt;&lt;endl;            clientWork();        &#125;    &#125;    void shutdown()    &#123;        //等待写事件完成后关闭        while(!m_writeing)            usleep(1000);        m_writeing = false;        removeFd(m_epollfd, m_sockfd);        m_writeing = true;        //服务端        if(m_type == 1)        &#123;            for(auto i=serverConnVt.begin(); i!=serverConnVt.end(); i++)            &#123;                if((*i)-&gt;m_sockfd == m_sockfd)                &#123;                    //在vt中删除该连接                    serverConnVt.erase(i);                    cout&lt;&lt;&quot;退出服务端&quot;&lt;&lt;m_sockfd&lt;&lt;endl;                    break;                &#125;            &#125;        &#125;        //客户端        else        &#123;            //map删除            auto iter = clientConnMap.find(m_username);            if(iter != clientConnMap.end())            &#123;                clientConnMap.erase(iter);                printf(&quot;客户端%s退出\n&quot;, m_username.c_str());            &#125;        &#125;    &#125;private:    int m_epollfd;                   //epoll描述符    int m_sockfd;                    //套接字描述符    std::string m_username;            //连接唯一标识    int m_type;                        //连接类型   -1为未知客户端   0为已知客户端   1为服务端    sockaddr_in m_address;           //套接字地址    Buffer m_inBuff;                 //读缓冲    Buffer m_outBuff;                //写缓冲    std::atomic_bool m_writeing;     //是否正在写&#125;;std::vector&lt;Connection*&gt; Connection::serverConnVt;std::map&lt;string, Connection*&gt; Connection::clientConnMap;int Connection::serverIdx = -1;#endif /* Connection_H */</code></pre><h3 id="Buffer-h-1"><a href="#Buffer-h-1" class="headerlink" title="Buffer.h"></a>Buffer.h</h3><pre><code class="hljs">////  Buffer.h//  QuoridorServer////  Created by shiyi on 2016/12/2.//  Copyright © 2016年 shiyi. All rights reserved.//#ifndef Buffer_H#define Buffer_H#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;class Buffer&#123;public:    Buffer() : m_widx(0), m_ridx(0)    &#123;&#125;    ~Buffer()&#123;&#125;    void init()    &#123;        m_widx = m_ridx = 0;        m_buf.clear();    &#125;    //增加内容    void PutData(char *data, int len)    &#123;        //如果调整空间后足够存放，则进行调整        int capa = m_buf.capacity();        if(capa &lt; m_widx + len &amp;&amp; capa &gt; len + m_widx - m_ridx)            adjust();        for(int i = 0; i &lt; len; i++)            m_buf.push_back(data[i]);        m_widx += len;    &#125;    //返回获取的包的大小，数据不完整返回-1    int GetData(char* data)    &#123;        if(m_widx - m_ridx &lt; 4)            return -1;        int len;        char *t = (char*)&amp;len;        for(int i=0; i&lt;4; i++)        &#123;            t[i] = m_buf[m_ridx+i];        &#125;        //printf(&quot;-=-=%d\n&quot;, len);        if(len+4 &gt; m_widx-m_ridx)            return -1;        m_ridx += 4;        for(int i = 0; i &lt; len; i++)        &#123;            data[i] = m_buf[m_ridx++];        &#125;        if(m_ridx &gt;= m_widx)        &#123;            m_ridx = m_widx = 0;            m_buf.clear();        &#125;        return len;    &#125;    //返回Buffer内全部内容    int GetDataAll(char* data)    &#123;        int len = m_widx-m_ridx;        for(int i = 0; i &lt; len; i++)        &#123;            if(m_ridx &gt;= m_widx)                break;            data[i] = m_buf[m_ridx++];        &#125;        if(m_ridx &gt;= m_widx)        &#123;            m_ridx = m_widx = 0;            m_buf.clear();        &#125;        return len;    &#125;private:    //将数据移至容器头部，充分利用空间    void adjust()    &#123;        vector&lt;char&gt; t(m_buf.begin()+m_ridx, m_buf.begin()+m_widx);        m_widx -= m_ridx;        m_ridx = 0;        m_buf.clear();        for(int i=0; i&lt;m_widx; i++)            m_buf.push_back(t[i]);    &#125;private:    int m_ridx;    int m_widx;    std::vector&lt;char&gt; m_buf;&#125;;#endif /* Buffer_H */</code></pre><h3 id="ThreadPool-h-1"><a href="#ThreadPool-h-1" class="headerlink" title="ThreadPool.h"></a>ThreadPool.h</h3><pre><code class="hljs">////  ThreadPool.h//  QuoridorServer////  Created by shiyi on 2016/11/30.//  Copyright © 2016年 shiyi. All rights reserved.//#ifndef ThreadPool_H#define ThreadPool_H#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;functional&gt;#include &lt;thread&gt;#include &lt;atomic&gt;#include &quot;SyncQueue.h&quot;const int MaxTaskCount = 100;class ThreadPool&#123;public:    using Task = std::function&lt;void()&gt;;    ThreadPool(int numThreads = std::thread::hardware_concurrency()) : m_queue(MaxTaskCount)    &#123;        if(numThreads &lt; 4)            numThreads = 4;        printf(&quot;线程池启动-%d线程\n&quot;, numThreads);        Start(numThreads);    &#125;    ~ThreadPool()    &#123;        Stop();    &#125;    void Stop()    &#123;        std::call_once(m_flag, [this]&#123;            StopThreadGroup();        &#125;);    &#125;    void AddTask(Task&amp;&amp; task)    &#123;        m_queue.Push(std::forward&lt;Task&gt;(task));    &#125;    void AddTask(const Task&amp; task)    &#123;        m_queue.Push(task);    &#125;private:    void Start(int numThreads)    &#123;        m_running = true;        //创建线程组        for(int i=0; i&lt;numThreads; i++)        &#123;            m_threadGroup.push_back(std::make_shared&lt;std::thread&gt;(&amp;ThreadPool::RunInThread, this));        &#125;    &#125;    void RunInThread()    &#123;        while(m_running)        &#123;            std::queue&lt;Task&gt; queue;            m_queue.Take(queue);            std::queue&lt;int&gt; a;            while(!queue.empty())            &#123;                if(!m_running)                    return;                auto task = queue.front();                queue.pop();                task();            &#125;        &#125;    &#125;    void StopThreadGroup()    &#123;        m_queue.Stop();        m_running = false;        for(auto thread : m_threadGroup)        &#123;            thread-&gt;join();        &#125;        m_threadGroup.clear();    &#125;private:    SyncQueue&lt;Task&gt; m_queue;                                    //同步队列    std::vector&lt;std::shared_ptr&lt;std::thread&gt;&gt; m_threadGroup;    //处理任务的线程组    atomic_bool m_running;                                      //是否停止    std::once_flag m_flag;&#125;;#endif /* ThreadPool_H */</code></pre><h3 id="SyncQueue-h-1"><a href="#SyncQueue-h-1" class="headerlink" title="SyncQueue.h"></a>SyncQueue.h</h3><pre><code class="hljs">////  SyncQueue.h//  QuoridorServer////  Created by shiyi on 2016/11/30.//  Copyright © 2016年 shiyi. All rights reserved.//#ifndef SyncQueue_H#define SyncQueue_H#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;mutex&gt;#include &lt;thread&gt;#include &lt;queue&gt;#include &lt;condition_variable&gt;using namespace std;template &lt;typename T&gt;class SyncQueue&#123;public:    SyncQueue(int maxSize) : m_maxSize(maxSize), m_isStop(false)    &#123;    &#125;    ~SyncQueue()&#123;&#125;    void Push(const T&amp; x)    &#123;        Add(x);    &#125;    void Push(T&amp;&amp; x)    &#123;        Add(x);    &#125;    void Take(T&amp; t)    &#123;        std::unique_lock&lt;std::mutex&gt; locker(m_mutex);        m_notEmpty(locker, [this]&#123;            return m_isStop || m_notEmpty();        &#125;);        if(m_isStop)            return;        t = m_queue.front();        m_queue.pop();        m_notFull.notify_one();    &#125;    void Take(std::queue&lt;T&gt;&amp; queue)    &#123;        std::unique_lock&lt;std::mutex&gt; locker(m_mutex);        m_notEmpty.wait(locker, [this]&#123;            return m_isStop || NotEmpty();        &#125;);        if(m_isStop)            return;        queue = std::move(m_queue);        m_notFull.notify_one();    &#125;    void Stop()    &#123;        &#123;            std::lock_guard&lt;std::mutex&gt; locker(m_mutex);            m_isStop = true;        &#125;        m_notFull.notify_all();        m_notEmpty.notify_all();    &#125;    bool Empty()    &#123;        std::lock_guard&lt;std::mutex&gt; locker(m_mutex);        return m_queue.empty();    &#125;    bool Full()    &#123;        std::lock_guard&lt;std::mutex&gt; locker(m_mutex);        return m_queue.size() &gt;= m_maxSize;    &#125;private:    bool NotFull()    &#123;        bool full = m_queue.size() &gt;= m_maxSize;        if(full)            cout&lt;&lt;&quot;缓冲区满，需要等待...&quot;&lt;&lt;this_thread::get_id()&lt;&lt;endl;        return !full;    &#125;    bool NotEmpty()    &#123;        bool empty = m_queue.empty();        if(empty)            cout&lt;&lt;&quot;缓冲区空，需要等待...&quot;&lt;&lt;this_thread::get_id()&lt;&lt;endl;        return !empty;    &#125;    template&lt;typename F&gt;    void Add(F&amp;&amp; x)    &#123;        std::unique_lock&lt;std::mutex&gt; locker(m_mutex);        m_notFull.wait(locker, [this]&#123;            return m_isStop || NotFull();        &#125;);        if(m_isStop)            return;        m_queue.push(std::forward&lt;F&gt;(x));        m_notEmpty.notify_one();    &#125;private:    bool m_isStop;                     //是否停止    int m_maxSize;                     //同步队列最大的长度    std::queue&lt;T&gt; m_queue;                  //缓冲区    std::mutex m_mutex;                     //互斥量    std::condition_variable m_notEmpty;     //不为空的条件变量    std::condition_variable m_notFull;      //不满的条件变量&#125;;#endif /* SyncQueue_H */</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>服务器开发</tag>
      
      <tag>C++</tag>
      
      <tag>Linux网络编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Epoll-ET模式读写之用户连接的封装</title>
    <link href="/posts/12582.html"/>
    <url>/posts/12582.html</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>服务端而言，对于每一个新的连接我们都需要去保存其基本信息，如ip地址，套接字fd，也需要赋予其唯一标识如用户名。<br>这里，我们来谈谈对用户连接的封装。</p></blockquote><h3 id="用户连接需要哪些数据"><a href="#用户连接需要哪些数据" class="headerlink" title="用户连接需要哪些数据"></a>用户连接需要哪些数据</h3><pre><code class="hljs">1. 套接字描述符 sockfd        执行读写操作时当然不可缺2. 连接信息  sockaddr        基本信息的保存3. 用户缓存区 Buffer        非阻塞读写不可缺4. 唯一标识        服务端进行消息转发时不可能根据sockfd去进行查找，所以我们需要对每一个连接有一个唯一标识，用于对其进行检索</code></pre><p>关于Buffer细节可看 <a href="http://blog.csdn.net/to_be_better/article/details/53441468"> Epoll-ET模式下非阻塞读写之Buffer的封装</a></p><h3 id="用户连接需要哪些操作"><a href="#用户连接需要哪些操作" class="headerlink" title="用户连接需要哪些操作"></a>用户连接需要哪些操作</h3><pre><code class="hljs">1. 读    epoll-Et模式下，读必须将缓冲区全部读完，否则不会再次触发2. 写    epoll-Et模式下，写必须将所写数据全部写入或是写到缓冲区满，否则不会再次触发3. 断开    断开时，如果是异步读写，需要需要确认写事件已全部完成，再关闭套接字4. 初始化    保证连接可复用，否则每来一个连接，都要开辟空间，太过低效。</code></pre><h3 id="关于读写的细节"><a href="#关于读写的细节" class="headerlink" title="关于读写的细节"></a>关于读写的细节</h3><blockquote><p>本身 send和recv都是线程安全的。<br>因为读操作，我们可以确定只会有一个线程来对读操作进行处理(通过设置EPOLLONESHOT)，也就是说对读缓冲区的写入(接受数据)和取出(处理数据)都是在一<br>个线程内，所以读缓冲区本质上是线程安全的。<br>但是写操作，写缓冲区可能会有多个线程对其进行写入和更改，所以我们用一个原子变量，来标志写缓冲区是否被操作，来保证数据读写不会冲突。</p></blockquote><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>本代码数据处理只是简单的进行转发到原本socket里</p><pre><code class="hljs">////  Connection.h//  QuoridorServer////  Created by shiyi on 2016/12/2.//  Copyright © 2016年 shiyi. All rights reserved.//#ifndef Connection_H#define Connection_H#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;atomic&gt;#include &lt;fcntl.h&gt;#include &lt;sys/socket.h&gt;#include &lt;sys/types.h&gt;#include &lt;signal.h&gt;#include &lt;string.h&gt;#include &lt;sys/epoll.h&gt;#include &lt;unistd.h&gt;#include &lt;assert.h&gt;#include &lt;stdlib.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;errno.h&gt;#include &quot;Buffer.h&quot;#include &quot;Util.h&quot;#include &quot;BaseFunc.h&quot;const size_t BUFFER_SIZE = 65535;class Connection&#123;public:    Connection() : m_writeing(true), m_epollfd(-1), m_sockfd(-1)    &#123;&#125;    ~Connection()&#123;&#125;    //初始化连接    void init(int epollfd, int sockfd, const sockaddr_in&amp; client_addr)    &#123;        m_epollfd = epollfd;        m_sockfd = sockfd;        m_writeing = true;        m_address = client_addr;        //初始化读写缓冲区        m_inBuff.init();        m_outBuff.init();    &#125;    void HandleRead()    &#123;        while(true)        &#123;            char buf[BUFFER_SIZE];            int ret = recv(m_sockfd, buf, BUFFER_SIZE, 0);            if(ret &lt; 0)            &#123;                //缓冲区内容已读完                if((errno == EAGAIN) || (errno == EWOULDBLOCK))                &#123;                    break;                &#125;                //其他错误直接断开连接                Util::outError(&quot;HandleRead&quot;);                shutdown();            &#125;            //断开连接            else if(ret == 0)            &#123;                shutdown();            &#125;            else            &#123;                //将读取的内容加入缓冲区                m_inBuff.PutData(buf, ret);            &#125;            //printf(&quot;[%s]\n&quot;, buf);        &#125;        worker();    &#125;    void HandleWrite()    &#123;        //更改临界值        if(!m_writeing)            return;        m_writeing = false;        //取出数据        char buf[BUFFER_SIZE];        int len = m_outBuff.GetData(buf, BUFFER_SIZE);        int n = len;        while (n &gt; 0)        &#123;            int ret = send(m_sockfd, buf+len-n, n, 0);            if (ret &lt; n)            &#123;                if (ret == -1 &amp;&amp; errno != EAGAIN)                &#123;                    Util::outError(&quot;write error&quot;);                &#125;                break;            &#125;            n -= ret;        &#125;        //n=0表示数据全部写完，删除写事件        if(n == 0)            modFd(m_epollfd, m_sockfd, EPOLLIN | EPOLLET | EPOLLONESHOT);        //恢复临界值        m_writeing = true;    &#125;    void worker()    &#123;        //解析        //取出数据        char buf[BUFFER_SIZE];        int len = m_inBuff.GetData(buf, BUFFER_SIZE);        while(!m_writeing)            usleep(1000);        m_writeing = false;        m_outBuff.PutData(buf, len);        modFd(m_epollfd, m_sockfd, EPOLLIN | EPOLLOUT | EPOLLET | EPOLLONESHOT);        m_writeing = true;    &#125;    void shutdown()    &#123;        //等待写事件完成后关闭        while(!m_writeing)            usleep(1000);        m_writeing = false;        removeFd(m_epollfd, m_sockfd);    &#125;private:    int m_epollfd;              //epoll描述符    int m_sockfd;               //套接字描述符    sockaddr_in m_address;      //套接字地址    Buffer m_inBuff;            //读缓冲    Buffer m_outBuff;           //写缓冲    std::atomic_bool m_writeing;     //是否正在写&#125;;#endif /* Connection_H */</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>服务器开发</tag>
      
      <tag>Linux网络编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Epoll-ET模式下非阻塞读写之Buffer的封装</title>
    <link href="/posts/20402.html"/>
    <url>/posts/20402.html</url>
    
    <content type="html"><![CDATA[<h3 id="先说说Epoll的ET模式"><a href="#先说说Epoll的ET模式" class="headerlink" title="先说说Epoll的ET模式"></a>先说说Epoll的ET模式</h3><blockquote><p>epoll默认的模式是LT，要说ET不得不提到LT，LT与ET的区别可以用一句话概括：<br>LT模式下只要socket处于可读状态(添加EPOLLIN事件时)或可写状态(添加EPOLLOUT事件时)，就会一直返回其socket。<br>ET模式下在第一次返回socket后，只有当socket由不可写到可写(添加EPOLLIN事件时)或由不可读到可读(添加EPOLLOUT事件时)，才会返回其<br>socket。</p></blockquote><p>进一步捋一下</p><blockquote><p>由上可得，我们对ET操作必须要做到以下条件：<br>如果读：必须要将缓冲区的内容全部读出，即读到缓冲区空为止<br>如果写：一直写，知道需写的数据写完或是缓冲区满为止。<br>** 要做到以上要求，我们必须使用非阻塞套接字，否则socket会常常处在阻塞情况下，从而导致其他套接字饿死的情况发生。 ** (何谓饿死，程序阻塞在当前套接字的操作上，而其他套接字根本没有机会进行操作)</p></blockquote><h3 id="为什么我们需要Buffer"><a href="#为什么我们需要Buffer" class="headerlink" title="为什么我们需要Buffer"></a>为什么我们需要Buffer</h3><blockquote><p>** TCP 是一个无边界的字节流协议，接收方必须要处理“收到的数据尚不构成一条完整的消息”和“一次收到两条消息的数据”等等情况。 **<br>如果是阻塞模式下，上面的情况根本不需要考虑，因为只要你recv，数据最终一定会过来，但代价就是你会一直阻塞在那里，我们编写服务器当然要尽可能的避免这种情况的<br>出现，所以我们使用非阻塞套接字。<br>然而，非阻塞模式下，我们就必须要解决上面的情况。<br>** 那么，想想，如果给你一个内存空间，你读取数据时，无论取多少，都先放进这个空间，而要处理时从这个空间取数据即可。 **<br>** 有了这个空间，无论是消息不完整还是多个消息，我们都得以解决。 **<br>** 写也是一样的，当你向socket发送数据时，如果发送了一部分，缓冲区满了，此时我们该怎么办呢，只好一直阻塞，直至socket变回可写，再将剩余的数据全部写入。显然，代价还是阻塞，如果我们不想阻塞，仍然需要一个类似上面的空间。 **<br>这个空间，就是我们说的buffer，也可以叫做用户缓冲区。</p></blockquote><h3 id="Buffer的实现思路"><a href="#Buffer的实现思路" class="headerlink" title="Buffer的实现思路"></a>Buffer的实现思路</h3><blockquote><p>首先，我们希望保证任何时候向buffer里面添加数据，都可以添加成功，也就是说，我们的buffer的空间需要足够大，但我们又不能确定一个固定的数值，因为<br>如果数字设定的小了，还是会出现添加失败的情况，但如果设置的大了，又会导致大量空间的浪费。<br>所以我们将空间设置为可变的，用vector来保存，因为vector空间增长是以2的幂的形式扩展，很高效。<br>用两个指针或是变量来作为读标志和写标志，如下图所示。 <a href="http://www.cppblog.com/Solstice/archive/2011/04/17/144378.html"> 图片摘自Muduo 设计与实现之一：Buffer 类的设计</a> )<br><img src="http://img.blog.csdn.net/20161203033339007"><br>这张图画的相当的清晰明了，一目了然，就不再具体描述了。<br>另外有两点优化，第一点是当Buffer内没有数据的时候(也就是readindex=writeindex时)，要将两个标志全部归零，以免空间一直无限制增长下去<br>，前面的空间反而浪费了。<br>第二点是，要添加数据时，如果剩余的空间不够(writeable)，而加上前面空闲的空间(prependable+writeable)能够放下的话，将数据移动<br>到buffer起始位置，以避免一次空间的增长。</p></blockquote><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="hljs">////  Buffer.h//  QuoridorServer////  Created by shiyi on 2016/12/2.//  Copyright © 2016年 shiyi. All rights reserved.//#ifndef Buffer_H#define Buffer_H#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;class Buffer&#123;public:    Buffer() : m_widx(0), m_ridx(0)    &#123;&#125;    ~Buffer()&#123;&#125;    void init()    &#123;        m_widx = m_ridx = 0;        m_buf.clear();    &#125;    //增加内容    void PutData(char *data, int len)    &#123;        //如果调整空间后足够存放，则进行调整        int capa = m_buf.capacity();        if(capa &lt; m_widx + len &amp;&amp; capa &gt; len + m_widx - m_ridx)            adjust();        for(int i = 0; i &lt; len; i++)            m_buf.push_back(data[i]);        m_widx += len;    &#125;    //返回获取的包的大小，数据不完整返回-1    int GetData(char* data, int len)    &#123;        len = min(m_widx-m_ridx, len);        for(int i = 0; i &lt; len; i++)        &#123;            if(m_ridx &gt;= m_widx)                break;            data[i] = m_buf[m_ridx++];        &#125;        if(m_ridx &gt;= m_widx)        &#123;            m_ridx = m_widx = 0;            m_buf.clear();        &#125;        return len;    &#125;private:    //将数据移至容器头部，充分利用空间    void adjust()    &#123;        vector&lt;char&gt; t(m_buf.begin()+m_ridx, m_buf.begin()+m_widx);        m_widx -= m_ridx;        m_ridx = 0;        m_buf.clear();        for(int i=0; i&lt;m_widx; i++)            m_buf.push_back(t[i]);    &#125;private:    int m_ridx;    int m_widx;    std::vector&lt;char&gt; m_buf;&#125;;#endif /* Buffer_H */</code></pre><p>参考博客 <a href="http://www.cppblog.com/Solstice/archive/2011/04/17/144378.html"> Muduo 设计与实现之一：Buffer 类的设计</a></p>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>服务器开发</tag>
      
      <tag>Linux网络编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux之信号处理函数signal和sigaction</title>
    <link href="/posts/31618.html"/>
    <url>/posts/31618.html</url>
    
    <content type="html"><![CDATA[<h3 id="signal回调函数绑定"><a href="#signal回调函数绑定" class="headerlink" title="signal回调函数绑定"></a>signal回调函数绑定</h3><p>信号(signal)是一种软件中断，它提供了一种处理异步事件的方法，也是进程间惟一的异步通信方式。那么我们很多场景下，需要对不同的信号进行捕获并做出响应操作<br>。<br>在linux上，我们有两种方式完成该操作：</p><h4 id="1-signal"><a href="#1-signal" class="headerlink" title="1. signal"></a>1. signal</h4><pre><code class="hljs">#include &lt;signal.h&gt;signal(int, void (*)(int));</code></pre><blockquote><p>第一个参数是我们要捕获的信号类型，第二个参数是我们要绑定的信号处理函数。</p></blockquote><h4 id="2-sigaction"><a href="#2-sigaction" class="headerlink" title="2. sigaction"></a>2. sigaction</h4><pre><code class="hljs">#include &lt;signal.h&gt;int sigaction(int, const struct sigaction * __restrict, struct sigaction * __orestrict);</code></pre><blockquote><p>相比较signal来说，sigaction与它的功能是类似的，但是更全面。<br>先说一下参数吧，第一个参数同signal，后两个参数类型是一个名为sigaction的结构体，该结构体表示对信号的处理方式，__restrict为新设定的处<br>理方式，__orestrict参数则用于获取之前的信号处理方式。<br>我们来看一下这个结构体的内容：</p></blockquote><pre><code class="hljs">#include &lt;signal.h&gt;struct  sigaction &#123;         union __sigaction_u __sigaction_u;  /* signal handler */         sigset_t sa_mask;               /* signal mask to apply */         int     sa_flags;               /* see signal options below */ &#125;; union __sigaction_u &#123;         void    (*__sa_handler)(int);         void    (*__sa_sigaction)(int, siginfo_t *,                        void *); &#125;;</code></pre><blockquote><p>可以看到该结构体主要由三部分构成，</p></blockquote><pre><code class="hljs">sa_mask，一个信号集sa_flags,  设置程序收到信号时的行为signaction_u  表示信号处理函数</code></pre><blockquote><p>sa_mask和sa_flags都是用二进制位的形式来保存信息的，前者代表着当前进程所能接收到的信号集合，后者代表信号处理的设置信息。<br>sa_flags的值有好多，这里我们只说一个常用的SA_RESTART，书上的解释是【重新调用被该信号终止的系统调用】，最开始我没有理解，写了个小例子尝试后<br>，清晰了许多。<br>一起看看吧</p></blockquote><pre><code class="hljs">void action(int a)&#123;    printf(&quot;%d -=-=\n&quot;, a);&#125;int main()&#123;    int pid = fork();    if(pid &gt; 0)    &#123;        struct sigaction s;        memset(&amp;s, 0, sizeof(s));        s.sa_handler = action;        sigfillset(&amp;s.sa_mask);        //s.sa_flags |= SA_RESTART;        assert(sigaction(SIGCHLD, &amp;s, NULL) != 1);    &#125;    else if(pid == 0)    &#123;        sleep(2);        exit(0);    &#125;    char str[10];    scanf(&quot;%s&quot;, str);    printf(&quot;%s\n&quot;, str);    puts(&quot;End&quot;);    return 0;&#125;</code></pre><blockquote><p>上面这段代码是对SIGCHLD信号(当子进程状态发生变化时产生)进行了信号处理的设定。<br>当子进程执行exit后，会给父进程发送SIGCHLD信号，而父进程本来此时正在进行scanf函数，等待用户输入，在接受到SIGCHLD信号之后，中断目前正在<br>进行的系统调用，然后去执行信号处理函数，也就是上述代码中设定的action函数。在执行完action之后，程序会继续往下执行，也就是下面的结果<br><img src="http://img.blog.csdn.net/20161122031608713" alt="这里写图片描述"> 。</p></blockquote><blockquote></blockquote><blockquote><p>但是当我们把<br>s.sa_flags |= SA_RESTART;<br>这句话注释去掉之后再进行运行，结果如下：<br><img src="http://img.blog.csdn.net/20161122031746031" alt="这里写图片描述"><br>为什么的，因为SA_RESTART参数的设置，信号处理函数在执行完之后会对之前信号中断的系统调用进行重新调用，比如我们这里使用的scanf函数。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>服务器开发</tag>
      
      <tag>Linux网络编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>游戏后台开发九问(腾讯技术分享实录)</title>
    <link href="/posts/31126.html"/>
    <url>/posts/31126.html</url>
    
    <content type="html"><![CDATA[<pre><code class="hljs">[导读]腾讯游戏讯，7月30日消息，第九届中国游戏商务大会网页游戏论坛30日在上海浦东嘉里大酒店展进行相关主题论坛活动。</code></pre><blockquote><p>30日，在上海chinajoy嘉里酒店进行了游戏开发者大会，腾讯游戏的研发部助力总经理聂志明进行了演讲。</p></blockquote><blockquote></blockquote><blockquote><p>他为大家演讲的题目是“游戏后台开发中的九个选择”，他解释，使用这个标题的原因，是因为我们在生活中总会遇到很多选择，这个道理同样适用在游戏开发中。</p></blockquote><blockquote></blockquote><blockquote><p>这九个选择分别是：</p></blockquote><pre><code class="hljs">第一，选择什么样的架构。第二，选择单线程还是多线程。第三，如何在游戏中使用脚本。第四，如何处理网络通讯。第五，如何处理游戏通信协议。第六，如何设计存储结构。第七，如何设计网络同步。第八，如何定义性能基准。第九，如何在不同项目间进行代码复用。</code></pre><p>聂志明先生在他的PPT里详细地为大家讲解了这九个问题，具体情况请参看演讲实录。</p><h2 id="以下是演讲实录："><a href="#以下是演讲实录：" class="headerlink" title="以下是演讲实录："></a>以下是演讲实录：</h2><blockquote><p>聂志明：大家好！我们现在开始演讲，我先自我介绍，我是腾讯游戏研发部助理总经理。我今天的题目是“游戏后台开发中的九个选择”，为什么用这个题目？在生活中我们<br>有很多选择，对这些选择的不同处理方式会决定不同的品质，我们在游戏开发里面会遇到很多选择，我今天说九个，但不一定每个人都碰得到，我在这里会把一些经验给大家分享<br>一下。</p></blockquote><blockquote></blockquote><blockquote><p>首先介绍一下在腾讯开发跟别的公司会有不同，在我内部遵从两个岗位，每个公司里面是按照不同模块来分。为什么会这样分？前台是通过便，后台讲究的是不便，我们不是<br>追求新的技术，而是解决问题。</p></blockquote><blockquote></blockquote><blockquote><p>下面我开始演讲，这是北京最盛名的一座桥，每次都不知道怎么走，越来越复杂。我们每天都会遇到很多选择，所以导致人也不是很愉快。</p></blockquote><blockquote></blockquote><blockquote><p>我现在来讲九个选择，从Q1到Q9，后面一一按照这个顺序做个阐述。</p></blockquote><hr><h3 id="第一，选择什么样的架构？"><a href="#第一，选择什么样的架构？" class="headerlink" title="第一，选择什么样的架构？"></a>第一，选择什么样的架构？</h3><blockquote><p>其实是SNS特点决定的，不同的特点决定不同的架构。玩发围绕的是玩家之间偏真实的关系链，位置对玩家是不重要的，玩家之间没有物理上的距离概念，SNSGame<br>是大世界的模式，通用大世界方案的系统必须平行发展。MMO的特点，前几年是一个发展重点，很多人了解也不是很多，它的特点是存在世界地图，位置很重要，有地形概念，<br>每个玩家都有自己的物理坐标。交互频繁，逻辑复杂，交互的实时性要求高，严重依赖于预先设计的游戏内容。小世界有小世界的好处。第一易于就近部署及，减轻国内网络复杂<br>与MMO对网络要求高的矛盾。大家知道网络有很多问题，大家知道问题也解决不了。对MMO来讲，是一个很高的类型，所以会用小世界。</p></blockquote><blockquote></blockquote><blockquote><p>通过分区服务，降低了因为架构导致的运营问题的严重性，小世界的内部在架构上也需要有一定的可伸缩性，这取决于游戏的设计。并不是所有的小世界只有一台服务器搞定<br>，因为它的元素、它的特点对它也会有不同的要求。</p></blockquote><blockquote></blockquote><blockquote><p>在我选择这种架构的时候，我们会有原则，选择什么样的架构取决于游戏自身的设计，这取决于某些特点，并不是所有服务都有同样的需求，并不是大世界就好，小世界就不<br>行。我们不从纯技术角度追求大世界的架构，大世界需要游戏内容的支持，通常美术策划无法支撑百万在线的世界，这是最根本的原因。大世界在架构上有困难，但这是部分不可<br>克服的。</p></blockquote><blockquote></blockquote><blockquote><p>我讲大家非常熟悉的一个例子，通常最复杂的大区概念，大区通常是做帐号，服务器在服务器里面按角色区分。线，就是有的游戏有，有的游戏没有，在这些线里面只是为了<br>扩展这个世界的流量上线，线目前来说只是一个方便，这是一个样对复杂的示意部署视图（PPT）。</p></blockquote><blockquote></blockquote><blockquote><p>我们看一个架构，如果展开来讲，左边是一些辅助服务，右边的Worldsvr像公会的那种会放在这个里面，加在服务器上面，不同的游戏会有不同的处理。这是一个简<br>单的示意图，在不同的游戏里面会有不同的区分。</p></blockquote><hr><h3 id="第二，选择单线程还是多线程？"><a href="#第二，选择单线程还是多线程？" class="headerlink" title="第二，选择单线程还是多线程？"></a>第二，选择单线程还是多线程？</h3><blockquote><p>不同的公司会有不同的做法，这个问题并不是所有人都碰到，也有个概率，但是大家也会有争论。争论的原因，通常是双方关注的重点不同，单线程程序的执行只有一条主线<br>，容易跟踪、调试和定位。我们腾讯也不是一定说要这样选择，我们理由非常理由，单线程加异步模式可以提供更好的性能，我们会选择单线程模式。现在我们游戏开发周期很长<br>，在漫长的运行周期里面每周都会更新，交接过程中会有问题的，使用多线程容易导致问题。这个时候我们会进行一些处理，我们对里面的要求角度来看，运行的周期很长、节奏<br>很快，为了达到要求我们可以想更简便的方式。</p></blockquote><blockquote></blockquote><blockquote><p>新形势，对我们也是有一些影响，现在有一些四核以上的CPU出现，这个时候我们会尝试把一些通用的服务，把相对固定的进程变成简单化，这是一个新趋势。</p></blockquote><blockquote></blockquote><blockquote><p>这是适应新趋势的原则，只在必须的时候才使用多多线程，如果使用了多线程，尽量减少线程间的交互需求，这样我们就好把握。</p></blockquote><hr><h3 id="第三，如何在游戏中使用脚本？"><a href="#第三，如何在游戏中使用脚本？" class="headerlink" title="第三，如何在游戏中使用脚本？"></a>第三，如何在游戏中使用脚本？</h3><blockquote><p>在游戏开发中通常大家都会使用一些脚本。客户端对脚本的需求非常明显，这里主要讨论服务器端。两种使用脚本的方式：一种是C/C++的框架，主要逻辑用C/++编<br>写，脚本用来做一些局部扩展。C/C++的框架，主要逻辑用脚本来编写，耗性能的地方用C/C++决定的。</p></blockquote><blockquote></blockquote><blockquote><p>使用脚本的原则，脚本是一种胶水语言，通常用来隔离变化，易变化的逻辑用脚本实现，快速响应。一般情况下是说这个性能高，那个性能低，上面两种方法没有对错之分，<br>取决于两点，开发团队成员的能力，对不同语言的掌握程度；公司或者项目组的导向，偏重性能还是偏重开发速度，如果是创业型的团队，对性能方面要求多一些，怎么样把游戏<br>做好才是最重要的。</p></blockquote><hr><h3 id="第四，如何处理网络通讯？"><a href="#第四，如何处理网络通讯？" class="headerlink" title="第四，如何处理网络通讯？"></a>第四，如何处理网络通讯？</h3><blockquote><p>其实网络通信本身是非常复杂的事情，目前的开发环境已经提供了相对来讲简单得多的编程接口，但是网络程序还是需要处理很多的问题。</p></blockquote><blockquote></blockquote><blockquote><p>两种处理方式：一种是跟游戏服务器耦合带一起，游戏服务器既处理问落接入相关的逻辑，也处理游戏逻辑。一种是把网络通信部分剥离住来，向游戏服务器提供一种以消息<br>为单位的、非阻塞的、有Qos能力的中间服务，游戏服务器看不到网络的细节。</p></blockquote><blockquote></blockquote><blockquote><p>我们选择第二种好处，是基于这样的考虑，首先简化了游戏服务器的处理逻辑，降低了编程的难度。更易于提升后台整体的处理性能，不同部分可以独立的优化，因为它可以<br>不断的优化和在不同项目里面去继承的。</p></blockquote><blockquote></blockquote><blockquote><p>这是非常简单的一张示意图，我们会有一个界面，在客户端和服务器端给它不同的接口，会有不同的形式，看不到网络的问题，而且都是非阻塞的形式，面向消息的服务，类<br>似于有保障的、可持续的服务。</p></blockquote><hr><h3 id="第五，如何处理游戏通信协议？"><a href="#第五，如何处理游戏通信协议？" class="headerlink" title="第五，如何处理游戏通信协议？"></a>第五，如何处理游戏通信协议？</h3><blockquote><p>协议分两大类：文本协议和二进制协议，这是两个非常典型的例子，左边是UDP，非常高兴。右边是文本的协议，都是文字。文本协议直观，版本兼容性好，但是效率低。<br>其实对于游戏来讲，我们最好能够做到不同的版本都可以玩，不强调所有的客户端都去升级，这对运营商有非常强的周期，这对运营商来说有很大的挑战。版本兼容性问题其实是<br>我们在通信协议的时候，都需要重点考虑的。二进制协议效率高，但是不直观，版本兼容性处理相对复杂。</p></blockquote><blockquote></blockquote><blockquote><p>Web相关的游戏根据与浏览器交互的方式可能采用文本协议，基于效率原因，C/S类型的游戏通常采用二进制协议。</p></blockquote><blockquote></blockquote><blockquote><p>下面我会介绍腾讯的经验，游戏服务器是时钟消息和网络消息驱动的，大部分代码都是接受消息，或者接纳，其实有很多的解码、编码、代码占了相当大的比例。我们可以把<br>协议做一个区分，就变成一个消息的协议描述，然后生成工具，然后得到网络协议处理代码。</p></blockquote><blockquote></blockquote><blockquote><p>这是我们的做法，我们自己定义了一套协议描述方法，并实现了相应了工具集。我们这个协议重点会有所不同，在于高性能、与C/C++的无缝结合以及多协议版本共存能<br>力。利用我们这个版本来描述协议，不断在上面添加新的内容，但是其实可以进入到所有的低版本的客户端协议，不需要开发者做任何处理，它会自动生成。类似的方式大家可以<br>看Google protobuf orFacebook thrift。</p></blockquote><hr><h3 id="第六，如何设计存储结构。"><a href="#第六，如何设计存储结构。" class="headerlink" title="第六，如何设计存储结构。"></a>第六，如何设计存储结构。</h3><blockquote><p>从游戏来讲，所有的在线游戏通常使用数据库来存储用户数据。通常MMO使用关系型数据库来存储数据，后面主要针对MMO进行存储方式的讨论。会有两种方式：一种是<br>把游戏的每一个数据对象的属性看成一个单独字段，遵循RDBMS的要求来设计数据库表和索引，尽量符合3NF。以MMO为例，有帐号表、角色基本信息表、物品表、装备<br>表等等，这是一种方式。</p></blockquote><blockquote></blockquote><blockquote><p>还有一种方式更具体，角色的列表类数据尽量采用blob来存储而不是另一个表。原则是这些列表数据只被角色自身所拥有，就是这个玩家所拥有，其他玩家不会拥有个数<br>据，它的生命周期跟玩家是一致的，不存在其他的交叉拥有情况，技能、物品、装备、任务、好友等等都属于这种情况。</p></blockquote><blockquote></blockquote><blockquote><p>优点是存储表结构简单，通常几张表就可以玩一个游戏，不超过10个。存取交互简单，角色登录或者推出时通常只需要存取一到二条记录。同一个角色的数据易于保持一致<br>，易于多版本数据共存。我们把这些数据存到数据库的时候，会把编码存到数据库里面。所以在数据库里面做完的数据可能会不一样，不过不会影响，它会共存。</p></blockquote><blockquote></blockquote><blockquote><p>这种方式也会有缺点，数据维护工具、客服工具实现相对复杂，需要提供特殊的API来操作数据。如果手上工具是通用的，可能比以前要直白一点。某些类型的统计相对要<br>麻烦一些，有些常用的数据，比如说角色的等级，在这方面可以用一些方式解决你的问题。</p></blockquote><blockquote></blockquote><blockquote></blockquote><p>举个例子，在MMOG这块，存储角色的概要信息，包括名字、基本属性等，用于显示角色列表和防止重名。还有存储角色的详细信息，存储帐号的仓库信息，存储公会的信息。</p><blockquote></blockquote><blockquote><p>新趋势的影响，就是Nosql数据库，性能高，存在好的开源实现，游戏的数据访问多为唯一键访问，很少复杂的Query，符合Nosql数据库的特点。后面在游戏<br>应用上，可能也会涉及到。</p></blockquote><hr><h3 id="第七，如何设计网络同步？"><a href="#第七，如何设计网络同步？" class="headerlink" title="第七，如何设计网络同步？"></a>第七，如何设计网络同步？</h3><blockquote><p>网络同步面临的主要问题：第一如何减少网络波动对同步的影响；第二如何减少外挂对同步的破坏。如果没有外挂，网络几大问题没有服务器去运行。这两个问题单独都好解<br>决，但是在一起比较难解决。我们解决这两个问题，会遵循几个原则：第一网络条件好的玩家获得好的体验；第二网络条件差的玩家尽可能获得好一些的体验，但不能拖累其他玩<br>家的体验；第三外挂不能在网络同步方面获得持续的好处。对外挂方面，玩一个游戏是一个人，或者说非人类不清楚，所以说外挂不能在网络同步获得持续的好处。</p></blockquote><blockquote></blockquote><blockquote><p>为了解决问题我们有一些基本方法：首先要探测玩家的网络质量；第二在玩家机器与服务器之间进行时钟同步；第三基于游戏特点，设计合理的同步机制。像竞技类的游戏，<br>都是根据它的某些特点决定的，这是需要我们权衡考虑的。这里强调一点，在外挂获得好处，跟玩家体验时间做一个折中，你要保证外挂持续得到源源不断的好处，这样外挂就会<br>上去。对于探测、时钟同步都需要控制好。</p></blockquote><hr><h3 id="第八，如何定义性能基准？"><a href="#第八，如何定义性能基准？" class="headerlink" title="第八，如何定义性能基准？"></a>第八，如何定义性能基准？</h3><blockquote><p>做游戏开发通常不太注重事先对于性能的规划，多以结果作为目标，基本上是看后来测试出来的性能，能优化则优化。性能基准包括客户端和服务器，客户端的性能基准与游<br>戏的目标市场有关。在服务器当中我们可以分析出来服务器能支撑多少用户？我们分解一下，制约性能的因素，网络IO/磁盘IO/内存/CPU。</p></blockquote><blockquote></blockquote><blockquote><p>具体的方法，可以通过经验的方式，或者计算的方式来确确定理论上限。网络IO，可以分析，取悦于由游戏类型、游戏设计所形成的业务模型，可估算。内存，相对来讲更<br>简单，取决于用到的主要数据结构，相对来讲更聚焦，更能估算出来支撑多少人。CPU计算能力，其实也不是计算，需要更多对CPU的支撑，简单的方式，这个游戏取决于游<br>戏类型导致的逻辑复杂性。推过这三点，可以有一个目标，大概需要多少人。</p></blockquote><blockquote></blockquote><blockquote><p>我们的数据，以实时列MMOG来讲，单一物理服务器1CPU，2核心，支撑3000-4000在线。平均每用户流量12-20Kbps。</p></blockquote><hr><h3 id="第九，如何在不同项目间进行代码复用？"><a href="#第九，如何在不同项目间进行代码复用？" class="headerlink" title="第九，如何在不同项目间进行代码复用？"></a>第九，如何在不同项目间进行代码复用？</h3><blockquote><p>当一个公司内在不止一个项目在开发、运营时，复用的想法的产生是自然而然的。简单的把上一个心目的可用代码拷贝过来自行维护是最简单的方式，但是会导致同一个功能<br>有N种实现变体，每个变体都解决一部分问题。把共用的代码收归一个杜立德组织来开发和维护，形成公共组件，能够解决上述的问题，但是又会带来新的问题。要解决这些问题<br>，也很难有一些具体的方法，有几个原则，以服务、进程、库来提供。提供充分的工具，满足调试、验证、部署、运营等需求，如果推广好对你有很大的关系。最后还有充分的提<br>供扩展能力，可以降低组件开发的压力。</p></blockquote><p>我这边就讲到这里，九个问题，并不一定所有问题都会碰到，但希望这些问题对大家有所帮助。谢谢！</p>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>游戏开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 怎样实现非阻塞connect</title>
    <link href="/posts/64027.html"/>
    <url>/posts/64027.html</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>凡是接触过socket编程的，对connect函数一定不陌生。因为socket是面向连接的，所以在进行读写操作前我们首先要进行连接，而所谓连接也就是我们<br>常说的三次握手，这个过程就是在connect函数中完成的。<br>虽然connect函数本身不具备阻塞的功能，但是我们可以通过对socket进行设置和使用select函数可以设置阻塞时间的特性实现非阻塞。</p></blockquote><h3 id="为什么要非阻塞"><a href="#为什么要非阻塞" class="headerlink" title="为什么要非阻塞"></a>为什么要非阻塞</h3><blockquote><p>第一，我们可以在connect时去做些别的事，毕竟三次握手需要在网络中往返多层次，我们没有必要一直在那里闲着。<br>第二，这一点很重要，因为connect的超时时间在75秒到几分钟之间，显然不可能去让程序阻塞那么久。</p></blockquote><h3 id="怎样实现非阻塞"><a href="#怎样实现非阻塞" class="headerlink" title="怎样实现非阻塞"></a>怎样实现非阻塞</h3><h4 id="1-设置socket"><a href="#1-设置socket" class="headerlink" title="1. 设置socket"></a>1. 设置socket</h4><pre><code class="hljs">int oldOption = fcntl(sockfd, F_GETFL);int newOption = oldOption | O_NONBLOCK;//设置sockfd非阻塞fcntl(sockfd, F_SETFL, newOption);</code></pre><h4 id="2-执行connect"><a href="#2-执行connect" class="headerlink" title="2. 执行connect"></a>2. 执行connect</h4><pre><code class="hljs">如果返回0，表示连接成功，这种情况一般在本机上连接时会出现(否则怎么可能那么快)否则，查看error是否等于EINPROGRESS(表明正在进行连接中)，如果不等于，则连接失败int ret = connect(sockfd, (struct sockaddr*)&amp;addr, sizeof(addr));if(ret == 0)&#123;    //连接成功    fcntl(sockfd, F_SETFL, oldOption);    return sockfd;&#125;else if(errno != EINPROGRESS)&#123;    //连接没有立即返回，此时errno若不是EINPROGRESS，表明错误    perror(&quot;connect error != EINPROGRESS&quot;);    return -1;&#125;</code></pre><h4 id="3-使用select，如果没用过select可以去看看"><a href="#3-使用select，如果没用过select可以去看看" class="headerlink" title="3. 使用select，如果没用过select可以去看看"></a>3. 使用select，如果没用过select可以去看看</h4><pre><code class="hljs">用select对socket的读写进行监听那么监听结果有四种可能1. 可写(当连接成功后，sockfd就会处于可写状态，此时表示连接成功)2. 可读可写(在出错后，sockfd会处于可读可写状态，但有一种特殊情况见第三条)3. 可读可写(我们可以想象，在我们connect执行完到select开始监听的这段时间内，    如果连接已经成功，并且服务端发送了数据，那么此时sockfd就是可读可写的，    因此我们需要对这种情况特殊判断)    说白了，在可读可写时，我们需要甄别此时是否已经连接成功，我们采用这种方案：    再次执行connect，然后查看error是否等于EISCONN(表示已经连接到该套接字)。4. 错误if(FD_ISSET(sockfd, &amp;writeFds))&#123;    //可读可写有两种可能，一是连接错误，二是在连接后服务端已有数据传来    if(FD_ISSET(sockfd, &amp;readFds))    &#123;        if(connect(sockfd, (struct sockaddr*)&amp;addr, sizeof(addr)) != 0)        &#123;            int error=0;            socklen_t length = sizeof(errno);            //调用getsockopt来获取并清除sockfd上的错误.            if(getsockopt(sockfd, SOL_SOCKET, SO_ERROR, &amp;error, &amp;length) &lt; 0)            &#123;                printf(&quot;get socket option failed\n&quot;);                close(sockfd);                return -1;            &#125;            if(error != EISCONN)            &#123;                perror(&quot;connect error != EISCONN&quot;);                close(sockfd);                return -1;            &#125;        &#125;    &#125;    //此时已排除所有错误可能，表明连接成功    fcntl(sockfd, F_SETFL, oldOption);    return sockfd;&#125;</code></pre><h4 id="4-恢复socket"><a href="#4-恢复socket" class="headerlink" title="4. 恢复socket"></a>4. 恢复socket</h4><pre><code class="hljs">因为我们只是需要将连接操作变为非阻塞，并不包括读写等，所以我们吃醋要将socket重新设置。fcntl(sockfd, F_SETFL, oldOption);</code></pre><h4 id="End"><a href="#End" class="headerlink" title="End"></a>End</h4><p>到此，我们的非阻塞connect函数已经成功了。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="hljs">#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include &lt;sys/socket.h&gt;#include &lt;sys/types.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;unistd.h&gt;#include &lt;string&gt;#include &lt;errno.h&gt;//blokTimeMs表明非阻塞时的毫秒数，若值为-1表明阻塞int connect(std::string ip, int port, int blockTimeMs = -1)&#123;    struct sockaddr_in addr;    bzero(&amp;addr, sizeof(addr));    addr.sin_family = AF_INET;    addr.sin_port = htons(port);    inet_pton(AF_INET, ip.c_str(), &amp;addr.sin_addr);    int sockfd = socket(PF_INET, SOCK_STREAM, 0);    //阻塞    if(blockTimeMs == -1)    &#123;        int ret = connect(sockfd, (struct sockaddr*)&amp;addr, sizeof(addr));        if(ret &lt; 0)        &#123;            perror(&quot;connectBloking&quot;);            close(sockfd);            return -1;        &#125;        close(sockfd);        return 1;    &#125;    //非阻塞    int oldOption = fcntl(sockfd, F_GETFL);    int newOption = oldOption | O_NONBLOCK;    //设置sockfd非阻塞    fcntl(sockfd, F_SETFL, newOption);    int ret = connect(sockfd, (struct sockaddr*)&amp;addr, sizeof(addr));    if(ret == 0)    &#123;        //连接成功        fcntl(sockfd, F_SETFL, oldOption);        return sockfd;    &#125;    else if(errno != EINPROGRESS)    &#123;        //连接没有立即返回，此时errno若不是EINPROGRESS，表明错误        perror(&quot;connect error != EINPROGRESS&quot;);        return -1;    &#125;    fd_set readFds;    fd_set writeFds;    struct timeval timeout;    FD_ZERO(&amp;readFds);    FD_ZERO(&amp;writeFds);    FD_SET(sockfd, &amp;writeFds);    FD_SET(sockfd, &amp;readFds);    timeout.tv_sec = blockTimeMs/1000;    timeout.tv_usec = (blockTimeMs%1000)*1000;    ret = select(sockfd+1, &amp;readFds, &amp;writeFds, NULL, &amp;timeout);    if(ret &lt;= 0)    &#123;        perror(&quot;select timeout or error&quot;);        close(sockfd);        return -1;    &#125;    if(FD_ISSET(sockfd, &amp;writeFds))    &#123;        //可读可写有两种可能，一是连接错误，二是在连接后服务端已有数据传来        if(FD_ISSET(sockfd, &amp;readFds))        &#123;            if(connect(sockfd, (struct sockaddr*)&amp;addr, sizeof(addr)) != 0)            &#123;                int error=0;                socklen_t length = sizeof(errno);                //调用getsockopt来获取并清除sockfd上的错误.                if(getsockopt(sockfd, SOL_SOCKET, SO_ERROR, &amp;error, &amp;length) &lt; 0)                &#123;                    printf(&quot;get socket option failed\n&quot;);                    close(sockfd);                    return -1;                &#125;                if(error != EISCONN)                &#123;                    perror(&quot;connect error != EISCONN&quot;);                    close(sockfd);                    return -1;                &#125;            &#125;        &#125;        //此时已排除所有错误可能，表明连接成功        fcntl(sockfd, F_SETFL, oldOption);        return sockfd;    &#125;    else    &#123;        perror(&quot;connect failed&quot;);        close(sockfd);        return -1;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>服务器开发</tag>
      
      <tag>Linux网络编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自制Lex-词法分析器生成器(C++)</title>
    <link href="/posts/63134.html"/>
    <url>/posts/63134.html</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>前一阵子，编译原理课实验内容是要去做一个词法分析器，实现后，觉得没有把 ** 正规表达式和NFA、DFA **<br>这些知识用上，所以就产生了想自己去实现一个lex的想法，于是就有了这篇博文。<br>如果还不知道词法分析器该怎么实现，可以去看 [ c语言词法分析初试(C++实现) ](c%E8%AF%AD%E8%A8%80%E8%AF%8D%E6%B3%<br>95%E5%88%86%E6%9E%90%E5%88%9D%E8%AF%95%28C++%E5%AE%9E%E7%8E%B0%29) 。</p></blockquote><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><img src="http://img.blog.csdn.net/20161030213725180" alt="这里写图片描述"><br>上图是维基百科对lex的定义。<br>从中可以明确lex的功能： ** 读进一个代表词法分析器规则的输入字符串流，然后输出以C语言实做的词法分析器源代码 ** 。<br>本质上，本人是在对原lex进行模仿，但使用规则细节什么的与其并不一致，比如原lex用正则表达式来表示词法分析器规则，而本人的自制lex使用的是正规表达式，所<br>以接下来关于原lex的内容不再赘述。</p><h2 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h2><p><img src="http://img.blog.csdn.net/20161030214356200" alt="这里写图片描述"></p><h3 id="1-解析lex文本"><a href="#1-解析lex文本" class="headerlink" title="1.解析lex文本"></a>1.解析lex文本</h3><h4 id="1-1文本规则"><a href="#1-1文本规则" class="headerlink" title="1.1文本规则"></a>1.1文本规则</h4><pre><code class="hljs">%&#123;    c代码区块%&#125;%!    定义区块%!%%    规则1 方法体%$    规则2 方法体%$    ...%%</code></pre><blockquote><p>由上可以看到，整个lex文本分为三个区块。</p></blockquote><h5 id="c代码区"><a href="#c代码区" class="headerlink" title="c代码区"></a>c代码区</h5><blockquote><p>用%{ %}包围，里面内容是c代码，这些代码会原样复制进程序生成的词法分析器源代码中，也就是说，我们可以在这个区块里预定义一些c函数、变量等等。</p></blockquote><h5 id="定义区"><a href="#定义区" class="headerlink" title="定义区"></a>定义区</h5><p>用%! %!包围，里面内容是一些定义，格式为 a = b。</p><blockquote><p>a表示我们定义一种输入字符，比如所有的字母、数字，或是a-v，3-7等等区间，或是除了字母以外的任何字符。我们可以给这些值的集合起一个名字为a。<br>b表示一个函数名，该函数接受一个char字符，返回1或者0，表示输入是否匹配。该函数必须自己在c代码区进行实现。<br>例如：我们定义 digit = isDigit<br>digit表示所有的数字，则我们需要实现这样一个函数：</p></blockquote><pre><code class="hljs">int isDigit(char ch)&#123;    if(ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;)        return 1;    return 0;&#125;</code></pre><blockquote><p>完成上述之后，我们就可以在规则区里以{a}的形式在正规表达式中使用该自定义输入。</p></blockquote><h5 id="规则区"><a href="#规则区" class="headerlink" title="规则区"></a>规则区</h5><blockquote><p>这里可以说是整个lex文件最核心的部分了。<br>我们需要在这里对所有的词法规则用正规表达式进行描述。<br>还是举个例子，我们要将c语言的标识符的规则进行描述：</p></blockquote><pre><code class="hljs">正规表达式  方法体(&#123;letter&#125;|_)(&#123;letter&#125;|_|digit)* &#123;printf(&quot;&lt;$ID, %s&gt;&quot;, LEX_TEXT);&#125;</code></pre><blockquote><p>letter表示所有字母，digit表示所有数字，这两者都属于是我们在定义区所自定义的输入类型。<br>那么上面正规表达式代表的含义就是 ** 所有以字母或者下划线开头并后续字母是字母数字或者下划线的字符串 ** ，即是我们认为合法的标识符。<br>后面{}包含的内容是我们的方法体，即定义我们生成的词法分析器当识别出符合正规式定义的字符串后需要进行的操作，该操作用c语言来进行描述。<br>LEX_TEXT为我们预设定的保存识别出的串的char数组。<br>那么上面的规则所定义的就是 ** 对标识符进行匹配，并在匹配成功之后将其进行输出 ** 。</p></blockquote><h4 id="1-2文本识别细节"><a href="#1-2文本识别细节" class="headerlink" title="1.2文本识别细节"></a>1.2文本识别细节</h4><blockquote><p>这部分做的比较粗略。<br>1.上述三个区域的界符即%{，%!等必须出现在每行的行首，否则会被忽略。<br>2.所有出现在三个区域外的文本内容全部忽略<br>3.当出现文本忽略时会报出警告(文本内容及行号)<br>4.当出现文本识别错误时会进行报错(文本内容及行号)并程序终止。<br>5.因为正规式里面原本就有(,),|,*等符号，再加上{}用于标识自定义输入的符号以及空格，这些字符均需要进行转义，我定义的转义标志是%，与c语言的\没有什<br>么区别。用%$表示正规表达式里的空。</p></blockquote><h3 id="根据lex文本内容生成NFA等"><a href="#根据lex文本内容生成NFA等" class="headerlink" title="根据lex文本内容生成NFA等"></a>根据lex文本内容生成NFA等</h3><p>这部分我用了一个栈来实现，具体细节可参看之前写的一篇博客 <a href="http://blog.csdn.net/to_be_better/article/details/52721920"> 正规表达式转NFA(C++)</a><br>，细节有所差异，但是实现思想是一致的，这里就不再重复描述了。<br>除了要生成NFA，还要完成两件事。<br>1. 保存定义区里 自定义输入与对应判断函数名的映射。<br>2. 保存NFA的终点状态的序号集合，并保存其各自对应的方法体的映射。</p><h3 id="根据NFA生成DFA"><a href="#根据NFA生成DFA" class="headerlink" title="根据NFA生成DFA"></a>根据NFA生成DFA</h3><blockquote><p>这里使用的方法是子集法：<br>每个状态表示为一个数字，这一点在上面已经提过，那么我们用一个vector表示一个状态集合。<br>再使用一个set和一个queue，set用于对vector进行查重，queue用于遍历，从起始状态的集合开始，将其经每个输入到达的状态加入queue，当然，<br>前提是该状态集合没有在set中出现过。<br>这里有个重点是关于空的处理，见代码。</p></blockquote><pre><code class="hljs">//i为当前状态，input为输入，state为存放可到达的状态的集合void Lex::findBeGo(int i, string input, vector&lt;int&gt;* state)&#123;    for(auto x : nfaVet[i])    &#123;        int sId = x.toId;        bool flag = true;        for(auto iter=state-&gt;begin(); iter!=state-&gt;end(); iter++)            if((*iter) == sId)            &#123;                flag = false;                break;            &#125;        if(flag &amp;&amp; input.compare(x.input) == 0)        &#123;            state-&gt;push_back(sId);            findBeGo(sId, &quot;&quot;, state);        &#125;    &#125;&#125;</code></pre><blockquote><p>当然，这里也需要保存DFA的终点状态的序号，并保存其各自对应的方法体的映射。</p></blockquote><h3 id="将DFA转换为C代码"><a href="#将DFA转换为C代码" class="headerlink" title="将DFA转换为C代码"></a>将DFA转换为C代码</h3><blockquote><p>如果用自动机的模式写过一次词法分析器，就很明了，DFA只跟自动机的状态里面内容相关。<br>即：switch(状态){//} ；里面的内容是需要根据DFA动态生成的，其他的都不需要改变。<br>所以我们一开始就将switch部分上下的代码都确定，然后根据DFA来生成。<br>对每一个case来说，我们需要输出的内容只有以下几点：<br>1. 状态id<br>2. 状态接受的输入，以及该输入转向的状态id<br>3. 枚举完所有可接受的输入后，如果当前字符与以上输入都不符合，那么根据该状态是否是终止状态来确定是结束并执行方法体还是报错。 例子如下：</p></blockquote><pre><code class="hljs">case ID:        &#123;            ch = *str++;            SYLEX_TEXT[SYLEX_TEXT_LEN++]=ch;            if(ch == 输入1)&#123;                SYLEX_STATE = 转向的状态;            &#125;            else            if(ch == 输入2)&#123;                SYLEX_STATE = 转向的状态;            &#125;            else            &#123;                //根据id是否可终止，来决定是报错还是执行方法体            &#125;</code></pre><blockquote><p>这里还有个细节，关于我们的自定义输入，因为普通输入字符我们直接是用if(ch == ‘X’)来判断。而自定义输入，我们是通过if(函数名(ch))来判断<br>，所以在输出源代码时，需要先对其输入进行判断是否是自定义输入，这里我们用第一步时建立的映射直接就可以解决。</p></blockquote><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>全部流程都封装在了Lex类中，因为篇幅问题，就只贴类的成员变量和成员函数声明部分的代码。<br>有兴趣的朋友，可以去github上看完整代码，链接如下。<br><a href="https://github.com/shiyi1996/project/tree/master/Lex"> shiyi1996/project/tree/master/Lex</a></p><pre><code class="hljs">////  Lex.hpp//  Lex////  Created by shiyi on 2016/10/18.//  Copyright © 2016年 shiyi. All rights reserved.//#ifndef Lex_hpp#define Lex_hpp#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;set&gt;#include &lt;queue&gt;using namespace std;struct Node&#123;    Node(int fromId, string input, int toId)    &#123;        this-&gt;fromId = fromId;        this-&gt;input = input;        this-&gt;toId = toId;    &#125;    int fromId;    string input;    int toId;&#125;;class Lex&#123;public:    static const int MAXID = 100000;    Lex(string _lexFile);    Lex(string _lexFile, string _outCFile);    void init();    //写入scanner函数之前    void outCodeLeft();    //写入scanner函数之后    void outCodeRight();    //写入scanner函数    void outCodeMid();    //解析lex源文件    void scanner();    //错误警告等输出    inline void printError(int line, string str, string mess);    inline void printWaring(int line, string str, string mess);    //解析方法体    void getFunc(string str, int line);    //解析正规式    void getRegular(string str, int line);    //------日后补充    //判断正规式是否合法    bool isExpre(vector&lt;pair&lt;string, bool&gt;&gt;);    //DFA最小化    void getSimpDFA();    // -----------    //添加NFA节点    inline void addNFANode(int fromId, string input, int toId);    //添加DFA节点    inline void addDFANode(int fromId, string input, int toId);    //正规式转NFA    void regrToNFA(vector&lt;pair&lt;string, bool&gt;&gt; regr, int startId, int endId, int &amp;itemId);    //生成NFA    void getNFA();    //生成DFA    void getDFA();    //nfa查询    void findBeGo(int i, string input, vector&lt;int&gt;* state);    //获取nfa目标状态集合    vector&lt;int&gt;* getState(vector&lt;int&gt;* fromState, string input);    //获取终态    void getVt(map&lt;vector&lt;int&gt;, int&gt; stateMap);    //执行操作    void work();    //输出-测试-    inline void print();private:    string lexFile;    string outCFile;    //自定义输入对应方法体    map&lt;string, string&gt; funcMap;    //正规式    vector&lt;vector&lt;pair&lt;string, bool&gt;&gt;&gt; regrVet;    //方法体    vector&lt;string&gt; funcVet;    //NFA    vector&lt;Node&gt; nfaVet[MAXID];    //DFA    vector&lt;Node&gt; dfaVet[MAXID];    //储存所有输入    set&lt;string&gt; inputSet;    //DFAend    int dfaEnd[MAXID];    //NFAend   值为funcVet item的下标    int nfaEnd[MAXID];    int nfaNum;    int dfaNum;&#125;;#endif /* Lex_hpp */</code></pre><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="Lex代码"><a href="#Lex代码" class="headerlink" title="Lex代码"></a>Lex代码</h3><pre><code class="hljs">%&#123;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;const int KEY_NUM = 32;const char* KEY_SET[] = &#123;    &quot;auto&quot;, &quot;break&quot;, &quot;case&quot;, &quot;char&quot;, &quot;const&quot;, &quot;continue&quot;,    &quot;default&quot;, &quot;do&quot;, &quot;double&quot;, &quot;else&quot;, &quot;enum&quot;, &quot;extern&quot;,    &quot;float&quot;, &quot;for&quot;, &quot;goto&quot;, &quot;if&quot;, &quot;int&quot;, &quot;long&quot;, &quot;register&quot;,    &quot;return&quot;, &quot;short&quot;, &quot;signed&quot;, &quot;sizeof&quot;, &quot;static&quot;, &quot;struct&quot;,    &quot;switch&quot;, &quot;typedef&quot;, &quot;union&quot;, &quot;unsigned&quot;, &quot;void&quot;, &quot;volatile&quot;,    &quot;while&quot;&#125;;int isDigit(char ch)&#123;    if(ch &lt;= &#39;9&#39; &amp;&amp; ch &gt;= &#39;0&#39;)        return 1;    return 0;&#125;int isLetter(char ch)&#123;    if((ch &gt;= &#39;a&#39; &amp;&amp; ch &lt;= &#39;z&#39;) || (ch &gt;= &#39;A&#39; &amp;&amp; ch &lt;= &#39;Z&#39;))        return 1;    return 0;&#125;int getKeyId(char *str)&#123;    for(int i=0; i&lt;KEY_NUM; i++)    &#123;        if(strcmp(KEY_SET[i], str) == 0)            return i+1;    &#125;    return 0;&#125;int isNoOne(char ch)&#123;    if(ch != &#39;\&#39;&#39; &amp;&amp; ch != &#39;\0&#39;)        return 1;    return 0;&#125;int isNoTow(char ch)&#123;    if(ch != &#39;\&quot;&#39; &amp;&amp; ch != &#39;\0&#39;)        return 1;    return 0;&#125;%&#125;%!noone=isNoOnenotow=isNoTowletter=isLetterdigit=isDigit%!%%(&#123;letter&#125;|_)(&#123;letter&#125;|_|&#123;digit&#125;)* &#123;    int id = getKeyId(SYLEX_TEXT);    if(id != 0)        printf(&quot;&lt;%s,-&gt;\n&quot;, SYLEX_TEXT);    else    &#123;        printf(&quot;&lt;$ID,%s&gt;\n&quot;, SYLEX_TEXT);    &#125;&#125;%$(+|-|%$)&#123;digit&#125;&#123;digit&#125;*(.&#123;digit&#125;&#123;digit&#125;*|%$)((E|e)&#123;digit&#125;&#123;digit&#125;*|%$) &#123;    printf(&quot;&lt;$NUM,%s&gt;\n&quot;, SYLEX_TEXT);&#125;%$%(|%)|%&#123;|%&#125;|[|]|;|,|. &#123;    printf(&quot;&lt;%s,-&gt;\n&quot;, SYLEX_TEXT);&#125;%$% |&#123;\t&#125;|&#123;\n&#125; &#123;&#125;%$(%*(%=|%$))|(/(=|%$))|(+(+|=|%$))|(-(-|=|%$))|(&lt;(&lt;|=|%$))|(&gt;(&gt;|=|%$))|(=(=|%$))|(&amp;(&amp;|=|%$))|(%|(%||=|%$))|(^(=|%$))|(~(=|%$)) &#123;    printf(&quot;&lt;%s,-&gt;\n&quot;, SYLEX_TEXT);&#125;%$(&#123;\&#39;&#125;&#123;noone&#125;*&#123;\&#39;&#125;)|(&#123;\&quot;&#125;&#123;notow&#125;*&#123;\&quot;&#125;) &#123;    printf(&quot;&lt;$STR,%s&gt;\n&quot;, SYLEX_TEXT);&#125;%$#include(% )*((&lt;(&#123;letter&#125;|_)(&#123;letter&#125;|_|&#123;digit&#125;)*.h&gt;)|(&quot;(&#123;letter&#125;|_)(&#123;letter&#125;|_|&#123;digit&#125;)*.h&quot;)) &#123;    printf(&quot;%s 应该预处理的，暂时先忽略&quot;, SYLEX_TEXT);&#125;%%</code></pre><h3 id="生成的词法分析器C代码"><a href="#生成的词法分析器C代码" class="headerlink" title="生成的词法分析器C代码"></a>生成的词法分析器C代码</h3><pre><code class="hljs">//%&#123; start#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;const int KEY_NUM = 32;const char* KEY_SET[] = &#123;    &quot;auto&quot;, &quot;break&quot;, &quot;case&quot;, &quot;char&quot;, &quot;const&quot;, &quot;continue&quot;,    &quot;default&quot;, &quot;do&quot;, &quot;double&quot;, &quot;else&quot;, &quot;enum&quot;, &quot;extern&quot;,    &quot;float&quot;, &quot;for&quot;, &quot;goto&quot;, &quot;if&quot;, &quot;int&quot;, &quot;long&quot;, &quot;register&quot;,    &quot;return&quot;, &quot;short&quot;, &quot;signed&quot;, &quot;sizeof&quot;, &quot;static&quot;, &quot;struct&quot;,    &quot;switch&quot;, &quot;typedef&quot;, &quot;union&quot;, &quot;unsigned&quot;, &quot;void&quot;, &quot;volatile&quot;,    &quot;while&quot;&#125;;int isDigit(char ch)&#123;    if(ch &lt;= &#39;9&#39; &amp;&amp; ch &gt;= &#39;0&#39;)        return 1;    return 0;&#125;int isLetter(char ch)&#123;    if((ch &gt;= &#39;a&#39; &amp;&amp; ch &lt;= &#39;z&#39;) || (ch &gt;= &#39;A&#39; &amp;&amp; ch &lt;= &#39;Z&#39;))        return 1;    return 0;&#125;int getKeyId(char *str)&#123;    for(int i=0; i&lt;KEY_NUM; i++)    &#123;        if(strcmp(KEY_SET[i], str) == 0)            return i+1;    &#125;    return 0;&#125;int isNoOne(char ch)&#123;    if(ch != &#39;\&#39;&#39; &amp;&amp; ch != &#39;\0&#39;)        return 1;    return 0;&#125;int isNoTow(char ch)&#123;    if(ch != &#39;\&quot;&#39; &amp;&amp; ch != &#39;\0&#39;)        return 1;    return 0;&#125;//%&#125; end//%! start//%! end//%% start//%% end#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#define SYLEX_MAXSIZE_TEXT 120#define SYLEX_MAXSIZE_BUFF 1024char SYLEX_FILE_NAME[100];char SYLEX_OUT_FILE_NAME[100];int SYLEX_LINE = 0;int SYLEX_STATE = 0;int SYLEX_TEXT_LEN = 0;char SYLEX_TEXT[SYLEX_MAXSIZE_TEXT];char SYLEX_BUFF[SYLEX_MAXSIZE_BUFF];//扫描函数void SYLEX_scanner(char *str)&#123;    char ch = &#39; &#39;;    while(ch != &#39;\0&#39;)    &#123;        //printf(&quot;%c %d\n&quot;, ch, SYLEX_STATE);        switch(SYLEX_STATE) &#123;        case 0:        &#123;            ch = *str++;            SYLEX_TEXT[SYLEX_TEXT_LEN++]=ch;            if(ch == &#39; &#39;)&#123;                SYLEX_STATE = 1;            &#125;            else            if(ch == &#39;#&#39;)&#123;                SYLEX_STATE = 2;            &#125;            else            if(ch == &#39;&amp;&#39;)&#123;                SYLEX_STATE = 3;            &#125;            else            if(ch == &#39;(&#39;)&#123;                SYLEX_STATE = 4;            &#125;            else            //。。。            else            if(ch == &#39;&#125;&#39;)&#123;                SYLEX_STATE = 28;            &#125;            else            if(ch == &#39;~&#39;)&#123;                SYLEX_STATE = 29;            &#125;            else            &#123;printf(&quot;Error in line %d\n&quot;, SYLEX_LINE);exit(1);            &#125;            break;        &#125;        case 1:        &#123;            ch = *str++;            SYLEX_TEXT[SYLEX_TEXT_LEN++]=ch;            &#123;SYLEX_TEXT[SYLEX_TEXT_LEN-1] = &#39;\0&#39;;SYLEX_TEXT_LEN=0;SYLEX_STATE=0;str--;//**************s&#123;&#125;//**************e            &#125;            break;        &#125;      //考虑篇幅，省略中间的状态        case 81:        &#123;            ch = *str++;            SYLEX_TEXT[SYLEX_TEXT_LEN++]=ch;            &#123;SYLEX_TEXT[SYLEX_TEXT_LEN-1] = &#39;\0&#39;;SYLEX_TEXT_LEN=0;SYLEX_STATE=0;str--;//**************s&#123;   printf(&quot;%s 应该预处理的，暂时先忽略&quot;, SYLEX_TEXT);&#125;//**************e            &#125;            break;        &#125;        &#125;    &#125;&#125;int main(int argc, char **args)&#123;    if(argc == 1)    &#123;        printf(&quot;没有输入源文件名&quot;);        return 0;    &#125;    else if(argc == 2)    &#123;        strcpy(SYLEX_FILE_NAME, args[1]);        sprintf(SYLEX_OUT_FILE_NAME, &quot;%s.out&quot;, SYLEX_FILE_NAME);    &#125;    else    &#123;        strcpy(SYLEX_FILE_NAME, args[1]);        strcpy(SYLEX_OUT_FILE_NAME, args[2]);    &#125;    FILE* file = fopen(SYLEX_FILE_NAME, &quot;r&quot;);    while(NULL != fgets(SYLEX_BUFF, SYLEX_MAXSIZE_BUFF, file))    &#123;        ++SYLEX_LINE;        SYLEX_scanner(SYLEX_BUFF);    &#125;    return 0;&#125;</code></pre><h3 id="测试C代码"><a href="#测试C代码" class="headerlink" title="测试C代码"></a>测试C代码</h3><pre><code class="hljs">#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include&quot;aaa.h&quot;int main()&#123;    int a = 5;    int b = a + 3.5E3;    char s[] = &quot;I love the world\n&quot;;    for(int i=0; i&lt;5; i++)        printf(&quot;%s\n&quot;,s);&#125;</code></pre><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><pre><code class="hljs">#include &lt;stdio.h&gt; 应该预处理的，暂时先忽略#include &lt;string.h&gt; 应该预处理的，暂时先忽略#include&quot;aaa.h&quot; 应该预处理的，暂时先忽略&lt;int,-&gt;&lt;$ID,main&gt;&lt;(,-&gt;&lt;),-&gt;&lt;&#123;,-&gt;&lt;int,-&gt;&lt;$ID,a&gt;&lt;=,-&gt;&lt;$NUM,5&gt;&lt;;,-&gt;&lt;int,-&gt;&lt;$ID,b&gt;&lt;=,-&gt;&lt;$ID,a&gt;&lt;+,-&gt;&lt;$NUM,3.5E3&gt;&lt;;,-&gt;&lt;char,-&gt;&lt;$ID,s&gt;&lt;[,-&gt;&lt;],-&gt;&lt;=,-&gt;&lt;$STR,&quot;I love the world\n&quot;&gt;&lt;;,-&gt;&lt;for,-&gt;&lt;(,-&gt;&lt;int,-&gt;&lt;$ID,i&gt;&lt;=,-&gt;&lt;$NUM,0&gt;&lt;;,-&gt;&lt;$ID,i&gt;&lt;&lt;,-&gt;&lt;$NUM,5&gt;&lt;;,-&gt;&lt;$ID,i&gt;&lt;++,-&gt;&lt;),-&gt;&lt;$ID,printf&gt;&lt;(,-&gt;&lt;$STR,&quot;%s\n&quot;&gt;&lt;,,-&gt;&lt;$ID,s&gt;&lt;),-&gt;&lt;;,-&gt;&lt;&#125;,-&gt;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux之创建守护进程</title>
    <link href="/posts/9932.html"/>
    <url>/posts/9932.html</url>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><blockquote><p>守护进程是一种运行在后台的特殊进程，它 ** 独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件 ** 。<br>其实，本质上守护进程和普通的进程并没有什么区别，只是我们规定了一种进程的编写规则，将其叫做守护进程，仅此而已。</p></blockquote><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><h4 id="1-在后台运行"><a href="#1-在后台运行" class="headerlink" title="1. 在后台运行"></a>1. 在后台运行</h4><blockquote><p>为了不让其阻塞终端，我们用fork()创建子进程，然后退出父进程，就可以完成在后台运行的目的。</p></blockquote><h4 id="2-脱离控制终端，创建新的会话组和进程组"><a href="#2-脱离控制终端，创建新的会话组和进程组" class="headerlink" title="2. 脱离控制终端，创建新的会话组和进程组"></a>2. 脱离控制终端，创建新的会话组和进程组</h4><blockquote><p>简单说一下会话、进程、进程组以及控制终端的关系。多个进程构成进程组，多个进程组构成一个会话，会话可以有一个控制终端<br>此时我们的会话进程组等都是由父进程继承来的，我们要与之脱离，不受其影响。<br>** 方法是调用setsid();成功返回0，失败返回-1。 **<br>执行成功后会为当前进程创建会话组并成为该会话组的组长，当然也是新的进程组的组长了。<br>当调用者本身就是会话组长时会失败。</p></blockquote><h4 id="3-使其不再是会话组长，用以禁止其打开终端"><a href="#3-使其不再是会话组长，用以禁止其打开终端" class="headerlink" title="3. 使其不再是会话组长，用以禁止其打开终端"></a>3. 使其不再是会话组长，用以禁止其打开终端</h4><blockquote><p>仍然是通过fork()产生子进程，然后退出父进程来做到这一点</p></blockquote><h4 id="4-关闭已经打开文件描述符"><a href="#4-关闭已经打开文件描述符" class="headerlink" title="4. 关闭已经打开文件描述符"></a>4. 关闭已经打开文件描述符</h4><blockquote><p>这里的作用是 ** 避免对资源的占用 **</p></blockquote><pre><code class="hljs">for(int i=0; i&lt;NOFILE; i++)    close(i);//NOFILE所属头文件是 &lt;sys/param.h&gt;</code></pre><h4 id="5-更改当前工作目录"><a href="#5-更改当前工作目录" class="headerlink" title="5. 更改当前工作目录"></a>5. 更改当前工作目录</h4><blockquote><p>原因很简单，比如你讲工作目录设在了/home/aaa下，现在你要删掉aaa，是删不掉的，因为守护进程在运行过程中，是依赖于aaa这个目录的。<br>通常需要将工作目录设为根，根据特定情况而定。</p></blockquote><pre><code class="hljs">    chdir(&quot;/&quot;)</code></pre><h4 id="6-重设文件掩码"><a href="#6-重设文件掩码" class="headerlink" title="6. 重设文件掩码"></a>6. 重设文件掩码</h4><blockquote><p>使文件操作权限不再受父进程影响<br>直接将其设为0即可。<br>** umask(0); **<br>这里强调一点，umask函数里的参数，我们平时使用的比如0666，第一位的0只是表示0666是一个八进制的数，没有别的含义。与umask命令略有区别</p></blockquote><h4 id="7-处理信号-非必须"><a href="#7-处理信号-非必须" class="headerlink" title="7. 处理信号(非必须)"></a>7. 处理信号(非必须)</h4><pre><code class="hljs">signal(SIGCHLD, SIG_IGN);</code></pre><blockquote><p>忽略SIGCHLD信号，常用于并发服务器的性能提升。因为并发服务器常常fork很多子进程，子进程终结之后需要服务器进程去wait清理资源。如果将此信号的<br>处理方式设为忽略，内核就会把僵尸子进程转交给init进程去处理，避免了大量僵尸进程对系统资源的占用。</p></blockquote><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="hljs">#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/param.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;#include &lt;time.h&gt;#include &lt;string.h&gt;#define DIR &quot;/Users/shiyi/Desktop&quot;#define TMP_TXT &quot;/Users/shiyi/Desktop/tmp.txt&quot;void init_daemon()&#123;    //转为后台进程    int pid = fork();    if(pid &lt; 0)        exit(1);    else if(pid != 0)        exit(0);    //开启新的会话组，成为会话组长和进程组长    setsid();    //使其不再是会话组长，不能开启终端    pid = fork();    if(pid &lt; 0)        exit(1);    else if(pid != 0)        exit(0);    //关闭已经打开的文件描述符，避免浪费系统资源    for(int i=0; i&lt;NOFILE; i++)        close(i);    //更改工作目录    chdir(DIR);    //重设文件掩码，使文件操作权限不再受父进程影响    umask(0000);    //重定向输入输出    int fd = open(TMP_TXT, O_CREAT | O_RDWR, 0644);    if(fd &lt; 0)        exit(2);    dup2(fd, STDIN_FILENO);    dup2(fd, STDOUT_FILENO);    dup2(fd, STDERR_FILENO);    close(fd);    //忽略SIGCHLD信号，避免大量僵尸进程占用系统资源    signal(SIGCHLD, SIG_IGN);&#125;int main()&#123;    //创建守护进程    init_daemon();    time_t t;    char str[30];    for(int i=0; i&lt;10; i++)    &#123;        time(&amp;t);        strcpy(str, ctime(&amp;t));        str[strlen(str)-1] = &#39;\0&#39;;        printf(&quot;%s : 当前是第%d次循环\n&quot;, str, i);        fflush(NULL);        sleep(1);    &#125;    return 0;&#125;</code></pre><h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><p><img src="http://img.blog.csdn.net/20161017174751382" alt="这里写图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>服务器开发</tag>
      
      <tag>Linux系统编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux之fcntl&amp;flock建议锁的操作</title>
    <link href="/posts/32846.html"/>
    <url>/posts/32846.html</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>当我们要进行多进程编程的时候，经常存在多个进程需要访问同一个文件的情况，因此会产生进程间访问不一致的问题，那么我们可以用到fcntl函数，我们可以用它来对文<br>件或者文件的一部分进行上锁。</p><pre><code class="hljs">   #include &lt;unistd.h&gt;   #include &lt;fcntl.h&gt;   int fcntl(int fd, int cmd, ... /* arg */ );</code></pre><p>fcntl 可以施加建议性锁，也可以施加强制锁。同时还能对文件的某一记录进行上锁，也就是记录锁。<br>** 所谓建议性锁，就是说它不具备强制性，只是作为程序员之间的约定，如果你愿意，仍然可以直接去对一个上锁的文件进行操作。 **</p><h3 id="fcntl"><a href="#fcntl" class="headerlink" title="fcntl"></a>fcntl</h3><p>这里我们只讲述加建议性锁，即arg为struct flock指针类型的时候，如下。</p><pre><code class="hljs">       int fcntl(int fd, int cmd, struct flock*);</code></pre><p>从fcntl的函数声明可以看到，它的参数是可变的。</p><h4 id="第一个参数fd："><a href="#第一个参数fd：" class="headerlink" title="第一个参数fd："></a>第一个参数fd：</h4><blockquote><p>要操作的文件描述符，</p></blockquote><h4 id="第二个参数cmd："><a href="#第二个参数cmd：" class="headerlink" title="第二个参数cmd："></a>第二个参数cmd：</h4><blockquote><p>要操作的指令类型，我们只考虑在第三个参数为flock结构体指针的情况下，cmd有三种取值情况：<br>F_GETLK 取得文件锁定的状态。<br>F_SETLK 设置文件锁定的状态。此时flcok 结构的l_type<br>值必须是F_RDLCK、F_WRLCK或F_UNLCK。如果无法建立锁定，则返回-1，错误代码为EACCES 或EAGAIN。<br>F_SETLKW F_SETLK<br>作用相同，但是无法建立锁定时，此调用会一直等到锁定动作成功为止。若在等待锁定的过程中被信号中断时，会立即返回-1，错误代码为EINTR。</p></blockquote><h4 id="第三个参数struct-flock-："><a href="#第三个参数struct-flock-：" class="headerlink" title="第三个参数struct flock*："></a>第三个参数struct flock*：</h4><blockquote><p>flock结构体定义如下</p></blockquote><pre><code class="hljs">struct flock&#123;    short int l_type;    short int l_whence;    off_t l_start;    off_t l_len;    pid_t l_pid;&#125;;</code></pre><p>** l_type 有三种状态: **</p><pre><code class="hljs">F_RDLCK 建立读锁F_WRLCK 建立写锁F_UNLCK 删除之前建立的锁</code></pre><p>** l_whence 也有三种方式: **</p><pre><code class="hljs">SEEK_SET 以文件开头为锁定的起始位置。SEEK_CUR 以目前文件读写位置为锁定的起始位置SEEK_END 以文件结尾为锁定的起始位置。</code></pre><p><strong>l_start 表示相对l_whence位置的偏移量，两者一起确定锁定区域的开始位置。<br>l_len表示锁定区域的长度，若为0则表示整个文件的长度，即不管在后面增加多少数据都在锁的范围内。<br>返回值 成功返回依赖于cmd的值，若有错误则返回-1，错误原因存于errno.</strong></p><h3 id="测试过程中发现的问题！！！"><a href="#测试过程中发现的问题！！！" class="headerlink" title="测试过程中发现的问题！！！"></a>测试过程中发现的问题！！！</h3><blockquote><ol><li>用fcntl获取锁的时候(F_GETLK)，struct flock<em>参数的l_type取值必须为(F_RDLCK|F_WRLCK|F_UNL<br>CK)中的一个，否则fcntl会执行失败，这个坑了我半天的时间，因为以为struct flock</em>只是作为接受锁信息的载体，没想到其type也必须要赋值才行<br>。测试证明，l_type的取值跟获取锁的结果没有任何关系，其赋值的意义仅在于赋值合法而已。</li></ol></blockquote><blockquote><ol start="2"><li>读锁作为共享锁，是可以存在多个的，所以在A进程里设置读锁后，在B进程里是获取不到的。</li></ol></blockquote><blockquote><ol start="3"><li>进程A设置的锁对进程A是不可见的，也就是说进程A无法GET到自己获得的锁。</li></ol></blockquote><h3 id="测试程序"><a href="#测试程序" class="headerlink" title="测试程序"></a>测试程序</h3><pre><code class="hljs">/*fcntl_write.c测试文件写入锁主函数部分*/#include &lt;unistd.h&gt;#include &lt;sys/file.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;/*lock_set函数*/void lock_set(int fd, int type)&#123;    struct flock lock;    lock.l_whence = SEEK_SET;//赋值lock结构体    lock.l_start = 0;    lock.l_len =0;    lock.l_type = type;    /*根据不同的type值给文件上锁或解锁*/    if((fcntl(fd, F_SETLK, &amp;lock)) == 0)&#123;        if( lock.l_type == F_RDLCK )            printf(&quot;read lock set by %d\n&quot;,getpid());        else if( lock.l_type == F_WRLCK )            printf(&quot;write lock set by %d\n&quot;,getpid());        else if( lock.l_type == F_UNLCK )            printf(&quot;release lock by %d\n&quot;,getpid());    &#125;    else    &#123;        /*判断文件是否可以上锁*/        fcntl(fd, F_GETLK,&amp;lock);        /*判断文件不能上锁的原因*/        if(lock.l_type == F_UNLCK)            printf(&quot;no lock by %d\n&quot;,lock.l_pid);        /*/该文件已有写入锁*/        if( lock.l_type == F_RDLCK )            printf(&quot;read lock already set by %d\n&quot;,lock.l_pid);        /*该文件已有读取锁*/        else if( lock.l_type == F_WRLCK )            printf(&quot;write lock already set by %d\n&quot;,lock.l_pid);    &#125;&#125;void lock_get(int fd)&#123;    struct flock lock;    lock.l_whence = SEEK_SET;//赋值lock结构体    lock.l_start = 0;    lock.l_len =0;    lock.l_type = F_RDLCK;    /*判断文件是否可以上锁*/    if(0 &gt; fcntl(fd, F_GETLK,&amp;lock))    &#123;        printf(&quot;get lock failure by %d\n&quot;,getpid());    &#125;    /*判断文件不能上锁的原因*/    if(lock.l_type == F_UNLCK)        printf(&quot;no lock by %d\n&quot;,lock.l_pid);    /*/该文件已有写入锁*/    else if( lock.l_type == F_RDLCK )        printf(&quot;read lock already set by %d\n&quot;,lock.l_pid);    /*该文件已有读取锁*/    else if( lock.l_type == F_WRLCK )        printf(&quot;write lock already set by %d\n&quot;,lock.l_pid);&#125;int main()&#123;    int fd;    /*首先打开文件*/    fd=open(&quot;hello&quot;,O_RDWR | O_CREAT, 0666);    if(fd &lt; 0)&#123;        perror(&quot;open&quot;);        exit(1);    &#125;    while(1)    &#123;        char str[4];        int type;        scanf(&quot;%s&quot;, str);        switch(str[0])&#123;            //write lock            case &#39;w&#39;:                type = F_WRLCK;                break;            //read lock            case &#39;r&#39;:                type = F_RDLCK;                break;            //unlock            case &#39;u&#39;:                type = F_UNLCK;                break;            //getlock            case &#39;g&#39;:                type = 0;                break;        &#125;        if(type == 0)            lock_get(fd);        else            lock_set(fd, type);    &#125;    close(fd);    return 0;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>服务器开发</tag>
      
      <tag>Linux系统编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c语言词法分析初试(C++实现)</title>
    <link href="/posts/28691.html"/>
    <url>/posts/28691.html</url>
    
    <content type="html"><![CDATA[<h3 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h3><blockquote><p>所谓词法分析，就是将源代码按照构词规则分解成一系列单词符号。单词是语言中具有独立意义的最小单位，包括关键字、标识符、运算符、界符和常量等。</p></blockquote><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><blockquote><p>源程序分解的单词可以归为以下几类：</p></blockquote><h4 id="1-关键字"><a href="#1-关键字" class="headerlink" title="1. 关键字"></a>1. 关键字</h4><blockquote><p>c语言关键字有不少，这里只列举其中一部分：<br>for，while，do，continue，if，else，<br>char，int，double，return</p></blockquote><h4 id="2-变量名"><a href="#2-变量名" class="headerlink" title="2. 变量名"></a>2. 变量名</h4><blockquote><p>变量名的规则为：<br>由字母数字以及下划线组成，开头必须为下划线或字母<br>用正规表达式描述为</p></blockquote><pre><code class="hljs">letter = &#123;a|b|...|z|A|B|...|Z&#125;digit = &#123;0|1|...|9&#125;id = (letter|_ )(letter| _| digit)*</code></pre><p>转化为NFA图为：<br><img src="http://img.blog.csdn.net/20161008190036033" alt="这里写图片描述"></p><h4 id="3-数字常量"><a href="#3-数字常量" class="headerlink" title="3. 数字常量"></a>3. 数字常量</h4><p>变量名的规则为：</p><blockquote><p>由字母数字以及下划线组成，开头必须为下划线或字母<br>用正规表达式描述为</p></blockquote><pre><code class="hljs">digit = &#123;0|1|...|9&#125;id = digit((digit)*|.(digit)*)(ℇ | (E|e)digit(digit)*)</code></pre><p>转化为NFA图为：</p><p><img src="http://img.blog.csdn.net/20161008190016923" alt="这里写图片描述"></p><h4 id="4-界符和运算符"><a href="#4-界符和运算符" class="headerlink" title="4. 界符和运算符"></a>4. 界符和运算符</h4><blockquote><p>()[]{};+-<em>/等等<br>本人这里只加入了+-和=，因为</em>/以及&amp;^%等都是类似的，这里只是试验，不需要全部写。</p></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><blockquote><p>根据有限自动机的概念，将整个源代码分解的规则转化为一个一个状态，用switch或if/else将状态之间的转移描述出来即可。这里省略了将常量以及变量名插<br>入到符号表返回指针的那一步。<br>简单一个伪代码描述这个过程</p></blockquote><pre><code class="hljs">    初始化 状态=0    switch(状态):    &#123;        case 0:            接收源码            if(符合1规则)                处理，状态=1            else if(符合2规则)                处理，状态=2            else                ...        case 1:        case 2:        case ...    &#125;</code></pre><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="hljs">#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;cstdlib&gt;#include &lt;cstdio&gt;using namespace std;const int KEY_NUM = 11;const char* KEY_SET[] = &#123;    &quot;for&quot;,    &quot;while&quot;,    &quot;do&quot;,    &quot;continue&quot;,    &quot;if&quot;,    &quot;else&quot;,    &quot;char&quot;,    &quot;int&quot;,    &quot;double&quot;,    &quot;float&quot;,    &quot;return&quot;&#125;;const char* FILE_NAME = &quot;/Users/shiyi/abc.c&quot;;char strBuffer[1026];char strBox[200];void retract(char* &amp;str)&#123;    str--;&#125;char getChar(char* &amp;str)&#123;    return *str++;&#125;bool isNum(char ch)&#123;    if(ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;)        return true;    return false;&#125;bool isLetter(char ch)&#123;    if(ch &gt;= &#39;a&#39; &amp;&amp; ch &lt;= &#39;z&#39;)        return true;    if(ch &gt;= &#39;A&#39; &amp;&amp; ch &lt;= &#39;Z&#39;)        return true;    return false;&#125;int findKey(char* ch)&#123;    for(int i=0; i&lt;KEY_NUM; i++)    &#123;        if(0 == strcmp(ch, KEY_SET[i]))            return i+1;    &#125;    return 0;&#125;void output(char* key, char* value)&#123;    printf(&quot;&lt; %s, %s &gt;\n&quot;, key, value);&#125;//扫描void scanner(char* str)&#123;    int state = 0;    char ch = &#39; &#39;;    int pos = 0;    while(ch != &#39;\0&#39;)    &#123;    switch (state) &#123;        case 0:        &#123;            ch = getChar(str);            switch (ch) &#123;                case &#39; &#39;:                    pos = 0;                    break;                case &#39;[&#39;:                case &#39;]&#39;:                case &#39;(&#39;:                case &#39;)&#39;:                case &#39;&#123;&#39;:                case &#39;&#125;&#39;: &#123;                    char temp[2];                    temp[0] = ch;                    output(temp, &quot;-&quot;);                    pos = 0;                    break;                &#125;                case &#39;\&#39;&#39;: &#123;                    state = 0;                    while((ch = getChar(str)) != &#39;\&#39;&#39; &amp;&amp; ch != &#39;\0&#39;)                    &#123;                        strBox[pos++] = ch;                    &#125;                    if(ch == &#39;\0&#39;)                    &#123;                        //error                    &#125;                    strBox[pos] = &#39;\0&#39;;                    output(&quot;string&quot;, strBox);                    pos = 0;                    break;                &#125;                case &#39;&quot;&#39;: &#123;                    state = 0;                    while((ch = getChar(str)) != &#39;&quot;&#39; &amp;&amp; ch != &#39;\0&#39;)                    &#123;                        strBox[pos++] = ch;                    &#125;                    if(ch == &#39;\0&#39;)                    &#123;                        ////                        output(&quot;error&quot;, strBox);                    &#125;                    else                    &#123;                        strBox[pos] = &#39;\0&#39;;                        output(&quot;string&quot;, strBox);                        pos = 0;                    &#125;                    break;                &#125;                case &#39;+&#39;: &#123;                    state = 0;                    ch = getChar(str);                    switch (ch) &#123;                        case &#39;+&#39;:                            output(&quot;++&quot;, &quot;-&quot;);                            pos = 0;                            break;                        case &#39;=&#39;:                            output(&quot;+=&quot;, &quot;-&quot;);                            pos = 0;                            break;                        default:                            retract(str);                            output(&quot;+&quot;, &quot;-&quot;);                            pos = 0;                            break;                    &#125;                &#125;                case &#39;-&#39;: &#123;                    state = 0;                    ch = getChar(str);                    switch (ch) &#123;                        case &#39;-&#39;:                            output(&quot;--&quot;, &quot;-&quot;);                            pos = 0;                            break;                        case &#39;=&#39;:                            output(&quot;-=&quot;, &quot;-&quot;);                            pos = 0;                            break;                        default:                            retract(str);                            output(&quot;-&quot;, &quot;-&quot;);                            pos = 0;                            break;                    &#125;                &#125;                case &#39;=&#39;: &#123;                    state = 0;                    ch = getChar(str);                    switch (ch) &#123;                        case &#39;=&#39;:                            output(&quot;==&quot;, &quot;-&quot;);                            pos = 0;                            break;                        default:                            retract(str);                            output(&quot;=&quot;, &quot;-&quot;);                            pos = 0;                            break;                    &#125;                    break;                &#125;                default: &#123;                    if(isNum(ch))                    &#123;                        strBox[pos++] = ch;                        state = 2;                    &#125;                    else if(isLetter(ch) || ch == &#39;_&#39;)                    &#123;                        strBox[pos++] = ch;                        state = 1;                    &#125;                    break;                &#125;            &#125;            break;        &#125;        case 1:        &#123;            while(true)            &#123;                ch = getChar(str);                if(isLetter(ch) || isNum(ch) || ch == &#39;_&#39;)                    strBox[pos++] = ch;                else                &#123;                    strBox[pos] = &#39;\0&#39;;                    int id = findKey(strBox);                    if(id == 0)                        output(&quot;id&quot;, strBox);                    else                        output(&quot;key&quot;, strBox);                    retract(str);                    pos = 0;                    state = 0;                    break;                &#125;            &#125;            break;        &#125;        case 2:        &#123;            while(true)            &#123;                ch = getChar(str);                if(isNum(ch))                    strBox[pos++] = ch;                else if(ch == &#39;.&#39;)                &#123;                    strBox[pos++] = ch;                    state = 3;                    break;                &#125;                else if(ch == &#39;E&#39; || ch == &#39;e&#39;)                &#123;                    strBox[pos++] = ch;                    state = 4;                    break;                &#125;                else                &#123;                    strBox[pos] = &#39;\0&#39;;                    output(&quot;number&quot;, strBox);                    retract(str);                    pos = 0;                    state = 0;                    break;                &#125;            &#125;            break;        &#125;        case 3:        &#123;            while(true)            &#123;                ch = getChar(str);                if(isNum(ch))                    strBox[pos++] = ch;                else if(ch == &#39;E&#39; || ch == &#39;e&#39;)                &#123;                    strBox[pos++] = ch;                    state = 4;                &#125;                else                &#123;                    strBox[pos] = &#39;\0&#39;;                    output(&quot;number&quot;, strBox);                    retract(str);                    pos = 0;                    state = 0;                    break;                &#125;            &#125;            break;        &#125;        case 4:        &#123;            while(true)            &#123;                ch = getChar(str);                if(isNum(ch))                    strBox[pos++] = ch;                else                &#123;                    strBox[pos] = &#39;\0&#39;;                    output(&quot;number&quot;, strBox);                    retract(str);                    pos = 0;                    state = 0;                    break;                &#125;            &#125;            break;        &#125;        default:            ////            output(&quot;error&quot;, strBox);            break;    &#125;    &#125;&#125;int main()&#123;    FILE* file = fopen(FILE_NAME, &quot;r&quot;);    while(NULL != fgets(strBuffer, 1024, file))    &#123;        scanner(strBuffer);    &#125;    return 0;&#125;</code></pre><h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><h4 id="源程序"><a href="#源程序" class="headerlink" title="源程序"></a>源程序</h4><pre><code class="hljs">int main()&#123;    int a = 5;    for(int i=0; i&lt;5; i++)    &#123;        a++;    &#125;    return 0;&#125;</code></pre><h4 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果"></a>输出结果</h4><pre><code class="hljs">&lt; key, int &gt;&lt; id, main &gt;&lt; (, - &gt;&lt; ), - &gt;&lt; &#123;, - &gt;&lt; key, int &gt;&lt; id, a &gt;&lt; =, - &gt;&lt; number, 5 &gt;&lt; key, for &gt;&lt; (, - &gt;&lt; key, int &gt;&lt; id, i &gt;&lt; =, - &gt;&lt; number, 0 &gt;&lt; id, i &gt;&lt; number, 5 &gt;&lt; id, i &gt;&lt; ++, - &gt;&lt; -, - &gt;&lt; =, - &gt;&lt; ), - &gt;&lt; &#123;, - &gt;&lt; id, a &gt;&lt; ++, - &gt;&lt; -, - &gt;&lt; =, - &gt;&lt; &#125;, - &gt;&lt; key, return &gt;&lt; number, 0 &gt;&lt; &#125;, - &gt;Program ended with exit code: 0</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>正规表达式转NFA(C++)</title>
    <link href="/posts/7094.html"/>
    <url>/posts/7094.html</url>
    
    <content type="html"><![CDATA[<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><blockquote><p>表达式里包含五种符号：左括号，右括号，连接符，选择符，闭包符。<br>连接符因为优先级最高，可以将其过滤掉，不予考虑。</p></blockquote><h4 id="闭包符"><a href="#闭包符" class="headerlink" title="闭包符*"></a>闭包符*</h4><blockquote><p>首先来说闭包，无非两种情况：<br>X* 或者 (…..)*<br>两者都可以看做是从一个起始状态，经过诸多输入到达一个终止状态。如 1– X –&gt;2 和 1– (……) –&gt; 2。<br>那么闭包符可以看做是以下操作：<br>1 – ε –&gt; 2<br>2 – ε –&gt; 1<br>即将首尾以空连接即可。</p></blockquote><h4 id="选择符"><a href="#选择符" class="headerlink" title="选择符|"></a>选择符|</h4><blockquote><p>把整体式也看做在一个大括号内的话，我们可以认为选择符一定是在括号内出现的。那么对一个括号内的表达式，我们给定它一个起始状态和终止状态，那么选择符处理方法<br>如下：<br>(.A.|.B.|.C.)<br>st – .A. –&gt; ed<br>st – .B. –&gt; ed<br>st – .C. –&gt; ed<br>即将|分隔的每部分表达式都与首尾状态连接。</p></blockquote><h4 id="括号"><a href="#括号" class="headerlink" title="括号()"></a>括号()</h4><blockquote><p>因为括号的嵌套问题，让这个转化变得稍微棘手了些，但利用递归思想，每个括号里面的表达式看做一个子问题，对于括号内的式子给定该式一起始状态和终止状态，那么(<br>…)和X也就没有什么区别了。</p></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><blockquote><p>首先我们定义三个栈：<br>s_str，保存输入信息<br>s_st，保存起始状态序号<br>s_ed，保存终止状态序号<br>我们用一个例子来解释栈的进出规则。</p></blockquote><pre><code class="hljs">ab*(a*|(ab)*)</code></pre><blockquote><p>** 上式基本涵盖了所有表达式存在的情况，仔细看完它的转化过程，转化为代码是很容易的。 **<br>首先，将整个式子的起始状态id设为0和终止状态id为1，将其分别入栈s_st和s_ed<br>接下来对整个表达式进行扫描<br>[a] 添加状态id=3，入栈s_st，a入栈s_str.<br>[b] 添加状态id=4，入栈s_st，b入栈s_str.<br>[(] 因为上一个符号b已经添加的状态4可以作为括号内部分的起始状态，那么只添加终止状态=5，入栈s_ed，(入栈s_str.<br>[a] 添加状态id=6，入栈s_st，a入栈s_str.<br>[<em>] 获取s_st栈顶的两个状态，4和6, 添加4–ε–&gt;6 和 6–ε–&gt;4<br>[|] 依次对s_str进行出栈直到栈顶为(，同时对s_st进行出栈，<br>并将其两两用s_str进行连接. 如a出栈(s_str)，6出栈(s_st)，添加4–a–&gt;6.<br>最重要的地方是，将最先出栈的状态id与s_ed进行连接，即添加 6–ε–&gt;5.<br>[(] 添加终止状态=7，入栈s_ed，(入栈s_str.<br>[a] 添加状态id=8，入栈s_st，a入栈s_str.<br>[b] 添加状态id=9，入栈s_st，b入栈s_str.<br>[)] 依次对s_str进行出栈直到栈顶为(，同时对s_st进行出栈，<br>并将其两两用s_str进行连接(和|有些类似)，然后将该括号部分的终止id出栈=7，并将其入栈s_st，<br>同时入栈’-‘至s_str，’-‘作为括号里面部分式子的输入符号(其实是起占位符的作用，<br>这样的话，括号整体部分就与单个输入没有区别，既便于闭包符的处理，又解决了多个括号并列的情况).<br>[</em>] 获取s_st栈顶的两个状态，6和7, 添加7–ε–&gt;6 和 6–ε–&gt;7<br>[)] 与上面）的处理是完全一样的。</p></blockquote><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="hljs">#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;stack&gt;using namespace std;struct Node&#123;    Node(int id, char input, int nextId)    &#123;        this-&gt;id = id;        this-&gt;input = input;        this-&gt;nextId = nextId;    &#125;    int id;    char input;    int nextId;&#125;;class MyClass&#123;public:    MyClass() &#123;        strExpress = &quot;&quot;;        statusId = 0;    &#125;    MyClass(string str)    &#123;        strExpress = str;    &#125;    void printNFA();    void strToNFA();private:    string strExpress;    int statusId;    vector&lt;Node*&gt; map;&#125;;void MyClass::strToNFA()&#123;    stack&lt;int&gt; s_st;    stack&lt;int&gt; s_ed;    stack&lt;char&gt; s_str;    s_str.push(&#39;$&#39;);    s_st.push(statusId++);    s_ed.push(statusId++);    for(auto i=strExpress.begin(); i!=strExpress.end(); ++i)    &#123;        char ch = *i;        cout&lt;&lt;ch;        switch (ch)        &#123;            case &#39;(&#39;:            &#123;                s_ed.push(statusId++);                s_str.push(&#39;(&#39;);                break;            &#125;            case &#39;)&#39;:            &#123;                int ed = s_ed.top();                int st = s_st.top();                map.push_back(new Node(st, &#39;-&#39;, ed));                ch = s_str.top();                while(ch != &#39;(&#39;)                &#123;                    int nxt = s_st.top();                    s_st.pop();                    int pre = s_st.top();                    if(ch != &#39;#&#39;)                        map.push_back(new Node(pre, ch, nxt));                    s_str.pop();                    ch = s_str.top();                &#125;                s_str.pop();                s_str.push(&#39;#&#39;);                s_st.push(s_ed.top());                s_ed.pop();                break;            &#125;            case &#39;|&#39;:            &#123;                int ed = s_ed.top();                int st = s_st.top();                map.push_back(new Node(st, &#39;-&#39;, ed));                ch = s_str.top();                while(ch != &#39;(&#39; &amp;&amp; ch != &#39;$&#39;)                &#123;                    int nxt = s_st.top();                    s_st.pop();                    int pre = s_st.top();                    if(ch != &#39;#&#39;)                        map.push_back(new Node(pre, ch, nxt));                    s_str.pop();                    ch = s_str.top();                &#125;                break;            &#125;            case &#39;*&#39;:            &#123;                int nxt = s_st.top();                s_st.pop();                int pre = s_st.top();                map.push_back(new Node(pre, &#39;-&#39;, nxt));                map.push_back(new Node(nxt, &#39;-&#39;, pre));                s_st.push(nxt);                break;            &#125;            default:            &#123;                s_str.push(ch);                s_st.push(statusId++);                break;            &#125;        &#125;    &#125;    char ch = s_str.top();    while(ch != &#39;$&#39;)    &#123;        int nxt = s_st.top();        s_st.pop();        int pre = s_st.top();        if(ch != &#39;#&#39;)            map.push_back(new Node(pre, ch, nxt));        s_str.pop();        ch = s_str.top();    &#125;&#125;void MyClass::printNFA()&#123;    cout&lt;&lt;&quot;NFA：&quot;&lt;&lt;endl;    for(auto node : map)    &#123;        cout&lt;&lt;node-&gt;id&lt;&lt;&quot;--[&quot;&lt;&lt;node-&gt;input&lt;&lt;&quot;]--&gt;&quot;&lt;&lt;node-&gt;nextId&lt;&lt;endl;    &#125;&#125;int main()&#123;    string str;    stack&lt;int&gt; s;//    cin&gt;&gt;str;    str = &quot;ab*(a*|(ab)*|b)*b&quot;;    MyClass myclass(str);    myclass.strToNFA();    myclass.printNFA();    return 0;&#125;</code></pre><h3 id="output"><a href="#output" class="headerlink" title="output"></a>output</h3><pre><code class="hljs">ab*(a*|(ab)*|b)*bNFA：2--[-]--&gt;33--[-]--&gt;23--[-]--&gt;55--[-]--&gt;35--[-]--&gt;43--[a]--&gt;58--[-]--&gt;67--[b]--&gt;83--[a]--&gt;73--[-]--&gt;66--[-]--&gt;36--[-]--&gt;49--[-]--&gt;43--[b]--&gt;93--[-]--&gt;44--[-]--&gt;34--[b]--&gt;102--[b]--&gt;30--[a]--&gt;2</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaWeb ServletContext/application初试总结</title>
    <link href="/posts/43695.html"/>
    <url>/posts/43695.html</url>
    
    <content type="html"><![CDATA[<h2 id="简介：ServletContext-application"><a href="#简介：ServletContext-application" class="headerlink" title="简介：ServletContext/application"></a>简介：ServletContext/application</h2><blockquote><p>为什么将其两者放在一起介绍呢，因为他们可以被看做是同一个类，只是名字起得不同而已。<br>ServletContext是在Servlet中使用，而application则作为内置对象用于jsp中。<br>他们的作用域是 ** 整个tomcat的从启动到关闭的过程 ** 。<br>我们可以将其看做是JavaWeb应用里的全局变量。</p></blockquote><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><blockquote><p>所谓功能，也就是说，我们在什么时候会用到它们。<br>当你的服务端需要一些配置属性供所有客户端来进行访问，用ServletContext/application就正好。<br>比如：页面的访问次数，当前在线人数，等等信息。</p></blockquote><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="application"><a href="#application" class="headerlink" title="application"></a>application</h3><blockquote><p>已经说过，application是jsp的内置对象，使用起来很方便。如下，很简单，不再赘述。</p></blockquote><p><code>&lt;% application.setAttribute(&quot;num&quot;, 10); %&gt; &lt;% int num = (int)application.getAttribute(&quot;num&quot;); %&gt;</code></p><h3 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a>ServletContext</h3><blockquote><p>我们主要来说一下ServletContext的使用，既然要供所有客户端访问，那么肯定要进行初始化，这里主要有两种方式</p></blockquote><h4 id="1：通过监听器-listener-来初始化"><a href="#1：通过监听器-listener-来初始化" class="headerlink" title="1：通过监听器(listener)来初始化"></a>1：通过监听器(listener)来初始化</h4><blockquote><p>第一步：用一个类实现ServletContextListener接口提供的两个方法<br>contextInitialized：在tomcat启动的时候会调用<br>contextDestroyed：在tomcat关闭的时候会调用<br>如下</p></blockquote><pre><code class="hljs">public class ContextLoaderListener implements ServletContextListener &#123;    @Override    public void contextInitialized(ServletContextEvent sce) &#123;        ServletContext servletContext = sce.getServletContext();        servletContext.setAttribute(&quot;num&quot;, 10);        System.out.println(&quot;begin:&quot; + servletContext.getAttribute(&quot;num&quot;));    &#125;    @Override    public void contextDestroyed(ServletContextEvent sce) &#123;        ServletContext servletContext = sce.getServletContext();        System.out.println(&quot;end:&quot; + servletContext.getAttribute(&quot;num&quot;));    &#125;&#125;</code></pre><h4 id="第二步，在web-xml里面配置监听器，如下"><a href="#第二步，在web-xml里面配置监听器，如下" class="headerlink" title="第二步，在web.xml里面配置监听器，如下"></a>第二步，在web.xml里面配置监听器，如下</h4><pre><code class="hljs">&lt;listener&gt;    &lt;listener-class&gt;com.web.listener.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt;</code></pre><h3 id="2：自定义Servlet并设置Servlet的load-on-startup-1"><a href="#2：自定义Servlet并设置Servlet的load-on-startup-1" class="headerlink" title="2：自定义Servlet并设置Servlet的load-on-startup=1"></a>2：自定义Servlet并设置Servlet的load-on-startup=1</h3><h4 id="第一步，自定义Servlet类，重写init-和destroy-，如下"><a href="#第一步，自定义Servlet类，重写init-和destroy-，如下" class="headerlink" title="第一步，自定义Servlet类，重写init()和destroy()，如下"></a>第一步，自定义Servlet类，重写init()和destroy()，如下</h4><pre><code class="hljs">public class ContextLoaderServlet implements Servlet &#123;    private ServletConfig config;    @Override    public void init(ServletConfig config) throws ServletException &#123;        this.config = config;        ServletContext servletContext = config.getServletContext();        servletContext.setAttribute(&quot;num&quot;, 10);        System.out.println(&quot;begin:&quot; + servletContext.getAttribute(&quot;num&quot;));    &#125;    @Override    public void destroy() &#123;        ServletContext servletContext = config.getServletContext();        System.out.println(&quot;end:&quot; + servletContext.getAttribute(&quot;num&quot;));    &#125;    @Override    public ServletConfig getServletConfig() &#123;        return null;    &#125;    @Override    public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException &#123;    &#125;    @Override    public String getServletInfo() &#123;        return null;    &#125;&#125;</code></pre><h4 id="第二步，配置servlet为自启动，将如下配置添入web-xml"><a href="#第二步，配置servlet为自启动，将如下配置添入web-xml" class="headerlink" title="第二步，配置servlet为自启动，将如下配置添入web.xml"></a>第二步，配置servlet为自启动，将如下配置添入web.xml</h4><pre><code class="hljs">&lt;servlet&gt;        &lt;servlet-name&gt;ContextLoaderServlet&lt;/servlet-name&gt;        &lt;servlet-class&gt;com.web.ContextLoaderServlet&lt;/servlet-class&gt;        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;    &lt;/servlet&gt;    &lt;servlet-mapping&gt;        &lt;servlet-name&gt;ContextLoaderServlet&lt;/servlet-name&gt;        &lt;url-pattern&gt;/ContextLoaderServlet&lt;/url-pattern&gt;    &lt;/servlet-mapping&gt;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IDEA使用maven创建web项目卡住解决办法</title>
    <link href="/posts/11961.html"/>
    <url>/posts/11961.html</url>
    
    <content type="html"><![CDATA[<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><blockquote><p>如下图所示：在Properties中添加一个参数archetypeCatalog=internal，不加这个参数，在maven生成骨架的时候将会非常慢，<br>有时候会直接卡住。</p></blockquote><h3 id="理由"><a href="#理由" class="headerlink" title="理由"></a>理由</h3><blockquote><p>archetypeCatalog表示插件使用的archetype元数据，不加这个参数时默认为remote，local，即中央仓库archetype元数据<br>，由于中央仓库的archetype太多了，所以导致很慢，指定internal来表示仅使用内部元数据。</p></blockquote><h3 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h3><p><img src="http://img.blog.csdn.net/20160923001955417" alt="这里写图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网易游戏面试题</title>
    <link href="/posts/28122.html"/>
    <url>/posts/28122.html</url>
    
    <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p><img src="http://img.blog.csdn.net/20160919221334382" alt="这里写图片描述"></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><blockquote><p>乍一看题，冒出来的思路是，将每个用户凡是在同一个群的两个用户看做是一条无向边，这样所有群的所有用户之间的联系就转化为了一张图，然后以官方用户(id=1)<br>为起点，计算所有可以到达的节点的总数，dfs即可，按着这个思路正准备开始写，发现id max为100000，二维数组是开不了了，临界表的话未免也太繁琐了。<br>才突然意识到我们只需要对所有用户之间的连通性进行判断，至于具体的连通顺序根本不需要确定，那么呼之欲出了， ** 并查集 ** 。<br>在并查集基础之上，用每个集的顶节点为标识，记录每个集的节点总数，在集合并时对总数进行更新，一个数组就可以解决。</p></blockquote><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="hljs">#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;#define N 100009int p[N];int fa[N];int d[1009];int find(int x)&#123;    if(fa[x] == -1)        return x;    return fa[x] = find(fa[x]);&#125;int main()&#123;    int m;    scanf(&quot;%d&quot;, &amp;m);    memset(fa, -1, sizeof(fa));    for(int i=0; i&lt;=100000; i++)        p[i] = 1;    for(int i=0; i&lt;m; i++)    &#123;        int k;        scanf(&quot;%d&quot;, &amp;k);        for(int j=0; j&lt;k; j++)            scanf(&quot;%d&quot;, &amp;d[j]);        int x = find(d[0]);        for(int j=1; j&lt;k; j++)        &#123;            int y = find(d[j]);            if(x != y)            &#123;                fa[y] = x;                p[x] += p[y];            &#125;        &#125;    &#125;    int x = find(1);    printf(&quot;%d\n&quot;, p[x]-1);    return 0;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并差集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JDBC数据库操作封装(PreparedStatement)</title>
    <link href="/posts/64340.html"/>
    <url>/posts/64340.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>之前有用过老师给的实现好的JDBC封装类，今天自己看着书按自己思路实现了一遍，并将Statement改为了PreparedStatement。</p></blockquote><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="hljs">import com.sun.tools.javac.util.List;import java.sql.*;import java.util.ArrayList;import java.util.HashMap;import java.util.Map;import java.util.ResourceBundle;/** * Created by shiyi on 16/9/18. */public class DBUtil &#123;    private static DBUtil dbUtil = null;    private String dbDriver;    private String dbUrl;    private String dbUser;    private String dbPass;    private Connection conn;    private PreparedStatement stmt;    private ResultSet rst;    private DBUtil()&#123;&#125;    public static DBUtil getInstance() &#123;        if(dbUtil == null) &#123;            dbUtil = new DBUtil();            dbUtil.openConnection();        &#125;        return dbUtil;    &#125;    //从配置文件获取信息    private void loadConnProperties() &#123;        ResourceBundle rb = ResourceBundle.getBundle(&quot;database&quot;);        dbDriver = rb.getString(&quot;driver&quot;);        dbUrl = rb.getString(&quot;url&quot;);        dbUser = rb.getString(&quot;user&quot;);        dbPass = rb.getString(&quot;pass&quot;);    &#125;    //获取数据库连接对象    private void openConnection() &#123;        loadConnProperties();        try &#123;            //加载driver接口,完成注册            Class.forName(dbDriver);            conn = DriverManager.getConnection(dbUrl, dbUser, dbPass);        &#125; catch (ClassNotFoundException e) &#123;            e.printStackTrace();        &#125; catch (SQLException e) &#123;            e.printStackTrace();        &#125;    &#125;    //执行sql命令    public int execCommand(String sql)    &#123;        int flag = 0;        try &#123;            stmt = conn.prepareStatement(sql);            flag = stmt.executeUpdate();        &#125; catch (SQLException e) &#123;            e.printStackTrace();        &#125;        return flag;    &#125;    //插入新纪录,并获取标识列的值    public int execUpdate(String sql, Object[] data) &#123;        int flag = 0;        try &#123;            if(conn == null)                throw new Exception(&quot;Database not connected!&quot;);            stmt = conn.prepareStatement(sql);            for(int i=0; i&lt;data.length; i++)            &#123;                stmt.setObject(i+1, data[i]);            &#125;            flag = stmt.executeUpdate();        &#125; catch (SQLException e) &#123;            e.printStackTrace();        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125; finally &#123;            try &#123;                stmt.close();            &#125; catch (SQLException e) &#123;                e.printStackTrace();            &#125;        &#125;        return flag;    &#125;    //查询并返回结果集    public ResultSet execQuery(String sql, Object[] data)    &#123;        try &#123;            stmt = conn.prepareStatement(sql);            for(int i=0; i&lt;data.length; i++)            &#123;                stmt.setObject(i+1, data[i]);            &#125;            rst = stmt.executeQuery();        &#125; catch (SQLException e) &#123;            e.printStackTrace();        &#125;        return rst;    &#125;    //查询并以链表形式返回结果    public ArrayList&lt;Object&gt; execQueryList(String sql, Object[] data)    &#123;        int colCount = 0;        ResultSetMetaData rstmd = null;        rst = execQuery(sql, data);        try &#123;            rstmd = rst.getMetaData();            colCount = rstmd.getColumnCount();        &#125; catch (SQLException e) &#123;            e.printStackTrace();        &#125;        ArrayList&lt;Object&gt; list = new ArrayList&lt;Object&gt;();        try &#123;            while(rst.next())            &#123;                Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();                for(int i=1; i&lt;=colCount; i++)                &#123;                    /*                        getColumnLabel获取用于打印输出和显示的指定列的建议标                        getColumnName获取指定列的名称                        select的结果集返回的是Label                        所以此处只能用Label而不能用Name                    */                    map.put(rstmd.getColumnLabel(i), rst.getObject(i));                &#125;                list.add(map);            &#125;        &#125; catch (SQLException e) &#123;            e.printStackTrace();        &#125; finally &#123;            try &#123;                stmt.close();                rst.close();            &#125; catch (SQLException e) &#123;                e.printStackTrace();            &#125;        &#125;        return list;    &#125;    public static void main(String argc[])    &#123;        DBUtil db = DBUtil.getInstance();        Object[] data = &#123;&#125;;        db.execCommand(&quot;create table temp(id int, name char(100))&quot;);        db.execUpdate(&quot;insert into temp values(?, ?)&quot;, new Object[]&#123;1, &quot;aaa&quot;&#125;);        db.execUpdate(&quot;insert into temp values(?, ?)&quot;, new Object[]&#123;2, &quot;bbb&quot;&#125;);        db.execUpdate(&quot;insert into temp values(?, ?)&quot;, new Object[]&#123;3, &quot;ccc&quot;&#125;);        db.execUpdate(&quot;insert into temp values(?, ?)&quot;, new Object[]&#123;4, &quot;ddd&quot;&#125;);        ArrayList&lt;Object&gt; list = db.execQueryList(&quot;select * from temp where id &gt; ? and id &lt; ?&quot;, new Object[]&#123;1, 4&#125;);        for(Object it : list)        &#123;            Map&lt;String, Object&gt; map = (Map&lt;String, Object&gt;) it;            System.out.println(map.get(&quot;id&quot;) + &quot; -- &quot; + map.get(&quot;name&quot;));        &#125;    &#125;&#125;</code></pre><h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><blockquote><p>2 – bbb<br>3 – ccc</p></blockquote><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><h4 id="1-在从ResultSetMetaDate获取列名时，要使用getColumnLabel，而不能用getColumnName"><a href="#1-在从ResultSetMetaDate获取列名时，要使用getColumnLabel，而不能用getColumnName" class="headerlink" title="1. 在从ResultSetMetaDate获取列名时，要使用getColumnLabel，而不能用getColumnName:"></a>1. 在从ResultSetMetaDate获取列名时，要使用getColumnLabel，而不能用getColumnName:</h4><blockquote><p>原因在于：<br>getColumnLabel获取用于打印输出和显示的指定列的建议标<br>getColumnName获取指定列的名称<br>而select的结果集返回的是Label<br>所以此处只能用Label而不能用Name</p></blockquote><h4 id="2-在使用ResultSet之前不能关闭Statement，否则会出现SqlException："><a href="#2-在使用ResultSet之前不能关闭Statement，否则会出现SqlException：" class="headerlink" title="2. 在使用ResultSet之前不能关闭Statement，否则会出现SqlException："></a>2. 在使用ResultSet之前不能关闭Statement，否则会出现SqlException：</h4><blockquote><p>java.sql.SQLException: Operation not allowed after ResultSet closed</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mysql查询重复数据并按条件删除重复行</title>
    <link href="/posts/3962.html"/>
    <url>/posts/3962.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>在对游戏进行合区的过程中, 存在一个情况,<br>那就是当一个账号在两个区都存在角色的时候, 需要按照条件对重复角色进行删除,<br>比如以等级为条件, 只保留等级高的.</p></blockquote><hr><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>用mysql语句, 两条就可以解决:</p><blockquote><p>首先, 第一条语句</p></blockquote><pre><code class="hljs">create temporary table temp asselect user_id,max(level) as MAXIDfrom user group by open_id;这一句是将表user里面的数据按open_id进行分组,然后查询每组里等级最大的行的user_id,level两个字段,将查询结果存在一个临时表temp里面.</code></pre><blockquote><p>第二条语句</p></blockquote><pre><code class="hljs">delete from user where user_id not in(select user_id from temp);将user表里,没有存入temp表的user_id字段所在行删掉.</code></pre><hr><h4 id="这部分内容添加于9-2日晚———————-begin"><a href="#这部分内容添加于9-2日晚———————-begin" class="headerlink" title="这部分内容添加于9.2日晚———————-begin"></a>这部分内容添加于9.2日晚———————-begin</h4><blockquote><p>刚刚测试发现, 上面两条命令存在一定的问题, 原因很简单,<br>第一条语句存入temp的user_id<br>并不一定就是max(level)所在行的user_id.</p></blockquote><hr><p>那么我用了另一种方式来解决, 三条命令:</p><pre><code class="hljs">1.   create temporary table temp1 as select level, user_id, open_id from user order by level;    将user表的三项字段存入临时表temp1, 以level进行排序.2.   create temporary table temp2 as select user_id, level, open_id from temp1 group by open_id having count(open_id) &gt; 1;按open_id分组, 将分组后有重复数据的组的首个数据存入临时表temp2,因为默认以level排序, 所以存入的是有重复项的低等级玩家id.delete from user where user_id in (select user_id from temp2);删除啦!</code></pre><h4 id="————————————————end"><a href="#————————————————end" class="headerlink" title="————————————————end"></a>————————————————end</h4><h3 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h3><blockquote><p>有的小伙伴在执行第一条命令时可能会报下面的错误</p></blockquote><pre><code class="hljs">ERROR 1055 (42000): Expression #1 of SELECTlist is not in GROUP BY clause and contains nonaggregatedcolumn &#39;d1.user.user_id&#39; which is not functionallydependent on columns in GROUP BY clause;this is incompatible with sql_mode=only_full_group_by</code></pre><blockquote><p>那是因为mysql默认的设置要求,<br>group By后查询的列必须存在于group by后的字段集中,<br>修改设置即可, 在mysql命令行执行下面语句</p></blockquote><pre><code class="hljs">set @@sql_mode=&#39;STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION&#39;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>游戏开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java程序操作命令行</title>
    <link href="/posts/25065.html"/>
    <url>/posts/25065.html</url>
    
    <content type="html"><![CDATA[<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><blockquote><p>在写java项目时, 有些特殊情况下需要用到操作命令行, 以前用过好几次, 都是用的时候从网上找, 用完又忘记, 用一次找一次,<br>所以这次干脆将其保存在这里.</p></blockquote><pre><code class="hljs">/** * Created by shiyi on 16/8/30. */import java.io.BufferedReader;import java.io.InputStreamReader;public class Command &#123;    public static void exeCmd(String commandStr) &#123;        BufferedReader br = null;        try &#123;            Process p = Runtime.getRuntime().exec(commandStr);            br = new BufferedReader(new InputStreamReader(p.getInputStream()));            String line = null;            StringBuilder sb = new StringBuilder();            while ((line = br.readLine()) != null) &#123;                sb.append(line + &quot;\n&quot;);            &#125;            System.out.println(sb.toString());        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;        finally        &#123;            if (br != null)            &#123;                try &#123;                    br.close();                &#125; catch (Exception e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;    &#125;    public static void main(String[] args) &#123;        String commandStr = &quot;ping www.taobao.com&quot;;        Command.exeCmd(commandStr);    &#125;&#125;</code></pre><blockquote><p>命令行执行主要是对Runtime.getRuntime().exec()这个函数进行调用, 上述代码对其进行了封装, 作为一个类,<br>在执行完命令后同时会将终端返回结果给输出出来.</p></blockquote><h2 id="特殊点"><a href="#特殊点" class="headerlink" title="特殊点"></a>特殊点</h2><blockquote><p>今天使用命令行的目的是在java程序里对数据库进行备份, 也就是对mysqldump进行使用, 但是程序运行后, 并没有预期的执行结果.<br>查了资料后知道java操作命令不能支持管道操作, 而mysqldump的使用中恰恰用到了管道.<br>这种方法的解决方案很简单, 就是先将要操作的命令存为脚本,<br>linux- x.sh window- x.bat 再在exec里开始执行脚本的命令,<br>linux- sh x.sh window- x.bat<br>就可以绕过管道的问题.</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>步步为营-墙棋AI人机对战(Android)</title>
    <link href="/posts/41280.html"/>
    <url>/posts/41280.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>放纵了三天了，之前写了一半懒得去动的墙棋，反而在这几天间隙断断续续完成了，也是挺可笑的。</p></blockquote><h2 id="简介-关于墙棋"><a href="#简介-关于墙棋" class="headerlink" title="简介-关于墙棋"></a>简介-关于墙棋</h2><blockquote><p>路墙棋（Quoridor），或译墙棋、步步为营，是由Mirko Marchesi（米尔科·迈凯西）设计、Gigamic<br>Games发行的两到四人对战的棋类游戏(桌面游戏)，并在1997年被门萨国际评选为门萨推荐的游戏。1998年游戏杂志（Games<br>Magazine）年度游戏大奖。</p></blockquote><blockquote></blockquote><blockquote><p>先将各棋子放置在棋盘各边的中间格。两人玩时，两子需放在相对侧。<br>轮到回合的玩家，须作以下两动作之一：<br>动子：移动至邻边四格之一。若有其他玩家的棋子相邻，则可跳过后者至后方格，但不能一次跳过两子以上的棋子。若跳过的棋子后方为木板，则可以跳至后者左方或右方。棋子<br>不可穿过墙。<br>放墙：放木片至沟槽，需正对棋格边，也不可把棋子完全围住以至不能到达对边[2]。在游戏结束前，所有已被放置的木片不能再次移动或拿回。<br>以本方棋子先抵达对边为胜。<br>(cp于维基百科)</p></blockquote><h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h2><p><img src="http://img.blog.csdn.net/20160801191321219" alt="这里写图片描述"></p><p><img src="http://img.blog.csdn.net/20160801191336969" alt="这里写图片描述"></p><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><blockquote><p>GameView 游戏界面绘图部分<br>GameService 游戏逻辑部分<br>Robot AI部分<br>。。。 android项目的部分结构</p></blockquote><h2 id="GameService"><a href="#GameService" class="headerlink" title="GameService"></a>GameService</h2><p>** 游戏逻辑部分主要负责： **</p><ol><li><p>游戏信息：<br>如玩家(电脑)的位置坐标，所剩墙的数量，已放墙的位置，游戏是否结束等等。</p></li><li><p>游戏规则<br>这是比较棘手的一部分，首先来说走棋，有 ** 当对方棋子与自己相邻时、当旁边有墙时等等情况，不同情况下，可走的目标点不同 ** 。所以我实现了一个函数直接<br>** 根据目标位置自身位置、对方位置、棋盘信息来判断走法是否合法 ** 来解决。<br>再来说放墙，这个游戏之所以这么吸引人，最大的亮点在于墙，而墙的存在的一个很大的前提是 ** 不能将对方用墙堵死，也就是说放的墙不能令对方无法到达对面 **<br>。所以每次放墙的时候都要进行判断，确定墙放的位置是否合法。这个问题我解决的方案是， **<br>每次放墙时，先假设墙合法更新棋盘信息，然后使用A*来计算双方棋子到达对面所花的最小步数，若无法到达，则返回-1，即放墙操作不合法 ** 。</p></li></ol><h3 id="类的结构"><a href="#类的结构" class="headerlink" title="类的结构"></a>类的结构</h3><pre><code class="hljs">public class GameService&#123;    //玩家棋子位置    private int playerX;    private int playerY;    //电脑棋子位置    private int robotX;    private int robotY;    //玩家墙数量    public int playerWallCnt;    //电脑墙数量    public int robotWallCnt;    //储存棋盘信息    public boolean[][] boardA = new boolean[10][10];    public boolean[][] boardB = new boolean[10][10];    //标记游戏是否结束及胜方是电脑还是玩家    public int isEnd;    //AI    public Robot robot;    //判断走棋是否合法    public boolean isChessMan(int x, int y, int userMeX, int userMeY, int otherX, int otherY) &#123;    //走棋    public boolean putChessMan(boolean flag, int x, int y);    //放墙A    public boolean putWallA(boolean flag, int x, int y);    //放墙B    public boolean putWallB(boolean flag, int x, int y);    //判断墙是否合法    public boolean isCanGo();    //判断玩家是否可以到达终点    int a_start(boolean flag);</code></pre><h2 id="GameView"><a href="#GameView" class="headerlink" title="GameView"></a>GameView</h2><blockquote><p>这一部分是花费时间最多的部分，之前写五子棋时界面显示部分几乎不到一小时就完成了，而这个界面完成的时间是五子棋的好多倍。<br>原因很简单，五子棋的棋盘绘制时，确定棋盘的左上角，然后根据行列值直接就能确定到在何处绘制棋子。<br>而墙棋的棋盘中间的空隙要用于放墙，数值就比较繁琐，而且为了 ** 令项目可以根据不同屏幕自适应，所有的数值都是根据屏幕参数按比例动态计算而来 **<br>，写的时候很让人烦心。<br>还有一个难点(对我来说)是放墙的操作，因为要让用户用手指可以将墙拖动到目标位置，在此同时，还要根据拖动的位置模糊匹配相邻的沟槽。因为android方面实在是<br>半桶水，这部分实现起来还是挺麻烦的。</p></blockquote><h3 id="类的结构-1"><a href="#类的结构-1" class="headerlink" title="类的结构"></a>类的结构</h3><pre><code class="hljs">/** * Created by shiyi on 16/7/3. */public class GameView extends View &#123;    //游戏逻辑层    private GameService gameService;    //定义画笔    private Paint paint;    //屏幕尺寸    private int screenWidth;    private int screenHeight;    //棋盘格子尺寸    private float d;    private float e;    //棋盘绘制起点    private float startX;    private float startY;    //墙体绘制起点    private float startAX;    private float startAY;    private float startBX;    private float startBY;    //是否放墙    private boolean isWallA;    private boolean isWallB;    //是否走棋    private boolean isGo;    //触摸位置    private int lastX;    private int lastY;    private int wallX;    private int wallY;    //触摸坐标    private float nowX;    private float nowY;    //初始化控件坐标以及定义触屏事件监听函数    public GameView(Context context, AttributeSet attrs);    //重绘函数    @Override    protected void onDraw(Canvas canvas);    //绘制墙数量信息    public void drawWallMess(Canvas canvas);    //绘制棋子    public void drawChessMan(Canvas canvas, int color, int x, int y);    //绘制地图中的墙    public void drawWall(Canvas canvas);    //绘制横墙    public void drawWallA(Canvas canvas, int x, int y);    //绘制竖墙    public void drawWallB(Canvas canvas, int x, int y);    //绘制棋盘    public void drawChess(Canvas canvas);</code></pre><h2 id="Robot"><a href="#Robot" class="headerlink" title="Robot"></a>Robot</h2><pre><code class="hljs">本部分只有个alpha_beta剪枝函数，就不贴类结构了</code></pre><blockquote><p>AI部分应该算是人机对战的灵魂所在。<br>我仍然是使用alpha_beta剪枝搜索加上评估函数来确定走法。<br>关于alpha_beta剪枝搜索这里不再赘述，有兴趣的可以看这篇文章。 <a href="http://blog.csdn.net/to_be_better/article/details/50464320"> Alpha-Beta搜索</a><br>评估函数部分，我只用了简单的A*来求出棋子到达对面所需的最小步数，通过玩家与AI的评估值相减后的结果来作为局面评估值。<br>事实上这样做并不好，例如，如果一方一味的用墙来围堵对方，那么当它墙用光后且堵的效果并不好的话，几乎已经注定了它会输。<br>尝试了将剩余墙数联系到评估值中，但是效果并不好。<br>而且 ** 偶尔会出现AI棋子左右循环移动的情况，调试多次找不出原因，若有知晓原因的人看到，还望不吝告之 ** 。<br>能力有限，AI部分实现的效果一般般，只能日后再说了。</p></blockquote><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><blockquote><p>因为代码篇幅过多，已上传至git，有兴趣的可以去看。 <a href="https://github.com/shiyi1996/game/tree/master/Quoridor"> 墙棋AI人机对战app</a><br>apk文件还没有进行真机测试，因为之前安装过的问题，可能是卸载不彻底的问题，再安装时总显示替换安装，但又无法替换，因为之前的已经卸载了，总之好乱好乱，等解决<br>了，再在此处更新链接吧。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>游戏开发</tag>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cocos2dx实现简单卡牌翻转效果</title>
    <link href="/posts/25241.html"/>
    <url>/posts/25241.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>将两张图片放入图层，将其中一个图片x的比例设置为0，即隐藏起来。<br>分别给两个图片绑定点击监听事件，事件触发后执行缩放动作。将自身x比例设置为0，完成后将另一张图片x比例设置为1。<br>详见代码注释。</p></blockquote><pre><code class="hljs">bool HelloWorld::init()&#123;    //////////////////////////////    // 1. super init first    if ( !Layer::init() )    &#123;        return false;    &#125;    auto visibleSize = Director::getInstance()-&gt;getVisibleSize();    Vec2 origin = Director::getInstance()-&gt;getVisibleOrigin();    //使用两张图片分别创建精灵    auto logo1 = Sprite::create(&quot;up.jpg&quot;);    auto logo2 = Sprite::create(&quot;down.jpg&quot;);    //设置居中    logo1-&gt;setPosition(visibleSize/2);    logo2-&gt;setPosition(visibleSize/2);    //将第二张图片x轴缩放至隐藏    logo2-&gt;setScale(0, 1);    //加入图层    addChild(logo1);    addChild(logo2);    //创建监听器    auto touchListener1 = EventListenerTouchOneByOne::create();    //设置点击事件    touchListener1-&gt;onTouchBegan = [logo1, logo2](Touch* touch, Event* event)&#123;    //判断点击位置是否在精灵显示范围内        if(event-&gt;getCurrentTarget()-&gt;getBoundingBox().containsPoint(                        touch-&gt;getLocation()))        &#123;        //执行缩放动作            auto move1 = ScaleTo::create(1, 0, 1);            auto move2 = ScaleTo::create(1, 1, 1);            logo1-&gt;runAction(move1);            logo2-&gt;runAction(move2);        &#125;        return false;    &#125;;    //同上    auto touchListener2 = EventListenerTouchOneByOne::create();    touchListener2-&gt;onTouchBegan = [logo1, logo2](Touch* touch, Event* event)&#123;        if(event-&gt;getCurrentTarget()-&gt;getBoundingBox().containsPoint(                                                                     touch-&gt;getLocation()))        &#123;            auto move1 = ScaleTo::create(1, 0, 1);            auto move2 = ScaleTo::create(1, 1, 1);            logo2-&gt;runAction(move1);            logo1-&gt;runAction(move2);        &#125;        return false;    &#125;;    //分别将两个监听器与两个精灵绑定    Director::getInstance()-&gt;getEventDispatcher()-&gt;addEventListenerWithSceneGraphPriority(touchListener1, logo1);    Director::getInstance()-&gt;getEventDispatcher()-&gt;addEventListenerWithSceneGraphPriority(touchListener2, logo2);    return true;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Cocos2d-X开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cocos2dx源码阅读之万能的Value</title>
    <link href="/posts/55314.html"/>
    <url>/posts/55314.html</url>
    
    <content type="html"><![CDATA[<p>近日在学习cocos2dx引擎的使用时，阅读了某些常用的类的源码。在此进行总结。</p><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><pre><code class="hljs">版本：cocos2d-x-3.12语言：C++</code></pre><blockquote><p>在cocos2dx-3.x之前，存在着一些原生类型的封装类，如 CCBool, CCFloat, CCDouble,<br>CCinteger等，来完成对原生数据类型的封装，但在3.0版本出现之后，这些都被一个名叫Value的类替代了。</p></blockquote><blockquote></blockquote><blockquote><p>cocos2d::Value是一个模板容器类，完成了对很多数据类型的封装。如原生类型int, float, char, char*,<br>bool，以及string，map，vector等stl模板类。<br>Value极大的方便了cocos2dx工程里各种数据类型之间的转换。我们可以很同意的将不同数据类型转换为Value，反之亦然。</p></blockquote><h2 id="2-源码"><a href="#2-源码" class="headerlink" title="2.源码"></a>2.源码</h2><pre><code class="hljs">#include &lt;CCValue.h&gt;文件位置cocos2d-x-XXX/cocos/base/CCValue.h</code></pre><h3 id="2-1-成员变量"><a href="#2-1-成员变量" class="headerlink" title="2.1 成员变量"></a>2.1 成员变量</h3><pre><code class="hljs">class CC_DLL Value&#123;public:    //一个预定义的空值，暂时还不知道其作用    static const Value Null;   //枚举类，封装所有的数据类型名    enum class Type    &#123;        /// no value is wrapped, an empty Value        NONE = 0,        /// wrap byte        BYTE,        /// wrap integer        INTEGER,        /// wrap unsigned        UNSIGNED,        /// wrap float        FLOAT,        /// wrap double        DOUBLE,        /// wrap bool        BOOLEAN,        /// wrap string        STRING,        /// wrap vector        VECTOR,        /// wrap ValueMap        MAP,        /// wrap ValueMapIntKey        INT_KEY_MAP    &#125;;private:    //用共用体封装多种数据类型 保存Value的值，极大的节省了空间    union    &#123;        unsigned char byteVal;        int intVal;        unsigned int unsignedVal;        float floatVal;        double doubleVal;        bool boolVal;        std::string* strVal;        ValueVector* vectorVal;        ValueMap* mapVal;        ValueMapIntKey* intKeyMapVal;    &#125;_field;    //记录当前Value内保存的数据类型    Type _type;&#125;</code></pre><p>** 总结：Value用一个枚举类保存数据的类型，用一个共用体保存数据的值(极大的节省了空间)，用这两项完成对多种数据的保存。 **</p><h3 id="2-2-成员函数"><a href="#2-2-成员函数" class="headerlink" title="2.2 成员函数"></a>2.2 成员函数</h3><pre><code class="hljs">class CC_DLL Value&#123;public:    /***************************************    对多种类型均设置了构造函数，并用explicit设置其不可隐式转换，实现基本类型到Value类型的转换    ****************************************/    //构造函数    Value();    explicit Value(unsigned char v);    explicit Value(int v);    explicit Value(unsigned int v);    explicit Value(float v);    explicit Value(double v);    explicit Value(bool v);    explicit Value(const char* v);    explicit Value(const std::string&amp; v);    explicit Value(const ValueVector&amp; v);    explicit Value(ValueVector&amp;&amp; v);    explicit Value(const ValueMap&amp; v);    explicit Value(ValueMap&amp;&amp; v);    explicit Value(const ValueMapIntKey&amp; v);    explicit Value(ValueMapIntKey&amp;&amp; v);    //拷贝构造函数    Value(const Value&amp; other);    //移动构造函数    Value(Value&amp;&amp; other);    //析构函数    ~Value();    /***************************************    重载各种数据类型的=，!=, ==运算符,实现基本类型与Value类型的操作    ****************************************/    Value&amp; operator= (const Value&amp; other);    Value&amp; operator= (Value&amp;&amp; other);    Value&amp; operator= (unsigned char v);    Value&amp; operator= (int v);    Value&amp; operator= (unsigned int v);    Value&amp; operator= (float v);    Value&amp; operator= (double v);    Value&amp; operator= (bool v);    Value&amp; operator= (const char* v);    Value&amp; operator= (const std::string&amp; v);    Value&amp; operator= (const ValueVector&amp; v);    Value&amp; operator= (ValueVector&amp;&amp; v);    Value&amp; operator= (const ValueMap&amp; v);    Value&amp; operator= (ValueMap&amp;&amp; v);    Value&amp; operator= (const ValueMapIntKey&amp; v);    Value&amp; operator= (ValueMapIntKey&amp;&amp; v);    bool operator!= (const Value&amp; v);    bool operator!= (const Value&amp; v) const;    bool operator== (const Value&amp; v);    bool operator== (const Value&amp; v) const;    /***************************************        上面的构造函数，以及运算符重载都实现的是基本类型到Value类型的转换，那么下面众多asXXX函数实现了Value类型到基本类型的转换，两者结合才是真正实现了两者的互相转换    ****************************************/    unsigned char asByte() const;    int asInt() const;    unsigned int asUnsignedInt() const;    float asFloat() const;    double asDouble() const;    bool asBool() const;    std::string asString() const;    ValueVector&amp; asValueVector();    const ValueVector&amp; asValueVector() const;    ValueMap&amp; asValueMap();    const ValueMap&amp; asValueMap() const;    ValueMapIntKey&amp; asIntKeyMap();    const ValueMapIntKey&amp; asIntKeyMap() const;    //判断Value是否为空    //若类型为空则Value亦为空    inline bool isNull() const &#123; return _type == Type::NONE; &#125;    //获取Value类型    inline Type getType() const &#123; return _type; &#125;    //获取类的描述，作用于string，vector，map等类型    std::string getDescription() const;private:    //用于释放Value内变量的空间，会在析构函数里调用    void clear();    //重置Value并设置类型    void reset(Type type);&#125;;</code></pre><h3 id="2-3-详细分析"><a href="#2-3-详细分析" class="headerlink" title="2.3 详细分析"></a>2.3 详细分析</h3><h4 id="2-3-1构造函数"><a href="#2-3-1构造函数" class="headerlink" title="2.3.1构造函数"></a>2.3.1构造函数</h4><blockquote><p>以int，string为例，其他的都大同小异</p></blockquote><pre><code class="hljs">//很直观，直接进行了 类型_type和值_field两个成员变量的初始化Value::Value(int v): _type(Type::INTEGER)&#123;    _field.intVal = v;&#125;//相较于基本类型，多了一步开辟空间Value::Value(const std::string&amp; v): _type(Type::STRING)&#123;    _field.strVal = new (std::nothrow) std::string();    *_field.strVal = v;&#125;</code></pre><h4 id="2-3-2-析构函数"><a href="#2-3-2-析构函数" class="headerlink" title="2.3.2 析构函数"></a>2.3.2 析构函数</h4><pre><code class="hljs">Value::~Value()&#123;    clear();&#125;//析构函数仅调用了clear，下面说说clear函数void Value::clear()&#123;    // Free memory the old value allocated    switch (_type)    &#123;        //如果是基本类型，则直接对其值进行重置即可        case Type::BYTE:            _field.byteVal = 0;            break;        case Type::INTEGER:            _field.intVal = 0;            break;        //........省略部分内容        /*******************            如果是string等需要释放空间的对象，调用CC_SAFE_DELETE宏来进行处理。            #define CC_SAFE_DELETE(p)           do &#123; delete (p); (p) = nullptr; &#125; while(0)            该宏的功能很简单，释放指针指向的空间，并将指针置为空            *******************/        case Type::STRING:            CC_SAFE_DELETE(_field.strVal);            break;        case Type::VECTOR:            CC_SAFE_DELETE(_field.vectorVal);            break;        //........省略部分内容        default:            break;    &#125;    //将type重置    _type = Type::NONE;&#125;</code></pre><h4 id="2-3-3-Value转化函数asXXX"><a href="#2-3-3-Value转化函数asXXX" class="headerlink" title="2.3.3 Value转化函数asXXX"></a>2.3.3 Value转化函数asXXX</h4><pre><code class="hljs">同样，这里仅以asInt()为例int Value::asInt() const&#123;    //断言宏，如果条件表达式不符合，则中断程序并输出调试语句    CCASSERT(_type != Type::VECTOR &amp;&amp; _type != Type::MAP &amp;&amp; _type != Type::INT_KEY_MAP, &quot;Only base type (bool, string, float, double, int) could be converted&quot;);    //本身就是Int，直接返回    if (_type == Type::INTEGER)    &#123;        return _field.intVal;    &#125;    //根据不同的类型进行转换操作    if (_type == Type::UNSIGNED)    &#123;        CCASSERT(_field.unsignedVal &lt; INT_MAX, &quot;Can only convert values &lt; INT_MAX&quot;);        return (int)_field.unsignedVal;    &#125;    if (_type == Type::BYTE)    &#123;        return _field.byteVal;    &#125;    if (_type == Type::STRING)    &#123;        return atoi(_field.strVal-&gt;c_str());    &#125;    if (_type == Type::FLOAT)    &#123;        return static_cast&lt;int&gt;(_field.floatVal);    &#125;    if (_type == Type::DOUBLE)    &#123;        return static_cast&lt;int&gt;(_field.doubleVal);    &#125;    if (_type == Type::BOOLEAN)    &#123;        return _field.boolVal ? 1 : 0;    &#125;    //若进行到这一步，则表明type不是以上类型，则认为它不能与int进行转换，直接返回0    return 0;&#125;</code></pre><h4 id="2-3-4-reset重置函数"><a href="#2-3-4-reset重置函数" class="headerlink" title="2.3.4 reset重置函数"></a>2.3.4 reset重置函数</h4><pre><code class="hljs">//函数功能为将value重置为其他类型void Value::reset(Type type)&#123;    //如果类型相同，则操作完成    if (_type == type)        return;    //否则，先清除之前空间，然后根据不同类型对_field进行初始化    clear();    // Allocate memory for the new value    switch (type)    &#123;        case Type::STRING:            _field.strVal = new (std::nothrow) std::string();            break;        case Type::VECTOR:            _field.vectorVal = new (std::nothrow) ValueVector();            break;        case Type::MAP:            _field.mapVal = new (std::nothrow) ValueMap();            break;        case Type::INT_KEY_MAP:            _field.intKeyMapVal = new (std::nothrow) ValueMapIntKey();            break;        default:            break;    &#125;    //更改_type,重置操作完成    _type = type;&#125;</code></pre><h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h3><blockquote><p>看了源码，没有想象中的痛苦，反而带着一种享受，感慨人家的代码怎么可以写的那么好，那么条理清楚。<br>总结一下： ** Value类通过将所有数据类型都分化为 值 和类型 两部分，然后一系列操作都围绕着两部分，来实现Value与其封装类型之间的相互转换。其代<br>码实现并不难，但此设计思想实在是秒，尤其是将值使用共用体来表示，在完成需要的同时还节省了空间。 **</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Cocos2d-X开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>xcode7.3自动补全失效解决办法</title>
    <link href="/posts/64183.html"/>
    <url>/posts/64183.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>近日安装了cocos2dx环境，使用xcode作为ide进行开发，无奈xcode自动补全对于cocos的库失效，无法补全，百度了很久才找到一个方法，使用<br>有效，记录于此。</p></blockquote><pre><code class="hljs">1. 退出 Xcode2. 重启电脑3. 找到 这个 DerivedData 文件夹 删除 (路径: ~/Library/Developer/Xcode/DerivedData)4. 删除这个 com.apple.dt.Xcode 文件 (路径: ~/Library/Caches/com.apple.dt.Xcode)</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>xcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Web学习之简单验证码的实现(Servlet)</title>
    <link href="/posts/63605.html"/>
    <url>/posts/63605.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>刚刚进行完了接近两周时间的课设， 我们选择的是做一个web版的项目，而事实上整个团队之前都从没接触过web方面的知识，整个过程不可谓不煎熬。<br>从最初的一无所知到后面的初步能上手，有许多需要记录总结的知识，就从验证码开始吧。</p></blockquote><hr><blockquote><p>对于Web项目，验证码几乎是必备的，例如登陆功能就要用到，以防止恶意用户进行不断的登陆尝试。<br>那么验证码应该如何实现呢。<br>很简单，在后台，随机产生一串数字或文本，将其以图片形式展示在前端，再将用户输入的验证码内容与后台原本的内容进行对比来验证。</p></blockquote><h3 id="后台部分"><a href="#后台部分" class="headerlink" title="后台部分"></a>后台部分</h3><pre><code class="hljs">import *;//导入库部分省略@WebServlet(&quot;/image.show&quot;)public class Image extends HttpServlet&#123;    //随机产生一种颜色    Color getRandColor(int fc, int bc)    &#123;        Random random = new Random();        if(fc&gt;255) fc=255;        if(bc&gt;255) bc=255;        int r=fc+random.nextInt(bc-fc);        int g=fc+random.nextInt(bc-fc);        int b=fc+random.nextInt(bc-fc);        return new Color(r,g,b);    &#125;    public void doGet(HttpServletRequest req, HttpServletResponse response) throws ServletException, IOException &#123;        response.setHeader(&quot;Pragma&quot;, &quot;No-cache&quot;);        response.setHeader(&quot;Cache-Control&quot;, &quot;no-cache&quot;);        response.setDateHeader(&quot;Expires&quot;, 0);        //创建图像        int width = 60, height = 20;        BufferedImage image=new BufferedImage(width,height,BufferedImage.TYPE_INT_RGB);        //获取图形        Graphics g = image.getGraphics();        Random random = new Random();        g.setColor(getRandColor(200, 250));        g.fillRect(0, 0, width, height);        g.setFont(new Font(&quot;Times New Roman&quot;,Font.PLAIN,18));        g.setColor(getRandColor(160, 200));        //对图片进行模糊处理        for(int i=0;i&lt;155;i++)        &#123;            int x=random.nextInt(width);            int y=random.nextInt(height);            int x1=random.nextInt(12);            int y1=random.nextInt(12);            g.drawLine(x, y, x+x1, y+y1);        &#125;        //写入验证码        String sRand=&quot;&quot;;        for(int i=0; i&lt;4; i++)        &#123;            String rand=String.valueOf(random.nextInt(10));            sRand+=rand;            g.setColor(new Color(20+random.nextInt(110),20+random.nextInt(110),20+random.nextInt(110)));            g.drawString(rand, 13*i+6, 16);        &#125;        Check_num.check_num = sRand;//用一静态变量记录验证码，用以后面的验证        g.dispose();//释放图片资源        ImageIO.write(image, &quot;JPEG&quot;,response.getOutputStream());//将图片发送到前端    &#125;&#125;</code></pre><hr><h3 id="前端部分-很简单，向后台请求获取图片显示即可"><a href="#前端部分-很简单，向后台请求获取图片显示即可" class="headerlink" title="前端部分(很简单，向后台请求获取图片显示即可)"></a>前端部分(很简单，向后台请求获取图片显示即可)</h3><pre><code class="hljs">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;check&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;img src=&quot;image.show&quot;&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h3><p><img src="http://img.blog.csdn.net/20160623205624451" alt="这里写图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android学习笔记-TextView实现跑马灯效果</title>
    <link href="/posts/51960.html"/>
    <url>/posts/51960.html</url>
    
    <content type="html"><![CDATA[<h2 id="基本视图组件TextView"><a href="#基本视图组件TextView" class="headerlink" title="基本视图组件TextView"></a>基本视图组件TextView</h2><pre><code class="hljs">&lt;TextView    android:id=&quot;@+id/view1&quot;    android:layout_width=&quot;wrap_content&quot;    android:layout_height=&quot;wrap_content&quot;    android:text=&quot;我是一个TextView基本视图组件&quot;    android:textSize=&quot;28sp&quot;    android:textColor=&quot;#000000&quot;/&gt;</code></pre><blockquote><p>上述xml代码便可生成一个TextView，介绍一下这几个属性</p></blockquote><pre><code class="hljs">android:id : 设置组件idandroid:layout_width : 设置组件宽度android:layout_height : 设置组件高度android:text : 设置组件显示内容android:textSize : 设置组件字体大小android:textColor : 设置组件字体颜色</code></pre><blockquote><p>显示效果如下</p></blockquote><p><img src="http://img.blog.csdn.net/20160601201644088" alt="这里写图片描述"></p><blockquote><p>那如果我们加上</p></blockquote><pre><code class="hljs">android:signleLine=&quot;true&quot;</code></pre><blockquote><p>设置组件为单行显示，效果如下，可以发现，没能显示的内容被以省略号显示。</p></blockquote><p><img src="http://img.blog.csdn.net/20160601201834252" alt="这里写图片描述"></p><blockquote><p>那么，如果我们想要让它以跑马灯的形式滚动显示呢<br>加上下列属性</p></blockquote><pre><code class="hljs">android:focusable=&quot;true&quot;//允许获取焦点android:focusableInTouchMode=&quot;true&quot;//允许在非触摸模式下获取焦点android:ellipsize=&quot;marquee&quot;//当控件处在被选中状态下以跑马灯效果显示多余文字</code></pre><blockquote><p>效果如下</p></blockquote><p><img src="http://img.blog.csdn.net/20160601203549754" alt="这里写图片描述"></p><blockquote><p>那么，仅仅这样就可以了吗？我们尝试再添加一个相同的组件，看看会不会如我们预期的效果。</p></blockquote><p><img src="http://img.blog.csdn.net/20160601203809210" alt="这里写图片描述"></p><blockquote><p>如图所示，第二个TextView并没有我们预期的跑马灯效果。<br>原因在于，两个TextView想要以跑马灯效果显示的前提是必须获取焦点，而第一个TextView将焦点获取，导致第二个TextView没有焦点，所以出现我们<br>看到的情况。</p></blockquote><p>那么该如何解决呢，我们自定义一个TextView的子类</p><pre><code class="hljs">public class MyTextView extends TextView &#123;    public MyTextView(Context context, AttributeSet attrs) &#123;        super(context, attrs);    &#125;    public MyTextView(Context context, AttributeSet attrs, int defStyleAttr) &#123;        super(context, attrs, defStyleAttr);    &#125;    public MyTextView(Context context) &#123;        super(context);    &#125;    @Override    //是否已获取焦点    public boolean isFocused() &#123;        return true;    &#125;&#125;</code></pre><blockquote><p>可以看到，我们将isFocused强制每次都返回true，也就是说组件永远都处于已获取焦点的状态下。</p></blockquote><pre><code class="hljs">将&lt;TextView ... /&gt;修改为&lt;com.example.shiyi.demo1.MyTextView ... /&gt;，表示使用我们自定义的组件。</code></pre><blockquote><p>然后，再看效果</p></blockquote><p><img src="http://img.blog.csdn.net/20160601205148484" alt="这里写图片描述"></p><blockquote><p>两个TextView均以跑马灯效果显示了。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2016年Linux兴趣小组免试题Level_5及Level_End详解</title>
    <link href="/posts/18196.html"/>
    <url>/posts/18196.html</url>
    
    <content type="html"><![CDATA[<h2 id="level-5-1"><a href="#level-5-1" class="headerlink" title="level_5.1"></a>level_5.1</h2><h3 id="关卡链接：-level-5-1"><a href="#关卡链接：-level-5-1" class="headerlink" title="关卡链接：  level_5.1 "></a>关卡链接： <a href="http://115.159.53.185/shi.php"> level_5.1 </a></h3><p><img src="http://img.blog.csdn.net/20160429163042006" alt="这里写图片描述"></p><blockquote><p>本小关的目的是让大家了解规则。<br>本小关方格规模为3*3，左上角黄色格子为起点，右下角红色格子为重点，页面右侧有一数字，表示当前所累加的数字之和。通过几次尝试之后，可以发现， **<br>从左上角开始，我们可以按下方向键或者右方向键来移动方格，直到到达右下角终点格子，路径所累加的数字和若最大，则视为成功过关，否则失败重新来过。 **</p></blockquote><h2 id="level-5-2"><a href="#level-5-2" class="headerlink" title="level_5.2"></a>level_5.2</h2><h3 id="关卡链接：-level-5-2"><a href="#关卡链接：-level-5-2" class="headerlink" title="关卡链接：  level_5.2 "></a>关卡链接： <a href="http://115.159.53.185/fei.php"> level_5.2 </a></h3><p><img src="http://img.blog.csdn.net/20160429163125424" alt="这里写图片描述"></p><blockquote><p>上一小关是3<em>3，总共只有 C(2, 4)=6 种可能(因为需要向下移动2步，向右移动2步，一共4步，所以是C(2,<br>4))，我们很容易可以心算出正确的路径，但本关的规模是5</em>7，可能的路径数有C(4, 10)=210种，没有上一关那么容易了。<br>我们发现我们尝试的过程中，总会以当前位置附近的格子作为我们决定向右或者向下移动的选择依据，这实际上是一种贪心的思想。但是，贪心有它的局部最优性，即，对于我们<br>所参照的目标(当前位置附近的格子)，我们的选择是最优的，但对于从起点到终点即全部方格而言，它并不一定是最优的。<br>举个简单的例子，你可能会因为当前位置右边是30，下边是100，而选择向下移动，但如果30的右侧有很多100呢，你会因为之前的一次贪心，而错失了后面更好的选择<br>。<br>因为本小关规模也依旧不大，直接贪心思想尝试，成功的概率也是很大的，但有想法的同学应该可以意识到这种方法的错误的地方，从而进行思考，想到正确的解法。<br>这就是设立本小关的目的。</p></blockquote><h2 id="level-5-3"><a href="#level-5-3" class="headerlink" title="level_5.3"></a>level_5.3</h2><h3 id="关卡链接：-level-5-3"><a href="#关卡链接：-level-5-3" class="headerlink" title="关卡链接：  level_5.3 "></a>关卡链接： <a href="http://115.159.53.185/xuan.php"> level_5.3 </a></h3><p><img src="http://img.blog.csdn.net/20160429173020920" alt="这里写图片描述"></p><blockquote><p>本小关才是真正的重头戏了，我们将规模设置为了12<em>20，可能的方案数为C(11, 30)=54627300，它也依旧不算大(其实还想更大的，只是因为屏幕<br>有限)，所以我们将每个数字的范围由之前的0<del>100改为了280</del>320，这样，大家心算直接贪心成功的几率就变得很小很小了。<br>仔细想想，不难发现，对于每个格子而言，能到达它只有两种可能，就是上面和左边。<br>还是举个例子吧。<br>就拿3</em>3，来说，再大规模也是同理的。</p></blockquote><pre><code class="hljs">15 12 635 61 9553 22 58</code></pre><blockquote><p>我们要求从15到58的最大和路径。<br>那么对于58而言，它的上一步要么是22，要么是95，那么最大的路径肯定是15到22与95两者较大的那条。<br>那么如果我们得到下面两个图的结果，就可以得出我们想要的答案。</p></blockquote><pre><code class="hljs">15 12          15 12 635 61          35 61 9553 22</code></pre><blockquote><p>同理，他们两者依旧可以分解，直至1*1。<br>这样我们能够提取出一个公式，令a[i][j]表示第i行第j列方格的数值，令dp[i][j]表示从起点到第i行第j列位置所能获得的最大数值和。<br>则 dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + a[i][j];<br>递推式已得出，代码就很好写了。</p></blockquote><pre><code class="hljs">#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;const int N = 25;int dp[N][N];int a[N][N];char str[10000];int main()&#123;    printf(&quot;%s&quot;, str);    int len = strlen(str);    int row, col;    row = col = 0;    int num = 0;    //将方格数据转化为矩阵    for(int i=0; i&lt;len; i++)    &#123;        if(str[i] &gt;= &#39;0&#39; &amp;&amp; str[i] &lt;= &#39;9&#39;)        &#123;            num = num * 10 + str[i] - &#39;0&#39;;        &#125;        else if(i &gt; 0 &amp;&amp; str[i-1] &gt;= &#39;0&#39; &amp;&amp; str[i-1] &lt;= &#39;9&#39;)        &#123;            if(str[i] == &#39;]&#39;)            &#123;                a[row][col] = num;                num = 0;                if(str[i+1] != &#39;]&#39;)                &#123;                    col++;                    row = 0;                &#125;            &#125;            else if(str[i] == &#39;,&#39;)            &#123;                a[row][col] = num;                row++;                num = 0;            &#125;        &#125;    &#125;    //动态规划，按照转移方程，进行迭代    for(int i = 1; i &lt;= row; i++)        for(int j = 1; j &lt;= col; j++)            dp[i][j] = max(dp[i-1][j], dp[i][j-1])+a[i][j];    printf(&quot;ans = %d \n&quot;, dp[row][col]);    //逆推回来，得到路径    int i = row;    int j = col;    int k = 0;    while(i &gt;=1 &amp;&amp; j &gt;= 1)    &#123;        if(dp[i][j] == dp[i-1][j] + a[i][j])        &#123;            str[k++] = &#39;D&#39;;            i--;            continue;        &#125;        if(dp[i][j] == dp[i][j-1]+a[i][j])        &#123;            str[k++] = &#39;R&#39;;            j--;            continue;        &#125;    &#125;    printf(&quot;start : &quot;);    for(int p = k-2; p &gt;= 0; p--)        printf(&quot;%c &gt; &quot;, str[p]);    printf(&quot;end\n&quot;);    return 0;&#125;</code></pre><h2 id="level-End"><a href="#level-End" class="headerlink" title="level_End"></a>level_End</h2><h3 id="关卡链接：-level-End"><a href="#关卡链接：-level-End" class="headerlink" title="关卡链接：  level_End "></a>关卡链接： <a href="http://115.159.53.185/shiyears.php"> level_End </a></h3><p><img src="http://img.blog.csdn.net/20160429172948622" alt="这里写图片描述"></p><blockquote><p>免试题原本在5.3就应该要结束的，但因为做题的玩家(姑且叫玩家吧)，不止大一的小鲜肉，还有高年级的道友们，所以为了让大家玩得更愉快，临时增加了本关。<br>本关乍一看似乎和5.3没有什么区别，但当你使用5.3的方法去移动时，发现到了右下角并不会结束。如果你仔细尝试，才会发现现在方向键上和方向键左是可以按的了。也<br>就是说，现在我们要从左上角走到右下角再走回左上角，即走一个来回，两次路径的方格值总和最大即通过(重复经过的格子只计算一次)。<br>首先，我们可以将题意转化为从左上角以两条路径走到右下角，获得经过的方格数值总和。</p></blockquote><blockquote></blockquote><blockquote><p>那么，依照我们之前的那种思路，<br>我们令a[i][j]表示第i行第j列方格的数值，令dp[i][j][k][L]四维数组，表示第一条路径到达(i, j)，第二条路径到达(k,<br>L)所经过的方格数值总和最大值。那么显然，对于(i, j)来说，有两种可能即(i-1, j), (i, j-1)，同理(k, L)有两种可能(k-1,<br>L)和(k, L-1)，那么对于(i, j, k, L)就有4种可能性。<br>用转移方程描述就是</p></blockquote><pre><code class="hljs">dp[i][j][k][L] = max(                    dp[i-1][j][k-1][L],                    dp[i-1][j][k][L-1],                    dp[i][j-1][k-1][L],                    dp[i][j-1][k][L-1]                ) + (i != k || j != L) ? a[i][j]+a[k][L] : a[i][j];</code></pre><blockquote><p>讲到这里，我们来看代码吧。</p></blockquote><pre><code class="hljs">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;math.h&gt;#include &lt;cstdio&gt;using namespace std;const int N = 25;int dp[N][N][N][N];int a[N][N];int fa[2][N*N] = &#123;&#125;;char ans[2][100];char str[10000];int main()&#123;    cin&gt;&gt;str;    int len = strlen(str);    int row, col;    row = col = 0;    int num = 0;    //将方格数据转化为矩阵    for(int i=0; i&lt;len; i++)    &#123;        if(str[i] &gt;= &#39;0&#39; &amp;&amp; str[i] &lt;= &#39;9&#39;)        &#123;            num = num * 10 + str[i] - &#39;0&#39;;        &#125;        else if(i &gt; 0 &amp;&amp; str[i-1] &gt;= &#39;0&#39; &amp;&amp; str[i-1] &lt;= &#39;9&#39;)        &#123;            if(str[i] == &#39;]&#39;)            &#123;                a[row][col] = num;                num = 0;                if(str[i+1] != &#39;]&#39;)                &#123;                    col++;                    row = 0;                &#125;            &#125;            else if(str[i] == &#39;,&#39;)            &#123;                a[row][col] = num;                row++;                num = 0;            &#125;        &#125;    &#125;    int n = col;    //动态规划    for(int i=1; i&lt;=row; i++)        for(int j=1; j&lt;=col; j++)            for(int k=1; k&lt;=row; k++)                for(int l=1; l&lt;=col; l++)                &#123;                    int mx = 0;                    if(mx &lt; dp[i-1][j][k-1][l])                    &#123;                        mx = dp[i-1][j][k-1][l];                    &#125;                    if(mx &lt; dp[i-1][j][k][l-1])                    &#123;                        mx = dp[i-1][j][k][l-1];                    &#125;                    if(mx &lt; dp[i][j-1][k-1][l])                    &#123;                        mx = dp[i][j-1][k-1][l];                    &#125;                    if(mx &lt; dp[i][j-1][k][l-1])                    &#123;                        mx = dp[i][j-1][k][l-1];                    &#125;                    if(i == k &amp;&amp; j == l)                        dp[i][j][k][l] = mx + a[i][j];                    else                        dp[i][j][k][l] = mx + a[i][j] + a[k][l];                &#125;    cout&lt;&lt;&quot;the ans = &quot;&lt;&lt;dp[row][col][row][col]&lt;&lt;endl;    //逆推得到路径    int cnt = 0;    int i=row, j=col, k=row, l=col;    while(1)    &#123;        if(i == 1 &amp;&amp; j == 1 &amp;&amp; k == 1 &amp;&amp; l == 1)            break;        dp[i][j][k][l] -= a[i][j];        if(i != k || j != l)            dp[i][j][k][l] -= a[k][l];        if(dp[i][j][k][l] == dp[i-1][j][k-1][l])        &#123;            ans[0][cnt] = &#39;U&#39;;            ans[1][cnt] = &#39;D&#39;;            cnt++;            i--;k--;        &#125;        else if(dp[i][j][k][l] == dp[i-1][j][k][l-1])        &#123;            ans[0][cnt] = &#39;U&#39;;            ans[1][cnt] = &#39;R&#39;;            cnt++;            i--;l--;        &#125;        else if(dp[i][j][k][l] == dp[i][j-1][k-1][l])        &#123;            ans[0][cnt] = &#39;L&#39;;            ans[1][cnt] = &#39;D&#39;;            cnt++;            j--;k--;        &#125;        else        &#123;            ans[0][cnt] = &#39;L&#39;;            ans[1][cnt] = &#39;R&#39;;            cnt++;            j--;l--;        &#125;    &#125;    //输出路径    cout&lt;&lt;&quot;load_one &gt; &quot;;    for(int i=0; i&lt;cnt; i++)        cout&lt;&lt;ans[0][i]&lt;&lt;&quot; &gt; &quot;;    cout&lt;&lt;&quot;end&quot;&lt;&lt;endl;    cout&lt;&lt;&quot;load_two &gt; &quot;;    for(int i=cnt-1; i&gt;=0; i--)        cout&lt;&lt;ans[1][i]&lt;&lt;&quot; &gt; &quot;;    cout&lt;&lt;&quot;end&quot;&lt;&lt;endl;    return 0;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ZOJ Highway Project(dijkstra&amp;heap&amp;邻接表)</title>
    <link href="/posts/18231.html"/>
    <url>/posts/18231.html</url>
    
    <content type="html"><![CDATA[<p>题目链接： <a href="http://acm.zju.edu.cn/onlinejudge/showContestProblem.do?problemId=5706"> 146 - The 13th Zhejiang Provincial Collegiate Programming Contest - K<br>Highway Project</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><blockquote><p>有n个城市，0是首都，其他编号为1~n-1。<br>给定m条可以修建的道路，xi, yi, di, ci。表示从x到y需要di秒时间，并且该路需要花费ci$。<br>现在国王想要一个修建方案，使得他从首都到其他城市花费时间最少，在多种方案花费时间相等的情况下，修建道路所花费的钱最少。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><blockquote><p>显然，是一个最短路问题。但是题目的数据范围很大，n最大是100000。矩阵是开不了了，只能邻接表。<br>用了邻接表后，提交发现超时，于是改用优先队列优化，方过。<br>思路上没什么可说的，就是写起来麻烦些。</p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="hljs">#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstdlib&gt;#include &lt;string&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;using namespace std;#define LL long longconst int N = 100009;int head[N];struct Node&#123;    LL u, v, d, c, next;&#125;e[N*2];bool vis[N];struct P&#123;    LL i, d, c;    bool operator &lt;(const P &amp;t) const    &#123;        if(this-&gt;d == t.d)            return this-&gt;c &gt; t.c;        return this-&gt;d &gt; t.d;    &#125;&#125;;P dis[N];void dijk(int n)&#123;    memset(vis, 0, sizeof(vis));    memset(dis, 0x3f, sizeof(dis));    priority_queue&lt;P&gt; q;    P s = &#123;0, 0, 0&#125;;    q.push(s);    LL d, c;    d = c = 0;    while(!q.empty())    &#123;        P mi = q.top();        q.pop();        if(vis[mi.i])            continue;        vis[mi.i] = 1;        d += mi.d;        c += mi.c;        for(LL i=head[mi.i]; i!=-1; i=e[i].next)        &#123;            LL v = e[i].v;            if(vis[v])                continue;            if(mi.d+e[i].d &lt; dis[v].d)            &#123;                dis[v].d = mi.d+e[i].d;                dis[v].c = e[i].c;                dis[v].i = v;                q.push(dis[v]);            &#125;            else if(mi.d+e[i].d == dis[v].d &amp;&amp; e[i].c &lt; dis[v].c)            &#123;                dis[v].c = e[i].c;                dis[v].i = v;                q.push(dis[v]);            &#125;        &#125;    &#125;    printf(&quot;%lld %lld\n&quot;, d, c);&#125;int main()&#123;    int T;    cin&gt;&gt;T;    while(T--)    &#123;        memset(head, -1, sizeof(head));        int n, m;        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);        int pos = 0;        for(int i=0; i&lt;m; i++)        &#123;            int a, b, c, d;            scanf(&quot;%d%d%d%d&quot;, &amp;a, &amp;b, &amp;d, &amp;c);            e[pos].u = a;e[pos].v = b;e[pos].d = d; e[pos].c = c;            e[pos].next = head[e[pos].u];            head[e[pos].u] = pos;            pos++;            e[pos].u = b;e[pos].v = a;e[pos].d = d; e[pos].c = c;            e[pos].next = head[e[pos].u];            head[e[pos].u] = pos;            pos++;        &#125;        dijk(n);    &#125;    return 0;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>最短路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BestCoder Round</title>
    <link href="/posts/10073.html"/>
    <url>/posts/10073.html</url>
    
    <content type="html"><![CDATA[<p>** 题目链接 ** ： <a href="http://bestcoder.hdu.edu.cn/contests/contest_chineseproblem.php?cid=691&pid=1003"> BestCoder Round #81 (div.2) 1003 String </a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><blockquote><p>中文题，上有链接，就不贴了。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><blockquote><p>枚举起点i，计算可以达到k个不同字母的最小下标j，则此时有子串len-j个。<br>将所有起点的值加起来即是结果。</p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="hljs">#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std;#define LL long longconst int MOD = 1000000007;char str[1000009];int num[27];int get_cnt()&#123;    int cnt = 0;    for(int i=0; i&lt;26; i++)        cnt += num[i]==0?0:1;    return cnt;&#125;int main()&#123;    int T;    cin&gt;&gt;T;    while(T--)    &#123;        int k;        memset(num, 0, sizeof(num));        scanf(&quot;%s%d&quot;, str, &amp;k);        int len = strlen(str);        LL ans = 0;        int j = -1;        bool flag = false;        for(int i=0; i&lt;len; i++)        &#123;            while(get_cnt() &lt; k)            &#123;                j++;                if(j == len)                &#123;                    flag = true;                    break;                &#125;                num[str[j]-&#39;a&#39;]++;            &#125;            if(flag)                break;            ans += len-j;            num[str[i]-&#39;a&#39;]--;        &#125;        printf(&quot;%lld\n&quot;, ans);    &#125;    return 0;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BestCoder Round</title>
    <link href="/posts/10071.html"/>
    <url>/posts/10071.html</url>
    
    <content type="html"><![CDATA[<p>** 题目链接 ** ： <a href="http://bestcoder.hdu.edu.cn/contests/contest_chineseproblem.php?cid=691&pid=1002"> BestCoder Round #81 (div.2) 1002 Matrix </a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><blockquote><p>中文题，上有链接，就不贴了。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><blockquote><p>我们至少可以确定一点，无论怎么移动，在一行的数字，最终还是会在一行，在一列的数字，最终还是会在一列，无论怎么交换。<br>因为交换总是以整个行或者整个列为单位进行的。<br>确定了这个道理，我们可以用数组模拟指针指向。<br>用a[i] = x表示当前第i行实际是第x行。ac[i] =<br>num表示第i行整体增加了num。交换某行的时候，只需要交换其a数组,ac数组的对应值就好了，复杂度就降到了O(1)。<br>列的话同理，最后输出的时候按照行列新的指向来输出就好了。</p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="hljs">#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std;#define LL long longint d[1009][1009];int a[1009], ac[1009];int b[1009], bc[1009];int main()&#123;    int T;    cin&gt;&gt;T;    for(int i=0; i&lt;T; i++)    &#123;        int n, m, q;        memset(ac, 0, sizeof(ac));        memset(bc, 0, sizeof(bc));        scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;q);        for(int i=1; i&lt;=n; i++)            for(int j=1; j&lt;=m; j++)                scanf(&quot;%d&quot;, &amp;d[i][j]);        for(int i=1; i&lt;=n; i++)            a[i] = i;        for(int j=1; j&lt;=m; j++)            b[j] = j;        while(q--)        &#123;            int t, x, y;            scanf(&quot;%d%d%d&quot;, &amp;t, &amp;x, &amp;y);            if(t == 1)            &#123;                swap(a[x], a[y]);                swap(ac[x], ac[y]);            &#125;            else if(t == 2)            &#123;                swap(b[x], b[y]);                swap(bc[x], bc[y]);            &#125;            else if(t == 3)                ac[x] += y;            else                bc[x] += y;        &#125;        for(int i=1; i&lt;=n; i++)        &#123;            for(int j=1; j&lt;=m; j++)            &#123;                printf(&quot;%d&quot;, d[a[i]][b[j]]+ac[i]+bc[j]);                if(j != m)                    printf(&quot; &quot;);            &#125;            printf(&quot;\n&quot;);        &#125;    &#125;    return 0;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>思路题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BestCoder Round</title>
    <link href="/posts/10072.html"/>
    <url>/posts/10072.html</url>
    
    <content type="html"><![CDATA[<p>** 题目链接 ** ： <a href="http://bestcoder.hdu.edu.cn/contests/contest_chineseproblem.php?cid=691&pid=1001"> BestCoder Round #81 (div.2) 1001 Machine </a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><blockquote><p>中文题，上有链接，就不贴了。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><blockquote><p>显然，最后一个灯会变化n次，倒数第二个灯会变化n/3次，依次类推。<br>那么每个灯的变化次数 可以看做是 实际变化次数%3。</p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="hljs">#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std;#define LL long longint main()&#123;    int T;    cin&gt;&gt;T;    while(T--)    &#123;        int m;        LL n;        int d[39], a = 3;        cin&gt;&gt;m&gt;&gt;n;        for(int i=m; i&gt;=1; i--)        &#123;            d[i] = n%3;            n /= 3;        &#125;        for(int i=1; i&lt;=m; i++)        &#123;            if(d[i] == 0)                cout&lt;&lt;&quot;R&quot;;            else if(d[i] == 1)                cout&lt;&lt;&quot;G&quot;;            else                cout&lt;&lt;&quot;B&quot;;        &#125;        cout&lt;&lt;endl;    &#125;    return 0;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>思路题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>初学遗传算法解决tsp问题(C++)</title>
    <link href="/posts/30599.html"/>
    <url>/posts/30599.html</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>断断续续学遗传到现在快一个礼拜了，之前一直在看思想，死想活想，始终不敢去自己代码实现。<br>今天硬着头皮开始写，写不下去就找博文看，总算是初步的实现了，迈出了智能算法学习的第一小步，心情不可谓不激动。<br>好吧，说正经的。</p></blockquote><h2 id="tsp-amp-旅行商问题"><a href="#tsp-amp-旅行商问题" class="headerlink" title="tsp&amp;旅行商问题"></a>tsp&amp;旅行商问题</h2><blockquote><p>旅行商问题，即TSP问题（Traveling Salesman Problem）是数学领域中著名问题之一。<br>** 假设有一个旅行商人要拜访N个城市，他必须选择所要走的路径，路径的限制是 _ 每个城市只能拜访一次 _ ，而且最后要回到原来出发的城市。 **<br>** 路径的选择目标是要求得的路径路程为所有路径之中的最小值。 **</p></blockquote><h2 id="遗传算法"><a href="#遗传算法" class="headerlink" title="遗传算法"></a>遗传算法</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><blockquote><p>从遗传两个字，不难想到，这个算法是由生物进化的机理所抽象出来的一种思想。<br>对于一个问题，有许多可能的解。<br>就拿上述的tsp问题来说吧，每一种遍历顺序都是一个解。所有城市顺序的全排列合在一起就是这个问题的解集。<br>** 我们将每个解都看做一个个体。那么多个个体放在一起就可以构成一个种群。 **<br>大自然每个种群都要经过漫长的自然选择，也就是优胜劣汰，以及繁殖和变异。<br>而解所构成的种群也不例外。<br>显然，我们可以很明确的 ** 对每个个体的优劣性进行评价 ** 。本体的条件是总路程最短，根据解得到总路程的大小是很容易的。<br>评价过后，对于每个个体的优劣我们都已掌握。<br>那么残酷的地方来了，我们要 ** 杀死(淘汰) ** 一部分个体。<br>当然也不能光杀，温馨的部分也是有的，那就是两两个体 ** 交叉繁殖 ** ，产生后代。<br>除此之外，还要有一点幸运度，那就是 ** 变异 ** 了，随机的对某些个体进行一些改变。<br>上述操作进行完之后，我们已经相当于更新了整个群体。<br>然后重复的进行此过程，直到得到满意的(个体)结果。</p></blockquote><p>** 上述内容总结一下，就是下图。 **<br><img src="http://img.blog.csdn.net/20160419151241489" alt="这里写图片描述"></p><h3 id="交叉方式与变异方式"><a href="#交叉方式与变异方式" class="headerlink" title="交叉方式与变异方式"></a>交叉方式与变异方式</h3><blockquote><p>交叉方式有很多种，对于不同的问题，交叉方式的不同对于求解会有一定的影响。<br>变异同理。<br>这里只介绍我所用的方式。其实也是最普通最常用的方式。</p></blockquote><h4 id="交叉方式"><a href="#交叉方式" class="headerlink" title="交叉方式"></a>交叉方式</h4><pre><code class="hljs">父个体：1 2 3 4 9 8 7 6 5 0母个体：7 8 9 0 1 6 5 4 3 2那么随机取两个值，比如：4和6将父个体划分：1 2 3 [4 9] 8 7 6 5 0则，将划分区间内的基因赋给子个体子个体：x x x 4 9 x x x x x再按照母个体的基因顺序赋值给子个体子个体：7 8 0 4 9 1 6 5 3 2</code></pre><h4 id="变异方式"><a href="#变异方式" class="headerlink" title="变异方式"></a>变异方式</h4><pre><code class="hljs">个体：  1 2 3 4 9 8 7 6 5 0还是随机选取两个值，比如：4和6那么，交换位置4和位置6的基因。新个体：1 2 3 8 9 4 7 6 5 0</code></pre><h2 id="程序效果"><a href="#程序效果" class="headerlink" title="程序效果"></a>程序效果</h2><p><img src="http://img.blog.csdn.net/20160419145501214" alt="这里写图片描述"></p><blockquote><p>** 可以看到，20次求解有14次得到了最优解，在牺牲了一定最优性的情况下，换取了程序快速得解的能力。 **</p></blockquote><h2 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h2><blockquote><p>因为是第一次写，交叉和变异都用了最常用也是最简单的方式。<br>** 对于同一个问题，使用不同的交叉方式和变异方式，效果会有很大不同。还有种群个体数量以及进化迭代次数，变异概率等等参数的不同取值，都会有影响。 **<br>而这些只有不停的实践，才可以真正掌握一定经验。长路漫漫，吾往矣！</p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="hljs">#include &lt;iostream&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;const int city_num = 10;//城市数量const int unit_num = 100;//群体规模int ps = 10;//变异概率const int genmax = 500;//最大迭代数//城市间距离映射 最优解权值=10int length_table[10][10] = &#123;    &#123;0,1,1272,2567,1653,2097,1425,1177,3947,1&#125;,    &#123;1,0,1,2511,1633,2077,1369,1157,3961,1518&#125;,    &#123;1272,1,0,1,380,1490,821,856,3660,385&#125;,    &#123;2567,2511,1,0,1,2335,1562,2165,3995,933&#125;,    &#123;1653,1633,380,1,0,1,1041,1135,3870,456&#125;,    &#123;2097,2077,1490,2335,1,0,1,920,2170,1920&#125;,    &#123;1425,1369,821,1562,1041,1,0,1,4290,626&#125;,    &#123;1177,1157,856,2165,1135,920,1,0,1,1290&#125;,    &#123;3947,3961,3660,3995,3870,2170,4290,1,0,1&#125;,    &#123;1,1518,385,993,456,1920,626,1290,1,0&#125;&#125;;class Unit&#123;public:    int path[city_num];//个体的路径信息    int length;//个体价值&#125;;class Group&#123;public:    Unit group[unit_num];    Unit best;    int best_gen;    Group()    &#123;        best.length = 0x3f3f3f3f;        best_gen = 0;        for(int i = 0; i &lt; unit_num; i++)        &#123;            bool flag[city_num] = &#123;&#125;;            for(int j = 0; j &lt; city_num; j++)            &#123;                int t_city = rand()%city_num;                while(flag[t_city])                    t_city = rand()%city_num;                flag[t_city] = true;                group[i].path[j] = t_city;            &#125;        &#125;    &#125;    //对每个个体进行评估    void assess()    &#123;        for(int k = 0; k &lt; unit_num; k++)        &#123;            int rel = 0;            for(int i = 1; i &lt; city_num; i++)                rel += length_table[group[k].path[i-1]][group[k].path[i]];            rel += length_table[group[k].path[city_num-1]][group[k].path[0]];            group[k].length = rel;        &#125;    &#125;    //根据评估结果对个体进行排序    void unit_sort()    &#123;        for(int i = 0; i &lt; unit_num; i++)        &#123;            for(int j = i+1; j &lt; unit_num; j++)            &#123;                if(group[i].length &gt; group[j].length)                &#123;                    Unit temp;                    memcpy(&amp;temp, &amp;group[i], sizeof(Unit));                    memcpy(&amp;group[i], &amp;group[j], sizeof(Unit));                    memcpy(&amp;group[j], &amp;temp, sizeof(Unit));                &#125;            &#125;        &#125;    &#125;    //交叉    Unit cross(Unit &amp;father, Unit &amp;mother)    &#123;        int l = rand()%city_num;        int r = rand()%city_num;        if(l &gt; r)            swap(l, r);        bool flag[city_num] = &#123;&#125;;        for(int i = l; i &lt;= r; i++)            flag[father.path[i]] = true;        Unit son;        int pos = 0;        for(int i = 0; i &lt; l; i++)        &#123;            while(flag[mother.path[pos]])                pos++;            son.path[i] = mother.path[pos++];        &#125;        for(int i = l; i &lt;= r; i++)            son.path[i] = father.path[i];        for(int i = r+1; i &lt; city_num; i++)        &#123;            while(flag[mother.path[pos]])                pos++;            son.path[i] = mother.path[pos++];        &#125;        return son;    &#125;    //突变    void mutation(Unit &amp;t)    &#123;        int proport = rand() % 100;        if(proport &gt; ps)            return;        int one = rand()%city_num;        int two = rand()%city_num;        while(two != one)            two = rand()%city_num;        swap(t.path[one], t.path[two]);    &#125;    //输出信息    void print()    &#123;        for(int i = 0; i &lt; unit_num; i++)        &#123;            printf(&quot;第%d个个体，路径信息：&quot;, i);            for(int j = 0; j &lt; city_num; j++)                printf(&quot;%d &quot;, group[i].path[j]);            printf(&quot;;总权值：%d;\n&quot;, group[i].length);        &#125;        printf(&quot;最优个体，路径信息：&quot;);        for(int j = 0; j &lt; city_num; j++)            printf(&quot;%d &quot;, group[0].path[j]);        printf(&quot;;总权值：%d;\n&quot;, group[0].length);    &#125;    //种群进化    void work()    &#123;        for(int i = 0; i &lt; genmax; i++)        &#123;            //如果进化层数大于20，加大变异的概率            if(i &gt; 20)                ps *= 3;            assess();//评估            unit_sort();//根据评估结果排序            if(best.length &gt; group[0].length)            &#123;                memcpy(&amp;best, &amp;group[0], sizeof(group[0]));                best_gen = i;            &#125;            for(int j = 0; j+2 &lt; unit_num; j+=3)                group[j+2] = cross(group[j], group[j+1]);            for(int j = 0; j &lt; city_num; j++)//变异(从1开始，保留最优)                mutation(group[j]);        &#125;    &#125;&#125;;Unit group[unit_num];//种群变量Unit bestone;//记录最短路径int generation_num;//记录当前达到了第几代int main()&#123;    srand((int)time(0));    for(int i = 0; i &lt; 20; i++)    &#123;        Group g;        g.work();        printf(&quot;第%d次求解。路径：&quot;, i+1);        for(int j = 0; j &lt; city_num; j++)            printf(&quot;%d &quot;, g.best.path[j]);        printf(&quot;;总权值：%d; 第%d代;\n&quot;, g.best.length, g.best_gen);    &#125;    return 0;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>智能算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>njust sequence(二分查找)</title>
    <link href="/posts/60175.html"/>
    <url>/posts/60175.html</url>
    
    <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><pre><code class="hljs">Time Limit: 1000MSMemory Limit: 65536KB</code></pre><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>将一个给定的数列，拆分成K个不降序列，每个数出现且只出现一次，且在各序列中各个数相对于原数列的相对顺序不变。<br>如7 6 9 8 10可以拆成 7 9 10和6 8。求最小的K值。</p></blockquote><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><blockquote><p>第一行输入一个整数T（1 &lt;= T &lt;= 100），表示接下来T组测试数据，<br>每组两行，第一行为n，代表数列长度（1&lt;=n&lt;=10000）<br>接下来一行有n个数，空格分隔（每个数&lt;=50000）。</p></blockquote><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><blockquote><p>对每组数据输出一个最小的K值。</p></blockquote><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code class="hljs">257 6 9 8 1055 4 3 2 1</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code class="hljs">25</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><blockquote><p>维护一个数组，保存多个非递减序列的最后一个值。<br>显然，这个数组一定是递减的。<br>例如上面样例中的 7 6 9 8 10<br>初始时，我们令a[0] = 7，表示目前有一个序列，最后一个值为7<br>接下来到6了，因为6小于7，所以只能使用一个新的序列，令a[1] = 6<br>到9，我们发现9既可以放在7后面，也可以放在6后面，那我们当然选择在7后面放，相比放在6后面会更好。<br>也就是说，假如当前需要放入x，那就在数组中找小于等于x的最大值，更新它为x。<br>因为数组是递减的，所以寻找的这个过程可以使用二分查找。</p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="hljs">#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;list&gt;#include&lt;vector&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;#include&lt;stack&gt;#include&lt;queue&gt;using namespace std;#define LL long longint d[50009];int find(int l, int r, int x)&#123;    while(l &lt;= r)    &#123;        int mid = (l+r)/2;        if(x &lt; d[mid])            l = mid+1;        else if(x &gt; d[mid])            r = mid-1;        else            return mid;    &#125;    return l;&#125;int main()&#123;    int T;    scanf(&quot;%d&quot;, &amp;T);    while(T--)    &#123;        int n;        scanf(&quot;%d&quot;, &amp;n);        int len = 0;        d[len] = 0;        for(int i=0; i&lt;n; i++)        &#123;            int t;            scanf(&quot;%d&quot;, &amp;t);            int z = find(0, len, t);            if(z &gt; len)                d[++len] = t;            else                d[z] = t;        &#125;        printf(&quot;%d\n&quot;, len+1);    &#125;    return 0;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>思路题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hihocoder 1149 回文字符序列(区间dp)</title>
    <link href="/posts/26901.html"/>
    <url>/posts/26901.html</url>
    
    <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><pre><code class="hljs">时间限制:2000ms单点时限:1000ms内存限制:256MB</code></pre><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>给定字符串，求它的回文子序列个数。回文子序列反转字符顺序后仍然与原序列相同。例如字符串aba中，回文子序列为”a”, “a”, “aa”, “b”,<br>“aba”，共5个。内容相同位置不同的子序列算不同的子序列。</p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><blockquote><p>第一行一个整数T，表示数据组数。之后是T组数据，每组数据为一行字符串。</p></blockquote><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><blockquote><p>对于每组数据输出一行，格式为”Case #X: Y”，X代表数据编号（从1开始），Y为答案。答案对100007取模。</p></blockquote><pre><code class="hljs">数据范围1 ≤ T ≤ 30小数据字符串长度 ≤ 25大数据字符串长度 ≤ 1000</code></pre><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><pre><code class="hljs">5abaabcbaddabcba12111112351121cccccccfdadfa</code></pre><h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><pre><code class="hljs">Case #1: 5Case #2: 277Case #3: 1333Case #4: 127Case #5: 17</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><blockquote><p>典型的区间dp.</p></blockquote><pre><code class="hljs">if(s[i] == s[j])    dp[i][j] = dp[i+1][j]+dp[i][j-1]+1;else    dp[i][j] = dp[i+1][j]+dp[i][j-1]-dp[i+1][j-1];</code></pre><blockquote><p>简单解释一下，先说一下s[i] != s[j]时，dp[i+1][j]+dp[i][j-1]然后再减去重复的dp[i+1][j-1]部分，这个不难理解。<br>那么当s[i] == s[j]时，显然i与j之间所有是回文串的子序列可以用s[i],s[j]包裹成为新的子序列，所以重复部分不需要剪去了，还需要加上1是因为<br>s[i]s[j]两个单独一起也可以作为一个回文子序列。</p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="hljs">#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;using namespace std;const int MOD = 100007;char s[1009];int dp[1009][1009];int main()&#123;    int T;    scanf(&quot;%d&quot;, &amp;T);    for(int i=1; i&lt;=T; i++)    &#123;        memset(dp, 0, sizeof(dp));        scanf(&quot;%s&quot;, s+1);        int n = strlen(s+1);        for(int l=0; l&lt;n; l++)        &#123;            for(int i=1; i+l&lt;=n; i++)            &#123;                int j = i+l;                if(s[i] == s[j])                    dp[i][j] = (dp[i+1][j]+dp[i][j-1]+1)%MOD;                else                    dp[i][j] = (dp[i+1][j]+dp[i][j-1]-dp[i+1][j-1]+MOD)%MOD;            &#125;        &#125;        printf(&quot;Case #%d: %d\n&quot;, i, dp[1][n]);    &#125;    return 0;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GDUT Krito的讨伐(bfs、优先队列)</title>
    <link href="/posts/24933.html"/>
    <url>/posts/24933.html</url>
    
    <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote></blockquote><p>Krito终于干掉了99层的boss，来到了第100层。第100层可以表示成一颗树，这棵树有n个节点（编号从0到n-1），树上每一个节点可能有很多只怪物。<br>Krito现在在0号节点，现在它想要区清除这一层所有的怪物。他现在有atk大小的攻击力。只有当你的攻击力大于这只怪物的防御力时，你才可以打败他，同时每打败只<br>怪物,你会获得一定的攻击力加成。一个节点可能存在着不止一只怪兽，你要打败这个节点的所有怪物才能可以从这个节点通过，请问他能不能完成这个任务？注意：不要求一次<br>性杀光一个节点里面的所有怪物。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><pre><code class="hljs">第1行：一个数T，表示有T个测试样例（0&lt;=T&lt;=50) ,接下来有T个测试样例对于每一个测试样例：第1行：两个整数n，m表示这棵树有n个节点，m只怪兽(0&lt;=n&lt;=1000 ,0&lt;=m &lt;=100)第2至n-1行： 两个整数u，v表示编号为u，v之间的节点有一条无向边，题目保证不会成环。（0&lt;=u,v&lt;n , u!=v)&gt;第3行： 一个整数atk，表示Krito的初始化攻击力(0&lt;=atk&lt;=100)第4至3+m行：两个整数id，def，add_atk，表示在编号为id的点上，有一只防御力为def的怪物,打败后可以增加add_atk点的攻击力。(0&lt;=add_atk,def&lt;=100)</code></pre><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><pre><code class="hljs">对于每一个测试样例，如果Krito能够清除所有的怪物，则输出“Oh yes.” 否则，输出“Good Good Study,Day Day Up.”</code></pre><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code class="hljs">15 20 10 22 32 4113 10 21 11 0</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code class="hljs">Oh yes.</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><blockquote><p>因为从根节点开始，必须打败当前节点的所有怪物，才可以进入下一节点。贪心思想，先选择防御力低的怪物总是不会更坏。<br>所以用一优先队列维护我们可以攻击到到怪物，一旦某节点怪物全杀完，则将其子节点怪物加入队列。<br>如果当前最小防御力怪物都不能消灭，那么一定是失败的。</p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="hljs">#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;algorithm&gt;#include &lt;stack&gt;#include &lt;queue&gt;using namespace std;#define LL long longstruct Node&#123;    int id, def, add;    friend bool operator &lt; (Node a, Node b)    &#123;        return a.def &gt; b.def;    &#125;&#125;;bool g[1009][1009];int cnt[1009];vector&lt;Node &gt; v[1009];bool vis[1009];int n, m, k;void init()&#123;    memset(cnt, 0, sizeof(cnt));    memset(g, 0, sizeof(g));    memset(vis, 0, sizeof(vis));    for(int i=0; i&lt;n; i++)        v[i].clear();&#125;bool bfs()&#123;    priority_queue&lt;Node&gt; q;    for(int i=0; i&lt;v[0].size(); i++)        q.push(v[0][i]);    if(cnt[0] == 0)    &#123;        Node t = &#123;0, -1, 0&#125;;        q.push(t);    &#125;    vis[0] = 1;    while(!q.empty())    &#123;        Node t = q.top();        q.pop();        if(t.def == -1)        &#123;            for(int i=0; i&lt;n; i++)            &#123;                if(!vis[i] &amp;&amp; g[t.id][i] == 1)                &#123;                    vis[i] = 1;                    for(int j=0; j&lt;cnt[i]; j++)                        q.push(v[i][j]);                    if(cnt[i] == 0)                    &#123;                        Node x = &#123;i, -1, 0&#125;;                        q.push(x);                    &#125;                &#125;            &#125;            continue;        &#125;        if(t.def &lt; k)        &#123;            k += t.add;            if(--cnt[t.id] == 0)            &#123;                t.def = -1;                q.push(t);            &#125;        &#125;        else            return false;    &#125;    return true;&#125;int main()&#123;    int T;    scanf(&quot;%d&quot;, &amp;T);    while(T--)    &#123;        init();        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);        for(int i=1; i&lt;n; i++)        &#123;            int a, b;            scanf(&quot;%d%d&quot;, &amp;a, &amp;b);            g[a][b] = g[b][a] = 1;        &#125;        scanf(&quot;%d&quot;, &amp;k);        for(int i=0; i&lt;m; i++)        &#123;            int a, b, c;            scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);            Node t=&#123;a, b, c&#125;;            v[a].push_back(t);            cnt[a]++;        &#125;        if(bfs())            printf(&quot;Oh yes.\n&quot;);        else            printf(&quot;Good Good Study,Day Day Up.\n&quot;);    &#125;    return 0;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GDUT 积木积水(栈)</title>
    <link href="/posts/36543.html"/>
    <url>/posts/36543.html</url>
    
    <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>现有一堆边长为1的已经放置好的积木，小明（对的，你没看错，的确是陪伴我们成长的那个小明）想知道当下雨天来时会有多少积水。小明又是如此地喜欢二次元，于是他把这<br>个三维的现实问题简化成二维的问题。设雨量无穷、积木不透水、积木间无缝连接，问在这个二次元的世界里，已放置好的积木会有多少单位的积水量？<br><img src="http://img.blog.csdn.net/20160410185537515" alt="这里写图片描述"></p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行包含一个整数T(T≤100)，表示接下来的测试样例个数。 每个测试样例有两行组成： 第一行包含一个整数N(N≤1e6)，表示积木的列数；<br>第二行包含N个整数Ai(Ai≤1e6)，表示第i列积木的个数。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>每个样例输出一行，包含一个整数，为题目所求。</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><p>1<br>11<br>6 2 2 4 2 0 3 4 4 5 1</p><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><p>19</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><blockquote><p>数据范围是10^6，显然不能O(n^2)。<br>不自然的就想到了栈。<br>维护一个递减的栈。<br>如果，当前列比栈顶列低，那就入栈。<br>否则，就一直出栈，直至栈顶高于当前列。<br>理由是显然的，对于两个相对高些的列，它们之间的较低列显然是没用的。<br>最后，所有列都进行过后，对栈里元素依次出栈，并记录它们之间的矩形面积，再减去它们之间的方格总数，既是最终的答案。</p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="hljs">#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;algorithm&gt;#include &lt;stack&gt;using namespace std;#define LL long longLL d[1000009], g[1000009];int main()&#123;    int T, n;    scanf(&quot;%d&quot;, &amp;T);    while(T--)    &#123;        scanf(&quot;%d&quot;, &amp;n);        for(int i=0; i&lt;n; i++)            scanf(&quot;%d&quot;, &amp;d[i]);        g[0] = d[0];        for(int i=1; i&lt;n; i++)            g[i] = g[i-1] + d[i];        stack&lt;int&gt; s;        LL ans = 0;        for(int i=0; i&lt;n; i++)        &#123;            if(s.empty())            &#123;                s.push(i);                continue;            &#125;            int t;            while(!s.empty())            &#123;                t = s.top();                if(d[t] &gt; d[i])                    break;                s.pop();            &#125;            if(s.empty())                ans += (i-t-1)*d[t]-(g[i-1]-g[t]);            s.push(i);        &#125;        if(!s.empty())        &#123;            int i = s.top();            s.pop();            while(!s.empty())            &#123;                int t = s.top();                s.pop();                ans += (i-t-1)*d[i]-(g[i-1]-g[t]);                i = t;            &#125;        &#125;        printf(&quot;%lld\n&quot;, ans);    &#125;    return 0;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>思路题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hihocoder 1032 最长回文子串(Manacher)</title>
    <link href="/posts/1772.html"/>
    <url>/posts/1772.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>之前做过类似的题，只是理解了，还没达到驾轻就熟，想到即敲出的地步，所以再练一次。<br>顺带将Manacher算法思想解释一遍，加强印象，也算作分享吧。</p></blockquote><h2 id="Manacher"><a href="#Manacher" class="headerlink" title="Manacher"></a>Manacher</h2><p>我们用f(x)表示以x位置为中心的回文串的长度<br>j相对i的对应位置是j’<br>那么f(j)与f(j’)和f(i)有什么关系呢。<br><img src="http://img.blog.csdn.net/20160410030917422" alt="这里写图片描述"><br>先看第一张图，下面那条横杠表示f(i)，那么，既然j’与j相对应，j’的回文串长度已经求出，那么j位置的回文串长度一定是大于等于j’长度的。<br>即f(i) &gt;= f(j’)=f(i*2-j)<br><img src="http://img.blog.csdn.net/20160410030905203" alt="这里写图片描述"><br>但是还存在上图这样的情况，即i的回文串并没有完全覆盖j’的回文串，那么j与j’的回文串的对应关系就只能在i回文串的范围内才能成立。<br>那么，这样以来，f(i) &gt;= min(f(j’), f(i)-(i-j)*2)。</p><p>有了上述结论，我们可以减少很多的不必要的计算，从而达到高效求解最长回文子串的目的。</p><p>题目链接： <a href="http://hihocoder.com/problemset/problem/1032"> 1032：最长回文子串 </a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><blockquote><p>Manacher思想，上面已经介绍，但那只能求解最长回文串是奇数的情况，对于偶数来说显然不适用。<br>其实稍加变通即可。<br>如：ababa的最长回文串长度为5<br>而#a#b#a#b#a#的最长回文长度为11。<br>容易看出，两者是相乘加一的关系<br>对于任意一个长度为n的字符串，将其穿插于#之间，变为一个长度为2n+1的新串，显然是奇数。<br>问题迎刃而解了。</p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="hljs">#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;algorithm&gt;using namespace std;char str[1000009];char t[2000009];int cnt[1000009];int manacher(char s[], int len)&#123;    cnt[0] = cnt[1] = 1;    int id = 1;    int ans = 1;    for(int i=2; i&lt;=len; i++)    &#123;        int num = min(cnt[id*2-i], cnt[id]+id-i);        while(s[i-num] == s[i+num])            num++;        cnt[i] = num;        if(id+cnt[id] &lt; i+num)            id = i;        if(ans &lt; num)            ans = num;    &#125;    return ans-1;&#125;int main()&#123;    int n;    scanf(&quot;%d&quot;, &amp;n);    while(n--)    &#123;        scanf(&quot;%s&quot;, str);        t[0] = &#39;$&#39;;        int len = strlen(str);        for(int i=0; i&lt;len; i++)        &#123;            t[i*2+2] = str[i];            t[i*2+1] = &#39;#&#39;;        &#125;        t[len*2+1] = &#39;#&#39;;        t[len*2+2] = &#39;\0&#39;;        printf(&quot;%d\n&quot;, manacher(t, len*2+1));    &#125;    return 0;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>KMP;Manacher</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++贪吃蛇</title>
    <link href="/posts/4866.html"/>
    <url>/posts/4866.html</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>做完俄罗斯方块后，突然不知道干嘛。索性一鼓作气，把贪吃蛇也撸出来。</p></blockquote><hr><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>贪吃蛇，c++，qt。<br>基本的贪吃蛇功能，没什么特殊的。蛇的速度与蛇的长度成正比。同时实现了记分以及暂停的功能。</p></blockquote><hr><h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h2><hr><h3 id="游戏过程效果图"><a href="#游戏过程效果图" class="headerlink" title="游戏过程效果图"></a>游戏过程效果图</h3><p><img src="http://img.blog.csdn.net/20160404183256409" alt="这里写图片描述"></p><hr><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><hr><blockquote><p>相比俄罗斯方块，实贪吃蛇的实现容易了许多，主要就是一个蛇的移动问题。<br>想到蛇的曲折的行进路径，正常第一反应就是去想把那么转向的位置纪录下来。<br>但仔细想想完全不用这样。<br>用一个数据记录蛇身每个节点的坐标。那么每次蛇移动，都是当前节点移动到上一个节点的位置。<br>这样以来，我们只需要控制蛇头去转向即可。蛇身自然会跟随蛇头的路径去前进。</p></blockquote><hr><h2 id="代码构成"><a href="#代码构成" class="headerlink" title="代码构成"></a>代码构成</h2><blockquote><p>全部代码仍然是三个类</p></blockquote><h3 id="1-Snake-蛇信息及操作"><a href="#1-Snake-蛇信息及操作" class="headerlink" title="1. Snake 蛇信息及操作"></a>1. Snake 蛇信息及操作</h3><pre><code class="hljs">class Snake&#123;public:    int len;//蛇的长度    int s[10000][2];//保存蛇身    int dx, dy;//蛇当前方向    Board *board;    Snake(Board *);    void eat();//吃食    int detect();//碰撞检测    void toNext();//前往当前方向下一步    void turnUp();//蛇转向    void turnDown();    void turnLeft();    void turnRight();&#125;;</code></pre><hr><h3 id="2-Board-游戏地图信息"><a href="#2-Board-游戏地图信息" class="headerlink" title="2. Board 游戏地图信息"></a>2. Board 游戏地图信息</h3><pre><code class="hljs">class Board&#123;public:    int score;//当前分数    int maxScore;//最高分    int atime;//每次下落的间隔时间    int length;//地图边长    int foodX;//食物所在坐标    int foodY;    Snake *snake;//蛇    int map[100][100];//保存地图信息    Board(int);    void makeFood();//随机生成食物    bool isEnd();//进行蛇的前进，并判断前进后是否游戏结束&#125;;</code></pre><hr><h3 id="3-mainWindow-游戏界面部分"><a href="#3-mainWindow-游戏界面部分" class="headerlink" title="3. mainWindow 游戏界面部分"></a>3. mainWindow 游戏界面部分</h3><pre><code class="hljs">class MainWindow : public QMainWindow&#123;    Q_OBJECTpublic:    bool flag;//判断是否暂停状态    bool isPress;//控制按键频率    QTimer *timer;//定时器    Board *board;//游戏所用地图类    MainWindow(QWidget *parent = 0);    void paintEvent(QPaintEvent *event);//绘制界面    void keyPressEvent(QKeyEvent *);//键盘事件处理signals:public slots:    void timerEvent();//定时事件private:&#125;;</code></pre><hr><h2 id="遇到的问题及解决方法"><a href="#遇到的问题及解决方法" class="headerlink" title="遇到的问题及解决方法"></a>遇到的问题及解决方法</h2><blockquote><p>和俄罗斯方块的一个小区别是，俄罗斯方块每次完成一个小块的操作后，会产生一个新的小块，进行新的操作。<br>而贪吃蛇不同，蛇一直都在动，并且从游戏开始到结束都只有这一条蛇。<br>所以这里必须要保证每次移动一个单位长度，都必须只能前进一次。<br>因为玩家按键的速度远超过计算机的timeout。所以会出现界面上蛇身还没转向，但逻辑上方向已经发生了变化。<br>因此，使用一个isPress变量来实现对按键频率的控制，即：<br>蛇体的每次移动，只能转向一次。<br>这样就可以避免出现上述的问题。</p></blockquote><hr><h2 id="感触"><a href="#感触" class="headerlink" title="感触"></a>感触</h2><blockquote><p>写完俄罗斯后，几个小时就完成了贪吃蛇，在理解的基础上，唯手熟耳。要坚持！</p></blockquote><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p>我的github链接：<br><a href="https://github.com/shiyi1996/game"> https://github.com/shiyi1996/game </a></p>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>游戏开发</tag>
      
      <tag>C++</tag>
      
      <tag>Qt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++俄罗斯方块</title>
    <link href="/posts/44197.html"/>
    <url>/posts/44197.html</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>一个礼拜前想做一个俄罗斯方块小游戏，因为想用c++实现，但又受制于界面，于是苦读了几天的Qt。昨天开工连带一个不眠夜，总算是大功告成，个中滋味，怕是只有<br>自己知道。</p></blockquote><hr><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>俄罗斯方块，c++，qt。<br>功能：常规俄罗斯方块具有的：方块旋转，左移，右移，下落加速，消行，提示下一块样式等等都已实现。同时实现了记分以及暂停的功能。</p></blockquote><hr><h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h2><hr><h3 id="游戏过程效果图"><a href="#游戏过程效果图" class="headerlink" title="游戏过程效果图"></a>游戏过程效果图</h3><p><img src="http://img.blog.csdn.net/20160404104940464" alt="这里写图片描述"></p><hr><h3 id="暂停效果图"><a href="#暂停效果图" class="headerlink" title="暂停效果图"></a>暂停效果图</h3><p><img src="http://img.blog.csdn.net/20160404104955433" alt="这里写图片描述"></p><hr><h3 id="游戏结束效果图"><a href="#游戏结束效果图" class="headerlink" title="游戏结束效果图"></a>游戏结束效果图</h3><p><img src="http://img.blog.csdn.net/20160404104826573" alt="这里写图片描述"></p><hr><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><hr><blockquote><p>提到俄罗斯方块，稍微麻烦一些的地方只有三点</p></blockquote><hr><h3 id="1-方块旋转"><a href="#1-方块旋转" class="headerlink" title="1. 方块旋转"></a>1. 方块旋转</h3><pre><code class="hljs">#1###1###11###########1#111##########11###1###1######111#1######</code></pre><blockquote><p>上面四个小矩阵我们很容易看出，它是L型图案的四种不同形态，用4＊4的矩阵来将它们统一表示，再细心一点的小伙伴还会发现，它们的顺序也是按照逆时针旋转进行排<br>列的。<br>那么加入我们对上面四个小矩阵进行编号为1，2，3，4。<br>那么显然1－旋转－&gt; 2 －旋转－&gt; 3 －旋转－&gt; 4 －旋转－&gt;1<br>如果我们开辟一NEXT数组用来保存方块对应的旋转后的方块编号。<br>则NEXT[1] = 2; NEXT[2] = 3; NEXT[3] = 4; NEXT[4] = 1;<br>举一反三，别的形状方块也是一样的。</p></blockquote><hr><h3 id="2-碰撞检测"><a href="#2-碰撞检测" class="headerlink" title="2. 碰撞检测"></a>2. 碰撞检测</h3><blockquote><p>上文，我们用一个四维小矩阵来表示方块，我们可以对它规定一个重心，索性就用左上角(0, 0)点来作为重心吧。<br>这个重心只是用来与实际地图相对应的一个相对点而已。<br>我们以将小矩阵忽略，只在意重心那个点，通过重心点所在地图的坐标，显然可以求出其他点位于地图的坐标。<br>这样一来，每次操作方块时，将方块将要变换到的位置与地图进行比较，通过简单的判断，可以得出是否有重复部分，若重复，则可以移动，否则不可以。</p></blockquote><hr><h3 id="3-方块自动下降"><a href="#3-方块自动下降" class="headerlink" title="3. 方块自动下降"></a>3. 方块自动下降</h3><blockquote><p>这个是最容易解决的，qt里有个QTimer类，有定时功能，设定一定时间间隔，触发timerEvent事件。在事件里，做你想做的即可。</p></blockquote><hr><h2 id="代码构成"><a href="#代码构成" class="headerlink" title="代码构成"></a>代码构成</h2><blockquote><p>全部代码仅实现三个类</p></blockquote><h3 id="1-Board-游戏地图信息"><a href="#1-Board-游戏地图信息" class="headerlink" title="1. Board 游戏地图信息"></a>1. Board 游戏地图信息</h3><pre><code class="hljs">class Board&#123;public:    int score;//当前分数    int maxScore;//最高分    int time;//每次下落的间隔时间    int width;//地图宽    int height;//地图高    Block *block;//下落的方块    char map[100][100];//保存地图信息    Board(int, int);    void confirm();//将下落到底的块更新到map    bool isEnd();//判断是否游戏结束&#125;;</code></pre><hr><h3 id="2-Block-方块信息及操作"><a href="#2-Block-方块信息及操作" class="headerlink" title="2. Block 方块信息及操作"></a>2. Block 方块信息及操作</h3><pre><code class="hljs">class Block&#123;public:    char BLOCKS[20][5][5];//各个类型的方块    int NEXT[20];//模拟指向用于方块旋转    Qt::GlobalColor COLOR[20];//各个类型方块的颜色    int x;//块重心起始坐标    int y;    int type;//块id    int nextType;//下一个块id    Board *board;    Block(Board *);//构造函数    void toNext();//更改块id    void moveUp();//变形    void moveRight();//加速    void moveLeft();//左移    void moveDown();//右移    bool detect(int);//碰撞检测&#125;;</code></pre><hr><h3 id="3-mainWindow-游戏界面部分"><a href="#3-mainWindow-游戏界面部分" class="headerlink" title="3. mainWindow 游戏界面部分"></a>3. mainWindow 游戏界面部分</h3><pre><code class="hljs">class MainWindow : public QMainWindow&#123;    Q_OBJECTpublic:    bool flag;//判断是否暂停状态    QTimer *timer;//定时器    Board *board;//游戏所用地图类    MainWindow(Board *, QWidget *parent = 0);    void paintEvent(QPaintEvent *event);//绘制界面    void keyPressEvent(QKeyEvent *);//键盘事件处理signals:public slots:    void timerEvent();//定时事件private:&#125;;</code></pre><hr><h2 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h2><blockquote><p>粗略估计了下，代码总量约500行，所以这里就只贴自己认为核心的部分，完整项目文件及可执行程序会上传到git上，下面会给出链接。有兴趣的朋友去down一下<br>即可。</p></blockquote><h3 id="碰撞检测"><a href="#碰撞检测" class="headerlink" title="碰撞检测"></a>碰撞检测</h3><pre><code class="hljs">bool Block::detect(int flag)&#123;    //获得当前操作的目标状态：目标坐标，目标方块类型。    int nextX, nextY, nextType;    // 0,1,2,3对应上下左右    switch(flag)    &#123;        case 0: nextX = x; nextY = y; nextType = NEXT[type]; break;        case 1: nextX = x+1; nextY = y; nextType = type; break;        case 2: nextX = x; nextY = y-1; nextType = type; break;        case 3: nextX = x; nextY = y+1; nextType = type; break;    &#125;    for(int i=0; i&lt;4; i++)        for(int j=0; j&lt;4; j++)        &#123;            //tx，ty表示i，j所对应的地图的实际位置。            int tx = nextX+i;            int ty = nextY+j;            //边界处理            if(tx &lt; 0 || tx &gt; board-&gt;height+1 || ty &lt; 0 || ty &gt; board-&gt;width+1)                continue;            //如果块与地图墙相重合，则发生碰撞            if(BLOCKS[nextType][i][j] != &#39;#&#39; &amp;&amp; (ty == 0 || ty == board-&gt;width+1))                return false;            if(BLOCKS[nextType][i][j] != &#39;#&#39; &amp;&amp; board-&gt;map[tx][ty] != &#39;#&#39;)                return false;        &#125;    return true;&#125;</code></pre><hr><h3 id="方块沉底后的地图信息更新及消行记分操作"><a href="#方块沉底后的地图信息更新及消行记分操作" class="headerlink" title="方块沉底后的地图信息更新及消行记分操作"></a>方块沉底后的地图信息更新及消行记分操作</h3><pre><code class="hljs">void Board::confirm()&#123;    //将块更新到map    for(int i=0; i&lt;4; i++)        for(int j=0; j&lt;4; j++)        &#123;            int tx = block-&gt;x + i;            int ty = block-&gt;y + j;            if(tx&lt;1 || tx &gt; height || ty &lt; 1 || ty &gt; width)                continue;            if(block-&gt;BLOCKS[block-&gt;type][i][j] != &#39;#&#39;)                map[tx][ty] = block-&gt;BLOCKS[block-&gt;type][i][j];        &#125;    //消去完整的行并计算行个数    int cnt = 0;    for(int i=height; i&gt;=1; i--)    &#123;        bool flag = false;        for(int j=1; j&lt;=width; j++)            if(map[i][j] == &#39;#&#39;)            &#123;                flag = true;                break;            &#125;        if(flag)            continue;        cnt++;        for(int j=i; j&gt;=1; j--)            for(int k=1; k&lt;=width; k++)                map[j][k] = map[j-1][k];    &#125;    //每下落一个块加5分    score += 5;    //根据同时消去的行的数量指数型记分    //1-10 2-20 3-40 4-80    if(cnt)        score += 10*(1&lt;&lt;cnt);    //实时更新最大值    maxScore = std::max(maxScore, score);    //每下落一个块，时间间隔减2    time -= 2;    if(time &lt; 0)        time = 0;    //更新块    block-&gt;toNext();&#125;</code></pre><hr><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p>我的github链接：<br><a href="https://github.com/shiyi1996/algorithm/tree/master/eluosi"> https://github.com/shiyi1996/game</a></p><blockquote><p>哈哈，分享成果的过程总是令人快乐的。<br>最后，如果有道友发现其中有出错的地方，还望不吝指出。<br>若有更好的写法也可交流一二，大家一起进步嘛！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>游戏开发</tag>
      
      <tag>C++</tag>
      
      <tag>Qt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU 3038 How Many Answers Are Wrong(并查集)</title>
    <link href="/posts/36719.html"/>
    <url>/posts/36719.html</url>
    
    <content type="html"><![CDATA[<p>题目链接： <a href="http://acm.hust.edu.cn/vjudge/contest/view.action?cid=66964#problem/D"> [kuangbin带你飞]专题五 并查集 D - How Many Answers Are Wrong</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><blockquote><p>有n次询问，给出a到b区间的总和，问这n次给出的总和中有几次是和前面已近给出的是矛盾的。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><blockquote><p>sum[x]表示x到区间末尾的总和<br>则a到b的总和c 可以表示为sum[a]-sum[b+1] = c。</p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="hljs">#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#define LL long longusing namespace std;int sum[200009], fa[200009];int find(int x)&#123;    if(fa[x] == x)        return x;    int t = fa[x];    fa[x] = find(fa[x]);    sum[x] += sum[t];    return fa[x];&#125;void update(int x, int y, int a, int b, int c)&#123;    if(x &gt; y)    &#123;        fa[y] = x;        sum[y] = sum[a]-sum[b]-c;    &#125;    else    &#123;        fa[x] = y;        sum[x] = sum[b]-sum[a]+c;    &#125;&#125;int main()&#123;    int len, n;    while(~scanf(&quot;%d%d&quot;, &amp;len, &amp;n))    &#123;        memset(sum, 0, sizeof(sum));        for(int i=0; i&lt;=200001; i++)            fa[i] = i;        int ans = 0;        while(n--)        &#123;            int a, b, c;            scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);            b++;            int x = find(a);            int y = find(b);            if(x == y &amp;&amp; sum[a] != sum[b] + c)                ans++;            else if(x != y)                update(x, y, a, b, c);        &#125;        printf(&quot;%d\n&quot;, ans);    &#125;    return 0;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并差集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ 2236 Wireless Network(并查集)</title>
    <link href="/posts/64214.html"/>
    <url>/posts/64214.html</url>
    
    <content type="html"><![CDATA[<p>** 题目链接 ** ： <a href="http://acm.hust.edu.cn/vjudge/contest/view.action?cid=66964#problem/A"> [kuangbin带你飞]专题五 并查集 A - Wireless Network </a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><blockquote><p>有n台损坏的电脑，现要将其逐台修复，且使其相互恢复通信功能。若两台电脑能相互通信，则有两种情况，一是他们之间的距离小于d，二是他们可以借助都可到达的第三<br>台已修复的电脑。给出所有电脑的坐标位置，对其进行两种可能的操作，O x表示修复第x台，S x y表示判断x<br>y之间能否通信，若能输出SUCCESS，否则输出FALL。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><blockquote><p>用并查集来保存电脑互相的连通情况。<br>每次修好电脑后，将它可以通信的电脑(距离满足且已修好)与它进行连通。</p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="hljs">#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#define LL long longusing namespace std;const int N = 1009;int x[N], y[N], fa[N];bool p[N];vector&lt;int&gt; v[N];int find(int x)&#123;    if(fa[x] == x)        return x;    return fa[x] = find(fa[x]);&#125;int main()&#123;    int n, d;    char s[2];    scanf(&quot;%d%d&quot;, &amp;n, &amp;d);    for(int i=1; i&lt;=n; i++)    &#123;        scanf(&quot;%d%d&quot;, &amp;x[i], &amp;y[i]);        fa[i] = i;    &#125;    for(int i=1; i&lt;=n; i++)        for(int j=i+1; j&lt;=n; j++)        &#123;            if(((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j])) &lt;= d*d)            &#123;                v[j].push_back(i);                v[i].push_back(j);            &#125;        &#125;    while(~scanf(&quot;%s&quot;, s))    &#123;        int a, b;        if(s[0] == &#39;O&#39;)        &#123;            scanf(&quot;%d&quot;, &amp;a);            p[a] = true;            for(int i=0; i&lt;v[a].size(); i++)                if(p[v[a][i]])                &#123;                    b = find(v[a][i]);                    fa[b] = a;                &#125;        &#125;        else        &#123;            scanf(&quot;%d%d&quot;, &amp;a, &amp;b);            int ta = find(a);            int tb = find(b);            if(ta == tb)                printf(&quot;SUCCESS\n&quot;);            else                printf(&quot;FAIL\n&quot;);        &#125;    &#125;    return 0;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并差集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POWEROJ 1168-A F(x)(找规律&amp;二分查找)</title>
    <link href="/posts/49878.html"/>
    <url>/posts/49878.html</url>
    
    <content type="html"><![CDATA[<p>题目链接： <a href="http://www.oj.swust.edu.cn/contest/problem/1168-A"> 1168-A </a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><pre><code class="hljs">Time Limit: 1000 MS Memory Limit: 65536 KB</code></pre><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>小明有一个不降序列（f（1），f（2），f（3），……），f（k）代表在这个序列中大小是k的有f（k）个。我们规定f（n）的前12项如下图。</p></blockquote><pre><code class="hljs">n           1    2    3    4    5   6   7   8   9   10   11   12f(n)        1    2    2    3    3   4   4   4   5   5    5    6</code></pre><blockquote><p>现在给你一个n，你知道f（n）是多少吗？</p></blockquote><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><blockquote><p>多组测试数据<br>每组一个n（1&lt;=n&lt;=2000,000,000）。</p></blockquote><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><blockquote><p>输出f（n）。</p></blockquote><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><blockquote><p>Raw<br>100<br>9999<br>123456</p></blockquote><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><blockquote><p>Raw<br>21<br>356<br>1684</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><blockquote><p>因为n的最大范围是20亿，显然不能数组保存，而且时间也不允许，也很难发现什么规律。<br>我们可以换个角度，既然要找的是f[n]的值，那么我们把f[x]=i时的最大x记录为 d[i] = x;<br>照此推算：<br>d[1] = 1<br>d[2] = 3<br>d[3] = 5<br>d[4] = 8<br>d[5] = 11<br>仔细推敲不难发现规律<br>从3起，d[i] = d[i-1] + find(i); find(i) = min(k) 当d[k]&gt;=i时<br>find(i)也就是d数组中大于等于i的一项的最小值的下标。</p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="hljs">#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#define LL long longusing namespace std;const int N = 5000086;int d[N];int find(int l, int r, int x)&#123;    while(l &lt; r)    &#123;        int mid = (l+r)/2;        if(d[mid] &lt; x)            l = mid+1;        else            r = mid;    &#125;    return r;&#125;int main()&#123;    int n;    d[1] = 1;    d[2] = 3;    int i;    for(i=3; ; i++)    &#123;        d[i] = d[i-1] + find(1, i-1, i);        if(d[i] &gt; 2000000000)            break;    &#125;    while(~scanf(&quot;%d&quot;, &amp;n))        printf(&quot;%d\n&quot;, find(1, i, n));    return 0;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>模拟</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>timus 1002. Phone Numbers(KMP&amp;动态规划)</title>
    <link href="/posts/15064.html"/>
    <url>/posts/15064.html</url>
    
    <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="http://acm.timus.ru/problem.aspx?space=1&num=1002"> 1002. Phone Numbers </a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><blockquote><p>现实生活中，你时常会遇到许多许多而且越来越长的电话号码。你需要记住这类型的号码。<br>例如按下面的图示，把字母划分到特定的数字上，是一种很容易就能把数字记住的方法：</p></blockquote><pre><code class="hljs">1 ij    2 abc   3 def4 gh    5 kl    6 mn7 prs   8 tuv   9 wxy0 oqz</code></pre><blockquote><p>按这种方法：每个字或一个词组可被代替成一组特定的数字，那么，你只可以通过记住一些词就能记住相应电话号码。<br>如果可以找出一种单词与个人电话号码的简单关系,它是很有吸引力的。例如你的一个棋友的电话号码是941837296，你可以用<br>WHITEPAWN来代替；又如你可以用BUULDOG来代替你的一个喜爱的老师的电话号码：2855304。</p></blockquote><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><blockquote><p>对给定的给定的数字和单词表，求出一个最简短的单词序列（也就是得出一尽可能短的单词来代替相应的数字）。这种对应关系要求符合上图所描述的关系。</p></blockquote><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><blockquote><p>输入包含若干组的测试数据。每组测试点的第一行是你所要记住的电话号码。这个号码最多有100个数位。测试的第二行是单词总数（最大为50000个）。以下的每一<br>行是只包含一个单词，单词长度最大限制为50个字母。整个输入文件的大小不超过300KB。 输入文件的最后一行以-1作为结束标志。</p></blockquote><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><blockquote><p>输出文件的每一行为找到的最短单词序列。每个单词间用一个空格隔开。如果没有解决方案，则输出“No solution.”。<br>如果有多个单词满足条件，可以从中选择任一个单词输出。</p></blockquote><h3 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h3><h4 id="input"><a href="#input" class="headerlink" title="input"></a>input</h4><pre><code class="hljs">73251890875ityourrealityrealour42949672965ityourrealityrealour-1</code></pre><h4 id="output"><a href="#output" class="headerlink" title="output"></a>output</h4><pre><code class="hljs">reality ourNo solution.</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><blockquote><p>首先，因为每个字母都对应唯一一个数字，我们完全可以将所有给定单词转换为数字序列。<br>那么，现在的问题就是用最少的数字串组成主串，我们用kmp找出每个数字串在主串中匹配的位置。<br>若匹配成功，那么在主串中匹配的首尾位置可以看作是一个权值为1的单向边，问题就可以转换为求0~n的最短路问题。<br>因为这题的每条边的先后次序是确定的，所以直接用dp解决即可。</p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="hljs">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;math.h&gt;#include &lt;cstdio&gt;#include &lt;stack&gt;using namespace std;const int N = 109;const int M = 50009;int p[N], d[N], v[N];int g[N][N];int fa[N];int l[M];char s[59], z[M][59];int t[26] = &#123;    2, 2, 2,    3, 3, 3,    4, 4,    1, 1,    5, 5,    6, 6,    0, 7, 0,    7, 7, 8,    8, 8, 9,    9, 9, 0&#125;;int nxt[59];void getNext(int d[], int length)&#123;    nxt[0] = 0;    for(int i=1, k=0; i&lt;length; i++)    &#123;        while(k &amp;&amp; d[i] != d[k])            k = nxt[k-1];        nxt[i] = d[i] == d[k] ? ++k : 0;    &#125;&#125;void kmp(int b[], int d[], int len, int length, int pos)&#123;    getNext(d, length);    for(int i=0, k=0; i&lt;len; i++)    &#123;        while(k&gt;0 &amp;&amp; d[k] != p[i])            k = nxt[k-1];        if(d[k] == p[i])            k++;        if(k == length)            g[i-length+1][i+1] = pos;    &#125;&#125;bool solve(int len)&#123;    memset(v, 0x3f, sizeof(v));    v[0] = 0;    for(int i=0; i&lt;len; i++)        for(int j=i+1; j&lt;=len; j++)            if(g[i][j] != -1 &amp;&amp; v[i]+1 &lt; v[j])            &#123;                v[j] = v[i] + 1;                fa[j] = g[i][j];            &#125;    return v[len] &lt; 0x3f3f3f3f;&#125;void print(int now)&#123;    if(now - l[fa[now]] &gt; 0)    &#123;        print(now-l[fa[now]]);        printf(&quot; &quot;);    &#125;    printf(&quot;%s&quot;, z[fa[now]]);&#125;int main()&#123;    int n;    while(~scanf(&quot;%s&quot;, s))    &#123;        if(s[0] == &#39;-&#39;)            break;        memset(g, -1, sizeof(g));        int len = strlen(s);        for(int i=0; i&lt;len; i++)            p[i] = s[i]-&#39;0&#39;;        scanf(&quot;%d&quot;, &amp;n);        for(int i=0; i&lt;n; i++)        &#123;            scanf(&quot;%s&quot;, z[i]);            l[i] = strlen(z[i]);            for(int j=0; j&lt;l[i]; j++)                d[j] = t[z[i][j]-&#39;a&#39;];            kmp(p, d, len, l[i], i);        &#125;        if(solve(len))            print(len);        else            printf(&quot;No solution.&quot;);        printf(&quot;\n&quot;);    &#125;    return 0;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>KMP&amp;amp;Manacher</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CODEVS 1029 遍历问题</title>
    <link href="/posts/3666.html"/>
    <url>/posts/3666.html</url>
    
    <content type="html"><![CDATA[<p>题目链接： <a href="http://codevs.cn/problem/1029/"> 1029 遍历问题 </a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><h3 id="题目描述-Description"><a href="#题目描述-Description" class="headerlink" title="题目描述 Description"></a>题目描述 Description</h3><blockquote><p>我们都很熟悉二叉树的前序、中序、后序遍历，在数据结构中常提出这样的问题：已知一棵二叉树的前序和中序遍历，求它的后序遍历，相应的，已知一棵二叉树的后序遍历<br>和中序遍历序列你也能求出它的前序遍历。然而给定一棵二叉树的前序和后序，你却不能确定其中序遍历序列，考虑如下图中的几棵二叉树：</p></blockquote><blockquote></blockquote><blockquote><p>所有这些二叉树都有着相同的前序遍历和后序遍历，但中序遍历却不相同。<br><img src="http://img.blog.csdn.net/20160317182130470" alt="这里写图片描述"></p></blockquote><h3 id="输入描述-Input-Description"><a href="#输入描述-Input-Description" class="headerlink" title="输入描述 Input Description"></a>输入描述 Input Description</h3><blockquote><p>输入文件共2行，第一行表示该树的前序遍历结果，第二行表示该树的后序遍历结果。输入的字符集合为{a-z}，长度不超过26。</p></blockquote><h3 id="输出描述-Output-Description"><a href="#输出描述-Output-Description" class="headerlink" title="输出描述 Output Description"></a>输出描述 Output Description</h3><pre><code class="hljs">输出文件只包含一个不超过长整型的整数，表示可能的中序遍历序列的总数。</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><blockquote><p>显然，中序遍历的数量一定和只有一个子节点的节点数目有关。<br>比如a的唯一子节点是b，那么先序遍历中一定是ab，后序遍历中一定是ba，即相邻且位置相反。<br>随便画一个二叉树观察即可明白。<br>那么，得出的节点数目为n，答案就是2^n。</p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="hljs">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;math.h&gt;#include &lt;cstdio&gt;#include &lt;stack&gt;using namespace std;const int N = 30;char a[N], b[N];int main()&#123;    cin&gt;&gt;a&gt;&gt;b;    int ans = 1;    int len = strlen(a);    for(int i=1; i&lt;len; i++)    &#123;        for(int j=1; j&lt;len; j++)        &#123;            if(a[i-1] == b[j] &amp;&amp; a[i] == b[j-1])                ans &lt;&lt;= 1;        &#125;    &#125;    cout&lt;&lt;ans&lt;&lt;endl;    return 0;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JSOI2008最大数maxnumber(栈&amp;二分查找)</title>
    <link href="/posts/48643.html"/>
    <url>/posts/48643.html</url>
    
    <content type="html"><![CDATA[<p>题目链接： <a href="http://www.lydsy.com/JudgeOnline/problem.php?id=1012"> 1012: [JSOI2008]最大数maxnumber</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><blockquote><p>中文题，点链接看吧，就不copy了。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><blockquote><p>打眼一看立刻就想到线段树，但本题的区间最值查找每次都是在查后L位，感觉用线段树有些大材小用了。<br>再仔细想想，发现，如果倒数第i个比倒数第i+1个数小，那么第i个数是没有用的，任意查询的最值都不会是它，因为查的是后L个嘛。<br>所以呢，我们我以维护一个栈，每次添加新元素时，将其与栈顶元素比较，若栈顶元素小，即无用了，那就出栈，否则，就将新元素入栈。<br>在查询时直接对栈里元素进行二分查找就好了，假如我们要查询后L位的最值，那么区间第一个数是d[len-L]。<br>我们只需找出栈中大于等于len－L的最小值，这个值就是区间最值的下标。(栈里当然存下标，要不然何谈二分)</p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="hljs">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;math.h&gt;#include &lt;cstdio&gt;#include &lt;stack&gt;using namespace std;const int N = 99999;int d[N];int sk[N];int main()&#123;    char s[2];    int x, n, mod, t, len=0, a=0;    scanf(&quot;%d%d&quot;, &amp;n, &amp;mod);    int st = 0;    while(n--)    &#123;        scanf(&quot;%s%d&quot;, s, &amp;x);        if(s[0] == &#39;A&#39;)        &#123;            d[len] = (x+a)%mod;            while(st &gt; 0)            &#123;                int temp = sk[st];                if(d[temp] &gt; d[len])                    break;                st--;            &#125;            sk[++st] = len;            len++;        &#125;        else        &#123;            int z = len-x;            int l = 1;            int r = st;            while(l &lt; r)            &#123;                int mid = (l+r)&gt;&gt;1;                if(sk[mid] &lt; z)                    l = mid+1;                else                    r = mid;            &#125;            a = d[sk[r]];            printf(&quot;%d\n&quot;, d[sk[r]]);        &#125;    &#125;    return 0;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>思路题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>五子棋AI图形界面人机对战(JAVA实现)</title>
    <link href="/posts/32040.html"/>
    <url>/posts/32040.html</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>改了又改，查了又查，想了又想，我真的不知道怎样让它再聪明了，大多时候走的都是正确的，但偶尔会蹦出那么一步臭棋，全盘皆输。 **<br>希望有相关经验的道友看到后可以指出原因和不足。 **</p></blockquote><h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h2><blockquote><p>按钮什么的还未完成，只是能实现正常的下棋了。<br><img src="http://img.blog.csdn.net/20160317135042608"></p></blockquote><h2 id="完成过程"><a href="#完成过程" class="headerlink" title="完成过程"></a>完成过程</h2><h3 id="UI部分"><a href="#UI部分" class="headerlink" title="UI部分"></a>UI部分</h3><blockquote><p>本来准备找张棋盘图片做背景，想了下我们还有人机界面课呢，权当复习一下java<br>GUI了，事实上过程比我想象中简单许多。现在界面部分输出游戏结果和按钮什么的还没来得及弄，只是凑合可以玩了，闲了再加上，先贴出来，找点动力再说。</p></blockquote><blockquote></blockquote><blockquote><p>棋盘部分 －－ 实现落子，撤子，判断是否成五子(游戏结束)。对局面的评估函数(这个很重要，下面专门会解释)<br>AI部分(这个更重要了) ， 主要功能就是得出AI的下一步走法。</p></blockquote><h3 id="alpha-beta剪枝搜索"><a href="#alpha-beta剪枝搜索" class="headerlink" title="alpha_beta剪枝搜索"></a>alpha_beta剪枝搜索</h3><blockquote><p>未了解过此算法的可先去看<br><a href="http://blog.csdn.net/to_be_better/article/details/50464280"> 最大最小搜索 </a><br><a href="http://blog.csdn.net/to_be_better/article/details/50464320"> Alpha-Beta剪枝 </a><br>上面两文解释的很清楚了，在此就不再赘述。</p></blockquote><h3 id="估值函数"><a href="#估值函数" class="headerlink" title="估值函数"></a>估值函数</h3><blockquote><p>判断是否能成5, 如果是机器方的话给予100000分，如果是人方的话给予－100000 分；<br>判断是否能成活4或者是双死4或者是死4活3，如果是机器方的话给予10000分，如果是人方的话给予－10000分；<br>判断是否已成双活3，如果是机器方的话给予5000分，如果是人方的话给予－5000 分；<br>判断是否成死3活3，如果是机器方的话给予1000分，如果是人方的话给予－1000 分；<br>判断是否能成死4，如果是机器方的话给予500分，如果是人方的话给予－500分；<br>判断是否能成单活3，如果是机器方的话给予200分，如果是人方的话给予－200分；<br>判断是否已成双活2，如果是机器方的话给予100分，如果是人方的话给予－100分；<br>判断是否能成死3，如果是机器方的话给予50分，如果是人方的话给予－50分；<br>判断是否能成双活2，如果是机器方的话给予10分，如果是人方的话给予－10分；<br>判断是否能成活2，如果是机器方的话给予5分，如果是人方的话给予－5分；<br>判断是否能成死2，如果是机器方的话给予3分，如果是人方的话给予－3分。</p></blockquote><h2 id="存在的问题以及未完成的地方"><a href="#存在的问题以及未完成的地方" class="headerlink" title="存在的问题以及未完成的地方"></a>存在的问题以及未完成的地方</h2><blockquote><p>最主要的问题就是偶尔会走臭棋。反复调试找原因，甚至把搜索方法又重新写了一遍，还是无果。觉得问题出现在估值函数上，但又想不出如何解决。<br>未完成的地方当然是提高搜索的效率了，每次估值都是要全盘进行估值，这样造成的时间影响是很大的，还可以用位棋盘来保存局面的情况，每走一步进行更新，每次回溯时再恢<br>复，这样估值时之用考虑最近的一步，而不是全局了。这个等日后有时间再好好改进一下吧。<br>对于输赢的判断已经有了，但是还少了UI部分的显示，只是仅仅输出提示在命令行上。</p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="AI走法搜索部分-－－"><a href="#AI走法搜索部分-－－" class="headerlink" title="AI走法搜索部分 －－"></a>AI走法搜索部分 －－</h3><pre><code class="hljs">import java.util.Random;/** * Created by shiyi on 16/3/14. */public class Robot &#123;    private static ChessBoard chess = ChessBoard.getInstance();    private Robot() &#123;&#125;    private static int depth = 1;    private static int robotColor = chess.BLACK;    private static Robot robot = new Robot();    public static Robot getRobot() &#123;        return robot;    &#125;    /* alpha_beta剪枝搜索 */    public int alpha_betaFind(int depth, int alpha, int beta, int color, int prex, int prey) &#123;        if(depth &gt;= Robot.depth || 0 != chess.isEnd(prex, prey, color%2+1)) &#123;            int ans = chess.reckon(robotColor) - chess.reckon(robotColor%2 + 1);            if(depth % 2 == 0)                ans = -ans;            return ans;        &#125;        for(int x=1; x&lt;=chess.N; x++) &#123;            for(int y=1; y&lt;=chess.N; y++) &#123;                if(!chess.isEmpty(x, y))                    continue;                chess.makeMove(x, y, color);                int val = -alpha_betaFind(depth+1, -beta, -alpha, color%2+1, x, y);                chess.unMove(x, y);                if(val &gt;= beta)                    return beta;                if(val &gt; alpha)                    alpha = val;            &#125;        &#125;        return alpha;    &#125;    /* 返回AI走法 */    public int[] getNext(int color) &#123;        int rel[] = new int[2];        int ans = -100000000;        Random random = new Random();        for(int x=1; x&lt;=chess.N; x++) &#123;            for(int y=1; y&lt;=chess.N; y++) &#123;                if(!chess.isEmpty(x, y))                    continue;                chess.makeMove(x, y, color);                int val = -alpha_betaFind(0, -100000000, 100000000, color%2 + 1, x, y);                int ra = random.nextInt(100);                if(val &gt; ans || val == ans &amp;&amp; ra &gt;= 50) &#123;                    ans = val;                    rel[0] = x;                    rel[1] = y;                &#125;                chess.unMove(x, y);            &#125;        &#125;        return rel;    &#125;&#125;</code></pre><h3 id="落子撤子以及估值-－－ChessBoard"><a href="#落子撤子以及估值-－－ChessBoard" class="headerlink" title="落子撤子以及估值 －－ChessBoard"></a>落子撤子以及估值 －－ChessBoard</h3><pre><code class="hljs">/** * Created by shiyi on 16/3/14. */public class ChessBoard &#123;    public final int N = 15;    public final int EMPTY = 0;    public final int BLACK = 1;    public final int WHITE = 2;    public int[][] board = new int[N+1][N+1];    private ChessBoard() &#123;&#125;    private static final ChessBoard chess = new ChessBoard();    /* 返回类单例 */    public static ChessBoard getInstance() &#123;        return chess;    &#125;    /*  判断该位置是否无子 */    public boolean isEmpty(int x, int y) &#123;        return board[x][y] == EMPTY;    &#125;    /* 落子 */    public void makeMove(int x, int y, int color) &#123;        board[x][y] = color;    &#125;    /* 撤子 */    public void unMove(int x, int y) &#123;        board[x][y] = EMPTY;    &#125;    public int reckon(int color) &#123;        int dx[] = &#123;1, 0, 1, 1&#125;;        int dy[] = &#123;0, 1, 1, -1&#125;;        int ans = 0;        for(int x=1; x&lt;=N; x++) &#123;            for (int y = 1; y &lt;= N; y++) &#123;                if (board[x][y] != color)                    continue;                int num[][] = new int[2][100];                for (int i = 0; i &lt; 4; i++) &#123;                    int sum = 1;                    int flag1 = 0, flag2 = 0;                    int tx = x + dx[i];                    int ty = y + dy[i];                    while (tx &gt; 0 &amp;&amp; tx &lt;= N                            &amp;&amp; ty &gt; 0 &amp;&amp; ty &lt;= N                            &amp;&amp; board[tx][ty] == color) &#123;                        tx += dx[i];                        ty += dy[i];                        ++sum;                    &#125;                    if(tx &gt; 0 &amp;&amp; tx &lt;= N                            &amp;&amp; ty &gt; 0 &amp;&amp; ty &lt;= N                            &amp;&amp; board[tx][ty] == EMPTY)                        flag1 = 1;                    tx = x - dx[i];                    ty = y - dy[i];                    while (tx &gt; 0 &amp;&amp; tx &lt;= N                            &amp;&amp; ty &gt; 0 &amp;&amp; ty &lt;= N                            &amp;&amp; board[tx][ty] == color) &#123;                        tx -= dx[i];                        ty -= dy[i];                        ++sum;                    &#125;                    if(tx &gt; 0 &amp;&amp; tx &lt;= N                            &amp;&amp; ty &gt; 0 &amp;&amp; ty &lt;= N                            &amp;&amp; board[tx][ty] == EMPTY)                        flag2 = 1;                    if(flag1 + flag2 &gt; 0)                        ++num[flag1 + flag2 - 1][sum];                &#125;                //成5                if(num[0][5] + num[1][5] &gt; 0)                    ans = Math.max(ans, 100000);                    //活4 | 双死四 | 死4活3                else if(num[1][4] &gt; 0                        || num[0][4] &gt; 1                        || (num[0][4] &gt; 0 &amp;&amp; num[1][3] &gt; 0))                    ans = Math.max(ans, 10000);                    //双活3                else if(num[1][3] &gt; 1)                    ans = Math.max(ans, 5000);                    //死3活3                else if(num[1][3] &gt; 0 &amp;&amp; num[0][3] &gt; 0)                    ans = Math.max(ans, 1000);                    //死4                else if(num[0][4] &gt; 0)                    ans = Math.max(ans, 500);                    //单活3                else if(num[1][3] &gt; 0)                    ans = Math.max(ans, 200);                    //双活2                else if(num[1][2] &gt; 1)                    ans = Math.max(ans, 100);                    //死3                else if(num[0][3] &gt; 0)                    ans = Math.max(ans, 50);                    //双活2                else if(num[1][2] &gt; 1)                    ans = Math.max(ans, 10);                    //单活2                else if(num[1][2] &gt; 0)                    ans = Math.max(ans, 5);                    //死2                else if(num[0][2] &gt; 0)                    ans = Math.max(ans, 1);            &#125;        &#125;        return ans;    &#125;    /* 判断局面是否结束 0未结束 1WHITE赢 2BLACK赢 */    public int isEnd(int x, int y, int color) &#123;        int dx[] = &#123;1, 0, 1, 1&#125;;        int dy[] = &#123;0, 1, 1, -1&#125;;        for (int i = 0; i &lt; 4; i++) &#123;            int sum = 1;            int tx = x + dx[i];            int ty = y + dy[i];            while (tx &gt; 0 &amp;&amp; tx &lt;= N                    &amp;&amp; ty &gt; 0 &amp;&amp; ty &lt;= N                    &amp;&amp; board[tx][ty] == color) &#123;                tx += dx[i];                ty += dy[i];                ++sum;            &#125;            tx = x - dx[i];            ty = y - dy[i];            while (tx &gt; 0 &amp;&amp; tx &lt;= N                    &amp;&amp; ty &gt; 0 &amp;&amp; ty &lt;= N                    &amp;&amp; board[tx][ty] == color) &#123;                tx -= dx[i];                ty -= dy[i];                ++sum;            &#125;            if(sum &gt;= 5)                return color;        &#125;        return 0;    &#125;&#125;</code></pre><h2 id="UI部分-1"><a href="#UI部分-1" class="headerlink" title="UI部分"></a>UI部分</h2><pre><code class="hljs">import java.awt.*;import java.awt.event.MouseEvent;import java.awt.event.MouseListener;import java.util.Random;/** * Created by shiyi on 16/3/15. */public class UI &#123;    private ChessBoard chess = ChessBoard.getInstance();    private int userColor = chess.WHITE;    private int robotColor = chess.BLACK;    private Frame frame = new Frame(&quot;绘制棋盘&quot;);    private MyChess drawArea = new MyChess();    private Robot robot = Robot.getRobot();    public void init()&#123;        Panel p = new Panel();        //机器执先        chess.makeMove(chess.N/2+1, chess.N/2+1, chess.BLACK);        drawArea.setPreferredSize(new Dimension(720, 720));        drawArea.addMouseListener(new MouseListener() &#123;            @Override            public void mouseClicked(MouseEvent e) &#123;                int x = e.getX();                int y = e.getY();                int i = (x-60)/40+1;                int j = (y-60)/40+1;                System.out.println(i+&quot;---&quot;+j);                if(chess.isEmpty(i, j)) &#123;                    chess.makeMove(i, j, userColor);                    int rel = chess.isEnd(i, j, userColor);                    if(rel != 0) &#123;                        System.out.println(&quot;玩家胜利&quot;);                        return;                    &#125;                    drawArea.repaint();                    int rob[] = robot.getNext(robotColor);                    chess.makeMove(rob[0], rob[1], robotColor);                    rel = chess.isEnd(rob[0], rob[1], robotColor);                    if(rel != 0) &#123;                        System.out.println(&quot;机器胜利&quot;);                        return;                    &#125;                    drawArea.repaint();                &#125;            &#125;            @Override            public void mousePressed(MouseEvent e) &#123;            &#125;            @Override            public void mouseReleased(MouseEvent e) &#123;            &#125;            @Override            public void mouseEntered(MouseEvent e) &#123;            &#125;            @Override            public void mouseExited(MouseEvent e) &#123;            &#125;        &#125;);        frame.add(drawArea);        frame.setSize(900, 720);        frame.setVisible(true);    &#125;&#125;class MyChess extends Canvas &#123;    private ChessBoard chess = ChessBoard.getInstance();    private final int N = chess.N + 2;    private final int square = 40;    private final int stx = square;    private final int sty = square;    private final int length = (N-1)*square;    public void drawPiece(int color, int x, int y, Graphics g) &#123;        if (color == chess.BLACK) &#123;            g.setColor(new Color(0, 0, 0));            g.fillArc(stx + x * square - 19, sty + y * square - 19, 38, 38, 0, 360);        &#125; else if (color == chess.WHITE) &#123;            g.setColor(new Color(255, 255, 255));            g.fillArc(stx + x * square - 19, sty + y * square - 19, 38, 38, 0, 360);        &#125;    &#125;    public void paint(Graphics g) &#123;        g.setColor(new Color(0, 0, 0));        g.fillRect(stx-8, sty-8, stx+(N-2)*square+15, sty+(N-2)*square+15);        g.setColor(new Color(139, 255, 71));        g.fillRect(stx-4, sty-4, stx+(N-2)*square+7, sty+(N-2)*square+7);        g.setColor(new Color(0, 0, 0));        g.fillArc(stx+8*square-6, sty+8*square-6, 12, 12, 0, 360);        g.fillArc(stx+4*square-6, sty+4*square-6, 12, 12, 0, 360);        g.fillArc(stx+4*square-6, sty+12*square-6, 12, 12, 0, 360);        g.fillArc(stx+12*square-6, sty+4*square-6, 12, 12, 0, 360);        g.fillArc(stx+12*square-6, sty+12*square-6, 12, 12, 0, 360);        for(int i = 0; i &lt; N; i++) &#123;            g.drawLine(stx+i*square, sty, stx+i*square, sty+length);            g.drawLine(stx, sty+i*square, stx+length, sty+i*square);        &#125;        for(int i=1; i&lt;=chess.N; i++) &#123;            for(int j=1; j&lt;=chess.N; j++) &#123;                drawPiece(chess.board[i][j], i, j, g);            &#125;        &#125;    &#125;&#125;</code></pre><h3 id="Main"><a href="#Main" class="headerlink" title="Main"></a>Main</h3><pre><code class="hljs">/** * Created by shiyi on 16/3/14. */public class Main &#123;    public static void main(String[] args) &#123;        System.out.println(&quot;游戏开始&quot;);        UI ui = new UI();        ui.init();    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>游戏开发</tag>
      
      <tag>人机对弈</tag>
      
      <tag>Java</tag>
      
      <tag>智能算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>快慢指针判断单向链表是否有环及找环入口</title>
    <link href="/posts/25671.html"/>
    <url>/posts/25671.html</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>关于快慢指针找环入口的这个问题，之前巴特跟我聊到过，印象比较深，今晚看学长在做的面试题，里面就出现了这个小知识。<br>发现有些东西不经意间就会用到，于是便出现此文。以后要努力做到善于总结，乐于总结。</p></blockquote><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><blockquote><p>快慢指针，所谓的快慢，就是指 ** 指针每次移动的步长 ** ，通常使快指针每次向前移动两步，慢指针每次向前移动一步。</p></blockquote><h2 id="判断链表环及找环入口"><a href="#判断链表环及找环入口" class="headerlink" title="判断链表环及找环入口"></a>判断链表环及找环入口</h2><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><blockquote><p>从链表头节点开始，快慢指针同时开始移动，快指针每次移动2，慢指针每次移动1，若快指针最终与慢指针相遇，则表示链表有环，否则，则为无环。<br>有环情况下，快慢指针相遇时，慢指针位置不变，将快指针置回表头，步长改为每次移1，快慢指针同时开始移动，再次相遇处即为环的入口。</p></blockquote><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><blockquote><p>判断是否有环就不解释了，下面主要解释，为什么可以那样找环入口。</p></blockquote><pre><code class="hljs">        ⬇️&lt;-&lt;-&lt;-⬆️        ⬇️      ⬆️♦️－&gt;-&gt;-&gt;⬇️-&gt;-&gt;-&gt;⬆️A       B       C</code></pre><blockquote><p>只是个简单图，就不专门做图了，凑合表示下吧。<br>♦️也就是A的位置是头节点，B表示环入口处，C表示快慢指针第一次相遇处。<br>在C处相遇时，设慢指针跑了N步，也就是从A开始N步后会到达C。<br>快指针比慢指针走的快一倍，也就是走了2*N步。那么慢指针从C处再跑N步还会回到C处。<br>既然都会回到C处，那么必然会在B点第一次相遇。<br>所以我们在入口处再设一指针(用之前快指针即可)，与慢指针用1步长同时前进，第一次相遇处就是环入口处。</p></blockquote><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="hljs">/* 代码很简单 */List* func(List* Head)&#123;    List* fast, slow;    fast = slow = Head;    while(fast != slow &amp;&amp; fast != NULL)    &#123;        slow = slow-&gt;next;        fast = fast-&gt;next;        if(fast != NULL)            fast = fast-&gt;next;    &#125;    if(fast == NULL)        return true;    fast = Head;    while(fast != slow)    &#123;        fast = fast-&gt;next;        slow = slow-&gt;next;    &#125;    return fast;&#125;</code></pre><h2 id="其他应用"><a href="#其他应用" class="headerlink" title="其他应用"></a>其他应用</h2><blockquote><p>譬如，给定一有序链表，求其中位数，因为不知道链表的具体长度，常规做法是先遍历一次，确定链表的长度，再遍历到中点，求出中位数。<br>但其实还有个更巧妙的法子，很方便的求出中位数，就是用快慢指针。<br>仍然是快指针步长为2，慢指针步长为1，当快指针到达链表尾部的时候，快指针就处于中点位置.(会牵扯到链表总数奇偶的情况，判断下即可，这里就不多赘述了)。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>归并排序非递归(想得通不写通还是空，懒病要治)</title>
    <link href="/posts/57744.html"/>
    <url>/posts/57744.html</url>
    
    <content type="html"><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><blockquote><p>现在有两个数组a, b，都是有序的，要你将他们合并成一个数组，你会怎么做呢，当然不会直接合并再排序了，而是如下操作</p></blockquote><pre><code class="hljs">1. 设两标志指针分别指向a,b的首元素。2. 比较当前a,b当前首位元素，选择较小的加入临时数组t，相应的标志指针后移。3. 重复2过程，知道a.b任一方已全部加入t，然后到步骤44. 将未完全加入的数组剩余元素全部加入。</code></pre><blockquote><p>这样合并两个数组的时间复杂度是O(len(a) + len(b))。<br>那么联想到归并排序，我们已经能大致猜出来他的排序的流程啦。如下图所示。<br><img src="http://img.blog.csdn.net/20160307160809310" alt="这里写图片描述"></p></blockquote><blockquote></blockquote><blockquote><p>没错， ** 归并排序就是不断的将数组二分，直到元素数为1，然后再合并(如上面说到的合并数组)，形成有序的序列，是一个快速且稳定的排序算法 **</p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><blockquote><p>原理很好理解，不做赘述，明白原理后，写出递归的归并排序是很容易的，下面会贴出递归的代码。<br>今天主要说下非递归的思路。<br>递归式的思想是先二分再合并的一个流程。而我们非递归时可以直接对它们进行合并，而不必二分(事实上每个元素都在各自下标处，完全可以当作已经二分好了)，当然，这里<br>的边界什么的需要自己用循环来规定了。<br>而且非递归相比递归还有一个特殊的地方，比如下面这个序列<br>8 3 4 5 7 2 1 3<br>递归的情况下，不会考虑它们的数值，而是直接进行二分，我们最终会进行4+2+1=7次合并操作。<br>但我们在非递归下就可以趁机对此改进。比如3 4 5 7，我们完全没有必要去将它们二分，因为它们已经是有序的了，只需要将其与相邻序列串合并就好。<br>那么我们会将其分为这些序列<br>8 ｜ 3 4 5 7 ｜ 2 ｜ 1 3<br>然后将8 与 3 4 5 7 合并为 3 4 5 7 8<br>同理，2与1 3为 1 2 3<br>再合并即为 1 2 3 3 4 5 7 8<br>我们只用了3次合并操作，对比递归已经好了很多。<br>不说了，上代码</p></blockquote><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><h4 id="非递归"><a href="#非递归" class="headerlink" title="非递归"></a>非递归</h4><pre><code class="hljs">#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;#define LL long longconst int N = 21;int d[N];int t[N];void func(const pair&lt;int, int&gt; &amp;a, const pair&lt;int, int&gt; &amp;b)&#123;    int i=0;    for(int sa = a.first, sb = b.first; sa&lt;=a.second || sb&lt;=b.second;)    &#123;        if(sa &lt;= a.second &amp;&amp; sb &lt;= b.second)        &#123;            if(d[sa] &lt;= d[sb])                t[i++] = d[sa++];            else                t[i++] = d[sb++];        &#125;        else if(sa &lt;= a.second)            t[i++] = d[sa++];        else            t[i++] = d[sb++];    &#125;    for(int j=0; j&lt;i; j++)        d[j+a.first] = t[j];&#125;void merge_sort(int st, int end)&#123;    while(1)    &#123;        int l = st;        vector&lt;pair&lt;int, int&gt;&gt; v;        for(int i=st+1; i&lt;=end; i++)        &#123;            if(d[i] &lt; d[i-1])            &#123;                v.push_back(pair&lt;int, int&gt;(l, i-1));                l = i;            &#125;        &#125;        if(l == st)            break;        v.push_back(pair&lt;int, int&gt;(l, end));        for(int i=1; i&lt;v.size(); i+=2)            func(v[i-1],v[i]);    &#125;&#125;int main()&#123;    int n;    cin&gt;&gt;n;    for(int i=0; i&lt;n; i++)        cin&gt;&gt;d[i];    merge_sort(0, n-1);    for(int i=0; i&lt;n; i++)        cout&lt;&lt;d[i]&lt;&lt;&quot; &quot;;    cout&lt;&lt;endl;    return 0;&#125;</code></pre><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><pre><code class="hljs">#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;#define LL long longconst int N = 21;int d[N];int t[N];void func(const pair&lt;int, int&gt; &amp;a, const pair&lt;int, int&gt; &amp;b)&#123;    int i=0;    for(int sa = a.first, sb = b.first; sa&lt;=a.second || sb&lt;=b.second;)    &#123;        if(sa &lt;= a.second &amp;&amp; sb &lt;= b.second)        &#123;            if(d[sa] &lt;= d[sb])                t[i++] = d[sa++];            else                t[i++] = d[sb++];        &#125;        else if(sa &lt;= a.second)            t[i++] = d[sa++];        else            t[i++] = d[sb++];    &#125;    for(int j=0; j&lt;i; j++)        d[j+a.first] = t[j];&#125;void merge_sort(int st, int ed)&#123;    if(st &gt;= ed)        return;    int mid = st+(ed-st)/2;    tmerge_sort(st, mid);    tmerge_sort(mid+1, ed);    func(pair&lt;int, int&gt;(st, mid), pair&lt;int, int&gt; (mid+1, ed));&#125;int main()&#123;    int n;    cin&gt;&gt;n;    for(int i=0; i&lt;n; i++)        cin&gt;&gt;d[i];    merge_sort(0, n-1);    for(int i=0; i&lt;n; i++)        cout&lt;&lt;d[i]&lt;&lt;&quot; &quot;;    cout&lt;&lt;endl;    return 0;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU 4549 M斐波那契数列(矩阵快速幂&amp;费马小定理)</title>
    <link href="/posts/35220.html"/>
    <url>/posts/35220.html</url>
    
    <content type="html"><![CDATA[<h4 id="ps：今天和战友聊到矩阵快速幂，想到前几天学长推荐去刷矩阵专题，挑了其中唯一一道中文题，没想到越过山却被河挡住去路。。。"><a href="#ps：今天和战友聊到矩阵快速幂，想到前几天学长推荐去刷矩阵专题，挑了其中唯一一道中文题，没想到越过山却被河挡住去路。。。" class="headerlink" title="ps：今天和战友聊到矩阵快速幂，想到前几天学长推荐去刷矩阵专题，挑了其中唯一一道中文题，没想到越过山却被河挡住去路。。。"></a>ps：今天和战友聊到矩阵快速幂，想到前几天学长推荐去刷矩阵专题，挑了其中唯一一道中文题，没想到越过山却被河挡住去路。。。</h4><p>题目链接： <a href="http://acm.hust.edu.cn/vjudge/contest/view.action?cid=71746#problem/R"> [kuangbin带你飞]专题十九 矩阵 R - M斐波那契数列</a></p><pre><code class="hljs">Time Limit:1000MS     Memory Limit:32768KB     64bit IO Format:%I64d &amp; %I64u</code></pre><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><h4 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h4><blockquote><p>M斐波那契数列F[n]是一种整数数列，它的定义如下：</p></blockquote><blockquote></blockquote><blockquote><p>F[0] = a<br>F[1] = b<br>F[n] = F[n-1] * F[n-2] ( n &gt; 1 )</p></blockquote><blockquote></blockquote><blockquote><p>现在给出a, b, n，你能求出F[n]的值吗？</p></blockquote><h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><blockquote><p>输入包含多组测试数据；<br>每组数据占一行，包含3个整数a, b, n（ 0 &lt;= a, b, n &lt;= 10^9 ）</p></blockquote><h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><blockquote><p>对每组测试数据请输出一个整数F[n]，由于F[n]可能很大，你只需输出F[n]对1000000007取模后的值即可，每组数据输出一行。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><blockquote><p>一看到题，就拿二维01矩阵变来变去尝试半天，无果，就手推了几部，猛然发现f[i] = a^fib[i-<br>1]*b^fib[i]。道友们动动手，很容易就能发现。<br>然后就是刷刷的矩阵快速幂求fib，求出两数，再快速幂，结果得出，俩样例试过没问题，提交，wrong。。。<br>找来找去，找不出错误在哪，去百度了下，发现别人在对矩阵快速幂的时候都是对MOD-1取余的，顿时纳闷，才发现自己忽略了a^b时迭代时不能直接取余的。<br>看解释说是由费马小定理可以得出循环节是MOD-1，所以对MOD-<br>1取余。仔细的看了费马小定理，似懂非懂的，至于循环节，压根就没想通，可怜在数论上几近一张白纸的我。(ps：过两天好好研究研究)</p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="hljs">#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;#include &lt;cmath&gt;#include &lt;map&gt;using namespace std;#define LL long longconst int MOD = 1000000007;struct Node&#123;    LL a, b, c, d;    Node()&#123;&#125;;    Node(LL a, LL b, LL c, LL d)    :a(a),b(b),c(c),d(d)&#123;&#125;    Node operator*(const Node&amp; t)    &#123;        Node ans;        ans.a = ((this-&gt;a*t.a)%(MOD-1)+(this-&gt;b*t.c)%(MOD-1))%(MOD-1);        ans.b = ((this-&gt;a*t.b)%(MOD-1)+(this-&gt;b*t.d)%(MOD-1))%(MOD-1);        ans.c = ((this-&gt;c*t.a)%(MOD-1)+(this-&gt;d*t.c)%(MOD-1))%(MOD-1);        ans.d = ((this-&gt;c*t.b)%(MOD-1)+(this-&gt;d*t.d)%(MOD-1))%(MOD-1);        return ans;    &#125;&#125;;LL qpower(LL n, LL x)&#123;    LL ans = 1;    LL p = x;    while(n)    &#123;        if(n &amp; 1)            ans = (ans*p)%MOD;        p = (p*p)%MOD;        n &gt;&gt;= 1;    &#125;    return ans;&#125;int main()&#123;    LL a, b, n;    while(cin&gt;&gt;a&gt;&gt;b&gt;&gt;n)    &#123;        Node p = Node(0, 1, 1, 1);        Node ans = Node(1, 0, 0, 1);        if(n == 0)        &#123;            cout&lt;&lt;a&lt;&lt;endl;            continue;        &#125;        --n;        while(n)        &#123;            if(n &amp; 1)                ans = ans*p;            p = p*p;            n &gt;&gt;= 1;        &#125;        LL fiba = ans.b;        LL fibb = ans.d;        LL rel = 0;        rel = (qpower(fiba, a) * qpower(fibb, b))%MOD;        cout&lt;&lt;rel&lt;&lt;endl;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>矩阵</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态规划之最优配对问题</title>
    <link href="/posts/17644.html"/>
    <url>/posts/17644.html</url>
    
    <content type="html"><![CDATA[<h2 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h2><blockquote><p>昨晚看了紫书上的最优配对问题，对于上面没有对i判断就直接取异或操作百思不得解，本想今天问学长，百度了下，才知道那里是作者写错了，唉，有点唏嘘，学的越多，<br>对待权威越不敢坚信自己了。。。</p></blockquote><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><blockquote><p>空间里有n个点P0,P1,…,Pn-1，你的任务是把它们配成n/2对（n是偶数），使得每个点恰好在一个点对中。所有点对中两点的距离之和应尽量小。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><blockquote><p>因为是对集合进行配对，自然需要记录当前集合的状态，老方法，二进制。<br>dp(s) = min(dist(i, j) + dp(s-i-j))<br>i是s集合中最小的元素的下标(最小最大都可以，只是作为检索起点)，j是s集合中其他元素的下标<br>s从1到1左移n再-1进行迭代，因为s-i-j必然小于s，所以直接迭代就可以，连递归都省去了。</p></blockquote><blockquote></blockquote><blockquote><p>因为没有在oj上找到类似的题目，就百度上找到别人做的一组数据，直接copy了，答案无误，正确性暂时未知，如有道友发现问题，还请不吝告之。</p></blockquote><pre><code class="hljs">测试数据：Input：201 2 31 1 15 6 24 7 82 3 11 4 72 5 83 6 91 2 52 3 64 5 27 8 54 5 1-1 2 3-1 -9 -70 0 0100 0 09 5 17 5 35 5 5Output：119.076</code></pre><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="hljs">#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;#include &lt;cmath&gt;#include &lt;map&gt;using namespace std;#define LL long longconst int N = 29;int x[N], y[N], z[N];double dist[N][N];double dp[(1&lt;&lt;N)];void init_dist(int n)&#123;    for(int i=0; i&lt;n; i++)        for(int j=i+1; j&lt;n; j++)            dist[i][j] = sqrt((x[i]-x[j])*(x[i]-x[j])                +(y[i]-y[j])*(y[i]-y[j])                +(z[i]-z[j])*(z[i]-z[j]));&#125;double solve(int n)&#123;    for(int s=1; s&lt;(1&lt;&lt;n); s++)    &#123;        dp[s] = 1E9;        int pos = 0;        while(pos&lt;n &amp;&amp; !(s&amp;(1&lt;&lt;pos))) ++pos;        for(int i=pos+1; i&lt;n; i++)            if(s&amp;(1&lt;&lt;i))                dp[s] = min(dp[s], dist[pos][i]+dp[s^(1&lt;&lt;pos)^(1&lt;&lt;i)]);    &#125;    return dp[(1&lt;&lt;n)-1];&#125;int main()&#123;    int n;    cin&gt;&gt;n;    for(int i=0; i&lt;n; i++)        cin&gt;&gt;x[i]&gt;&gt;y[i]&gt;&gt;z[i];    init_dist(n);    dp[0] = 0;    cout&lt;&lt;solve(n)&lt;&lt;endl;    return 0;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BZOJ 1833 [ZJOI2010]count 数字计数(数位dp)</title>
    <link href="/posts/56469.html"/>
    <url>/posts/56469.html</url>
    
    <content type="html"><![CDATA[<p>** 题目链接 ** ： <a href="http://acm.hust.edu.cn/vjudge/contest/view.action?cid=70324#problem/D"> [kuangbin带你飞]专题十五 数位DP D - Bomb </a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><blockquote><p>输入n,m，求n～m范围内的所有数字中，分别输出0～9出现的总数是多少。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><blockquote><p>和 <a href="http://blog.csdn.net/to_be_better/article/details/50769075"> POJ 3286 How many 0’s? (数位dp)</a><br>的思路基本是一样的，只是略有区别。<br>0和1～9要分开处理，是因为前缀0的问题。因为当某一位取0时，前面部分的数是不能为0的，而取1～9是可以前面为0的。</p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="hljs">#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;#include &lt;cmath&gt;#include &lt;map&gt;using namespace std;#define LL long longLL p[20];LL ans[10] = &#123;&#125;;void init()&#123;    p[0] = 1;    for(int i=1; i&lt;18; i++)        p[i] = p[i-1]*10;&#125;void solve(LL x, int f)&#123;    if(x == -1)    &#123;        ans[0]++;        return;    &#125;    for(int k=1; k&lt;10; k++)    &#123;        for(int i=1; ; i++)        &#123;            LL l = x/p[i];            LL r = x%p[i-1];            LL now = x%p[i]/p[i-1];            if(now &gt; k)                ans[k] += (l+1)*p[i-1]*f;            else if(now == k)                ans[k] += (l*p[i-1]+r+1)*f;            else                ans[k] += l*p[i-1]*f;            if(p[i] &gt; x)                break;        &#125;    &#125;    for(int i=1; ; i++)    &#123;        LL l = x/p[i];        LL r = x%p[i-1];        LL now = x%p[i]/p[i-1];        if(now &gt; 0)            ans[0] += l*p[i-1]*f;        else            ans[0] += ((l-1)*p[i-1]+r+1)*f;        if(p[i] &gt; x)            break;    &#125;&#125;int main()&#123;    LL n, m;    init();    cin&gt;&gt;n&gt;&gt;m;    solve(m, 1);    solve(n-1, -1);    for(int i=0; i&lt;9; i++)        printf(&quot;%lld &quot;, ans[i]);    printf(&quot;%lld\n&quot;, ans[9]);    return 0;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ 3286 How many 0&#39;s?(数位dp)</title>
    <link href="/posts/26646.html"/>
    <url>/posts/26646.html</url>
    
    <content type="html"><![CDATA[<p>** 题目链接 ** ： <a href="http://acm.hust.edu.cn/vjudge/problem/viewProblem.action?id=17102"> POJ 3286 How many 0’s? </a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><blockquote><p>输入n,m，求n～m范围内的所有数字中，0出现的总数是多少。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><blockquote><p>用2034做个例子。<br>枚举0在个十百千位上出现的次数<br>个：个位为0时，后面不需要考虑，只需考虑前面，因为0比4小，所以前面即使取到最大也不会过限，所以前面可以是1~203(因为当前位是0，所以前面不能是0)。一<br>共203种。<br>十：十位为0时，前面取1～20，后面取0～9。一共123＊10种。<br>百：百位为0时，因为0与当前位上限0相等，所以前面取1时，后面可以取0～99，前面取2时，后面只能取0～34。一共1＊100＋35种。<br>千位显然不能为0，所以总数为0。<br>把上述思想转化为代码即可。</p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="hljs">#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;#include &lt;cmath&gt;#include &lt;map&gt;using namespace std;const int N = 10009;#define LL long longLL p[20];void init()&#123;    p[0] = 1;    for(int i=1; i&lt;18; i++)        p[i] = p[i-1]*10;&#125;LL solve(LL x)&#123;    if(x == -1)        return -1;    LL ans = 0;    for(int i=1; ; i++)    &#123;        LL l = x/p[i];        LL r = x%p[i-1];        LL now = x%p[i]/p[i-1];        if(now &gt; 0)            ans += l*p[i-1];        else            ans += (l-1)*p[i-1] + r+1;        if(p[i] &gt; x)            break;    &#125;    return ans;&#125;int main()&#123;    LL n, m;    init();    while(cin&gt;&gt;n&gt;&gt;m &amp;&amp; (n!=-1 || m!=-1))        printf(&quot;%lld\n&quot;, solve(m) - solve(n-1));    return 0;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UVA 10003 Cutting Sticks(区间dp)</title>
    <link href="/posts/46634.html"/>
    <url>/posts/46634.html</url>
    
    <content type="html"><![CDATA[<p>** 题目链接 ** ： <a href="http://acm.hust.edu.cn/vjudge/problem/viewProblem.action?id=19202"> UVA - 10003 Cutting Sticks </a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><blockquote><p>给一长度为L的棍子，和n个切割点，每次切割的代价为当前的棍子的长度，问最少的总切割代价是多少。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><blockquote><p>典型的区间dp<br>dp[i][j] = min(dp[i][k]+dp[k][j]+a[j]-a[i]) |i</p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h4 id="递推"><a href="#递推" class="headerlink" title="递推"></a>递推</h4><pre><code class="hljs">#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;#include &lt;cmath&gt;using namespace std;const int N = 59;int a[N];int dp[N][N];int main()&#123;    int l;    while(~scanf(&quot;%d&quot;, &amp;l) &amp;&amp; l)    &#123;        int n;        memset(dp, 0x3f, sizeof(dp));        scanf(&quot;%d&quot;, &amp;n);        for(int i=1; i&lt;=n; i++)        &#123;            dp[i-1][i] = 0;            scanf(&quot;%d&quot;, &amp;a[i]);        &#125;        dp[n][n+1] = 0;        a[0] = 0;        a[n+1] = l;        for(int len=2; len&lt;=n+1; len++)            for(int i=0; i+len&lt;=n+1; i++)                for(int k=i+1; k&lt;i+len; k++)                    dp[i][i+len] = min(dp[i][i+len], dp[i][k]+dp[k][i+len]+a[i+len]-a[i]);        printf(&quot;The minimum cutting is %d.\n&quot;, dp[0][n+1]);    &#125;    return 0;&#125;</code></pre><h4 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h4><pre><code class="hljs">#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;#include &lt;cmath&gt;using namespace std;const int N = 59;int a[N];int dp[N][N];int dfs(int i, int j)&#123;    if(dp[i][j] != -1)        return dp[i][j];    int ans = 0x3f3f3f3f;    for(int k=i+1; k&lt;j; k++)        ans = min(ans, dfs(i,k)+dfs(k,j)+a[j]-a[i]);    return dp[i][j] = ans;&#125;int main()&#123;    int l;    while(~scanf(&quot;%d&quot;, &amp;l) &amp;&amp; l)    &#123;        int n;        memset(dp, -1, sizeof(dp));        scanf(&quot;%d&quot;, &amp;n);        for(int i=1; i&lt;=n; i++)        &#123;            scanf(&quot;%d&quot;, &amp;a[i]);            dp[i-1][i] = 0;        &#125;        dp[n][n+1] = 0;        a[0] = 0;        a[n+1] = l;        printf(&quot;The minimum cutting is %d.\n&quot;, dfs(0, n+1));    &#125;    return 0;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU 3709 Balanced Number(数位dp)</title>
    <link href="/posts/29068.html"/>
    <url>/posts/29068.html</url>
    
    <content type="html"><![CDATA[<p>** 题目链接 ** ： <a href="http://acm.hust.edu.cn/vjudge/contest/view.action?cid=70324#problem/F"> [kuangbin带你飞]专题十五 数位DP F - Balanced Number </a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><blockquote><p>给定区间[a,b]，求区间内平衡数的个数。所谓平衡数即有一位做平衡点，左右两边数字的力矩想等。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><blockquote><p>遍历每一位做为平衡点，进行搜索，sum保存数字乘以距离的和，若sum为0，则说明平衡。<br>要注意因为遍历了len次，所以0多加了len－1次。<br>还有个小技巧是当sum&lt;0时就可以直接return了，可以加速。因为，len由大到小的过程中，sum是由大到小的变化，但绝不会小于0，否则就是不能平衡。</p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="hljs">#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;using namespace std;#define LL long longLL dp[20][20][2000];int dis[20];LL dfs(int len, int pos, int sum, bool flag)&#123;    if(len &lt; 0)        return sum?0:1;    if(sum &lt; 0)        return 0;    if(!flag &amp;&amp; dp[len][pos][sum] != -1)        return dp[len][pos][sum];    LL ans = 0;    int end = flag?dis[len]:9;    for(int i=0; i&lt;=end; i++)    &#123;        ans += dfs(len-1, pos, sum+(len-pos)*i, flag&amp;&amp;i==end);    &#125;    if(!flag)        dp[len][pos][sum] = ans;    return ans;&#125;LL solve(LL n)&#123;    int len = 0;    while(n)    &#123;        dis[len++] = n%10;        n /= 10;    &#125;    LL ans = 0;    for(int i=0; i&lt;len; i++)        ans += dfs(len-1, i, 0, 1);    return ans - (len-1);&#125;int main()&#123;    int T;    scanf(&quot;%d&quot;, &amp;T);    memset(dp, -1, sizeof(dp));    while(T--)    &#123;        LL l, r;        scanf(&quot;%lld%lld&quot;, &amp;l, &amp;r);        printf(&quot;%lld\n&quot;, solve(r) - solve(l-1));    &#125;    return 0;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU 4507 吉哥系列故事――恨7不成妻(数位dp&amp;好魔性的一道好题)</title>
    <link href="/posts/46178.html"/>
    <url>/posts/46178.html</url>
    
    <content type="html"><![CDATA[<p>** 题目链接 ** ： <a href="http://acm.hust.edu.cn/vjudge/contest/view.action?cid=70324#problem/J"> [kuangbin带你飞]专题十五 数位DP J - 吉哥系列故事――恨7不成妻 </a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>Time Limit:500MS Memory Limit:32768KB 64bit IO Format:%I64d &amp; %I64u</p><h4 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h4><blockquote><p>单身!<br>依然单身！<br>吉哥依然单身！<br>DS级码农吉哥依然单身！<br>所以，他生平最恨情人节，不管是214还是77，他都讨厌！</p></blockquote><p>吉哥观察了214和77这两个数，发现：<br>2+1+4=7<br>7+7=7<em>2<br>77=7</em>11<br>最终，他发现原来这一切归根到底都是因为和7有关！所以，他现在甚至讨厌一切和7有关的数！</p><blockquote></blockquote><blockquote><p>什么样的数和7有关呢？</p></blockquote><blockquote></blockquote><blockquote><p>如果一个整数符合下面3个条件之一，那么我们就说这个整数和7有关――<br>1、整数中某一位是7；<br>2、整数的每一位加起来的和是7的整数倍；<br>3、这个整数是7的整数倍；</p></blockquote><blockquote></blockquote><blockquote><p>现在问题来了：吉哥想知道在一定区间内和7无关的数字的平方和。</p></blockquote><h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><blockquote><p>输入数据的第一行是case数T(1 &lt;= T &lt;= 50)，然后接下来的T行表示T个case;每个case在一行内包含两个正整数L, R(1 &lt;= L<br>&lt;= R &lt;= 10^18)。</p></blockquote><h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><blockquote><p>请计算[L,R]中和7无关的数字的平方和，并将结果对10^9 + 7 求模后输出。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><blockquote><p>题目dp思路很好想，但麻烦的地方在于其要求的值是符合条件的树的平方和。<br>我们用pra记录前面位的数字和%7，prb记录前面位的数字的值%7。加上遍历时对7的筛除，我们很容易可以找出与7无关的数，但是怎样求平方和呢？</p></blockquote><blockquote></blockquote><blockquote><hr></blockquote><blockquote></blockquote><blockquote><p>我们用三个变量<br>cnt表示当前状态下的与7无关的数的个数，在搜索的过程中很容易得到<br>sum表示当前状态下的与7无关的数的合<br>那么newsum ＝ i<em>10^len</em>cnt + sum(i是当前选取的数，用cnt个加上cnt个数的和即sum，便是新的数的和)<br>sqsum表示当前状态下与7无关的数的平方和<br>(i<em>10^len + num)^2 = (i</em>10^len)^2 + 2<em>i</em>10^len<em>num + num^2;<br>而cnt个数的平方和就是<br>(i</em>10^len)^2<em>cnt + SUM(num^2) + 2</em>i<em>10^len</em>SUM(num)<br>即(i<em>10^len)^2</em>cnt + sqsum + 2<em>i</em>10^len*sum。</p></blockquote><blockquote></blockquote><blockquote><hr></blockquote><blockquote></blockquote><blockquote><p>ps:之所以说这题魔性，就是要考虑的小细节太招人烦了，题目中需要大量的取余，少一个就得wrong(说好的优雅写代码呢)<br>还有，因为取余的原因，ansr － ansl可能结果为负，所以要加上mod再取余。</p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="hljs">#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;using namespace std;#define LL long longconst int MOD = 1E9 + 7;struct Node&#123;    LL cnt;    LL sum;    LL sqsum;    Node()&#123;&#125;    Node(LL a, LL b, LL c):cnt(a), sum(b), sqsum(c)&#123;&#125;&#125;dp[20][7][7];int dis[20];LL c[20];Node dfs(int len, int pra, int prb, bool flag)&#123;    if(len &lt; 0)    &#123;        return Node(pra!=0 &amp;&amp; prb!=0, 0, 0);    &#125;    if(!flag &amp;&amp; dp[len][pra][prb].cnt != -1)        return dp[len][pra][prb];    int end = flag?dis[len]:9;    Node ans = Node(0, 0, 0);    for(int i=0; i&lt;=end; i++)    &#123;        if(i != 7)        &#123;            Node t = dfs(len-1, (pra+i)%7, (prb*10+i)%7, flag &amp;&amp; i==end);            ans.cnt = (ans.cnt + t.cnt) % MOD;            ans.sum += (((c[len]*i)%MOD*t.cnt)%MOD + t.sum) % MOD;            ans.sum %= MOD;            ans.sqsum += (t.sqsum + ((2*c[len]*i)%MOD*t.sum)%MOD) %MOD;            ans.sqsum %= MOD;            ans.sqsum += ((i*c[len]*i%MOD)*c[len]%MOD * t.cnt) %MOD;            ans.sqsum %= MOD;        &#125;    &#125;    if(!flag)        dp[len][pra][prb] = ans;    return ans;&#125;void init()&#123;    c[0] = 1;    for(int i=1; i&lt;20; i++)        c[i] = (c[i-1]*10) % MOD;&#125;LL solve(LL n)&#123;    int len = 0;    while(n)    &#123;        dis[len++] = n%10;        n /= 10;    &#125;    Node ans;    ans = dfs(len-1, 0, 0, 1);    return ans.sqsum;&#125;int main()&#123;    int T;    scanf(&quot;%d&quot;, &amp;T);    init();    memset(dp, -1, sizeof(dp));    while(T--)    &#123;        LL l, r;        scanf(&quot;%lld%lld&quot;, &amp;l, &amp;r);        printf(&quot;%lld\n&quot;, (solve(r) - solve(l-1) + MOD) % MOD);    &#125;    return 0;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ 3468 A Simple Problem with Integers(段更新的区间求和&amp;Lazy思想&amp;线段树)</title>
    <link href="/posts/32279.html"/>
    <url>/posts/32279.html</url>
    
    <content type="html"><![CDATA[<p>** 题目链接 ** ： <a href="http://acm.hust.edu.cn/vjudge/contest/view.action?cid=66989#problem/C"> [kuangbin带你飞]专题七 线段树 C - A Simple Problem with Integers </a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><blockquote><p>给定n个数及m个操作。<br>操作分两种：<br>1. C a b c，表示对区间ab整体全部加上c<br>2. Q a b ，对区间ab求和并输出。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><blockquote><p>看到段更新，第一反应是给点更新外面加个for，但显然不可行。<br>了解到有个Lazy思想，即 ** 记录每一个线段树节点的变化值，当这部分线段的一致性被破坏我们就将这个变化值传递给子区间，大大增加了线段树的效率。 **<br>这个思想可以简单的用一个比喻来描述：一个四口之家每月都可以领国家的补贴，国家发放时自然是发到他们整体，那么孩子与父母分家后呢，怎么办，这时就需要在牠们家庭的<br>基础上进一步分开分配了(例子不是很形象，大概就是这个意思)。<br>我们用两个数组Sum和Add，Sum表示当前区间的和，Add表示当前区间所整体增加的值。<br>两个操作，PushUp(子向父更新)，PushDown(父向子更新)<br>继续上面的比喻，你是那个四口之家的小孩，平日里补贴肯定是到不了你手上，所以也就没必要去算你到底有多少，那么当你某时需要用呢(进行求和操作时)，你再问父亲要(<br>这个时候进行PushDown操作)。<br>这样的话，在update就免去了很多不必要的操作，效率大大提升。</p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="hljs">#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;using namespace std;const int N = 100009;const int MAX = N*3;long long Sum[MAX], Add[MAX] = &#123;&#125;;void PushUp(int k)&#123;    Sum[k] = Sum[k&lt;&lt;1] + Sum[k&lt;&lt;1 | 1];&#125;void PushDown(int k, int num)&#123;    if(!Add[k])        return;    Add[k&lt;&lt;1] += Add[k];    Add[k&lt;&lt;1 | 1] += Add[k];    Sum[k&lt;&lt;1] += ((num+1)&gt;&gt;1)*Add[k];    Sum[k&lt;&lt;1 | 1] += (num&gt;&gt;1)*Add[k];    Add[k] = 0;&#125;void build(int l, int r, int k)&#123;    Add[k] = 0;    if(l == r)    &#123;        scanf(&quot;%lld&quot;, &amp;Sum[k]);        return;    &#125;    int mid = (l+r)&gt;&gt;1;    build(l, mid, k&lt;&lt;1);    build(mid+1, r, k&lt;&lt;1 | 1);    PushUp(k);&#125;void update(int l, int r, int tol, int tor, int d, int k)&#123;    if(tol &lt;= l &amp;&amp; tor &gt;= r)    &#123;        Add[k] += d;        Sum[k] += d*(r-l+1);        return;    &#125;    PushDown(k, r-l+1);    int mid = (l+r)&gt;&gt;1;    if(tol &lt;= mid)        update(l, mid, tol, tor, d, k&lt;&lt;1);    if(tor &gt; mid)        update(mid+1, r, tol, tor, d, k&lt;&lt;1 | 1);    PushUp(k);&#125;long long find(int l, int r, int tol, int tor, int k)&#123;    if(tol &lt;= l &amp;&amp; tor &gt;= r)        return Sum[k];    PushDown(k, r-l+1);    int mid = (l+r)&gt;&gt;1;    long long ans = 0;    if(tol &lt;= mid)        ans += find(l, mid, tol, tor, k&lt;&lt;1);    if(tor &gt; mid)        ans += find(mid+1, r, tol, tor, k&lt;&lt;1 | 1);    return ans;&#125;int main()&#123;    int n, m;    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);    build(1, n, 1);    char str[10];    int i, j, k;    while(m--)    &#123;        scanf(&quot;%s&quot;, str);        if(str[0] == &#39;C&#39;)        &#123;            scanf(&quot;%d%d%d&quot;, &amp;i, &amp;j, &amp;k);            update(1, n, i, j, k, 1);        &#125;        else        &#123;            scanf(&quot;%d%d&quot;, &amp;i, &amp;j);            printf(&quot;%lld\n&quot; ,find(1, n, i, j, 1));        &#125;    &#125;    return 0;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>线段树&amp;amp;树状数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU 1754 I Hate It(区间最值问题、线段树)</title>
    <link href="/posts/47926.html"/>
    <url>/posts/47926.html</url>
    
    <content type="html"><![CDATA[<p>** 题目链接 ** ： <a href="http://acm.hust.edu.cn/vjudge/contest/view.action?cid=66989#problem/B"> [kuangbin带你飞]专题七 线段树 B - I Hate It </a></p><pre><code class="hljs">Time Limit:3000MS     Memory Limit:32768KB     64bit IO Format:%I64d &amp; %I64u</code></pre><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><h4 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h4><blockquote><p>很多学校流行一种比较的习惯。老师们很喜欢询问，从某某到某某当中，分数最高的是多少。<br>这让很多学生很反感。</p></blockquote><blockquote></blockquote><blockquote><p>不管你喜不喜欢，现在需要你做的是，就是按照老师的要求，写一个程序，模拟老师的询问。当然，老师有时候需要更新某位同学的成绩。</p></blockquote><h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><blockquote><p>本题目包含多组测试，请处理到文件结束。<br>在每个测试的第一行，有两个正整数 N 和 M ( 0</p></blockquote><h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><blockquote><p>对于每一次询问操作，在一行里面输出最高成绩。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><blockquote><p>裸的模版题，线段树求解区间最值。</p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="hljs">#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;using namespace std;const int N = 200009;const int MAX = N*3;int Sum[MAX];void build(int l, int r, int k)&#123;    if(l == r)    &#123;        scanf(&quot;%d&quot;, &amp;Sum[k]);        return;    &#125;    int mid = (l+r)&gt;&gt;1;    build(l, mid, k&lt;&lt;1);    build(mid+1, r, k&lt;&lt;1 | 1);    Sum[k] = max(Sum[k&lt;&lt;1], Sum[k&lt;&lt;1 | 1]);&#125;void update(int l, int r, int pos, int d, int k)&#123;    if(l == r)    &#123;        Sum[k] = d;        return;    &#125;    int mid = (l+r)&gt;&gt;1;    if(pos&lt;=mid)        update(l, mid, pos, d, k&lt;&lt;1);    else        update(mid+1, r, pos, d, k&lt;&lt;1 | 1);    Sum[k] = max(Sum[k&lt;&lt;1], Sum[k&lt;&lt;1 | 1]);&#125;int find(int l, int r, int tol, int tor, int k)&#123;    if(tol &lt;= l &amp;&amp; tor &gt;= r)        return Sum[k];    int mid = (l+r)&gt;&gt;1;    int ans = 0;    if(tol &lt;= mid)        ans = max(ans, find(l, mid, tol, tor, k&lt;&lt;1));    if(tor &gt; mid)        ans = max(ans, find(mid+1, r, tol, tor, k&lt;&lt;1 | 1));    return ans;&#125;int main()&#123;    ios_base::sync_with_stdio(false);    int n, m;    while(~scanf(&quot;%d%d&quot;, &amp;n, &amp;m))    &#123;        build(1, n, 1);        char str[10];        int i, j;        while(m--)        &#123;            scanf(&quot;%s%d%d&quot;, str, &amp;i, &amp;j);            if(str[0] == &#39;U&#39;)                update(1, n, i, j, 1);            else                printf(&quot;%d\n&quot; ,find(1, n, i, j, 1));        &#125;    &#125;    return 0;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>线段树&amp;amp;树状数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU 1166 敌兵布阵(区间求和(线段树|树状数组))</title>
    <link href="/posts/38389.html"/>
    <url>/posts/38389.html</url>
    
    <content type="html"><![CDATA[<p>** 题目链接 ** ： <a href="http://acm.hust.edu.cn/vjudge/contest/view.action?cid=66989#problem/A"> [kuangbin带你飞]专题七 线段树 A - 敌兵布阵 </a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>最近看到有些大牛代码里有句<br>** ios_base::sync_with_stdio(false); **<br>不免好奇，百度了下，才知道是可以加快io操作时间。<br>cin，cout速度慢，是因为先把要输出的东西存入缓冲区，再输出，导致效率降低，而这段ios_base::sync_with_stdio(false)可以来<br>打消iostream的输入输出缓存，可以节省许多时间，使效率与scanf与printf相差无几。<br>那么，以后就可以抛去超时的顾虑，优雅的用cin，cout啦！<br>另外，本人用这道题做了测试，将结果分享给大家。<br>超时的是纯cin，cout<br>468s的是cin，cout加上ios_base::sync_with_stdio(false);<br>358s的是纯scanf，printf。<br><img src="http://img.blog.csdn.net/20160223144341400" alt="IO测试"></p></blockquote><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>Time Limit:1000MS Memory Limit:32768KB 64bit IO</p><h4 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h4><blockquote><p>C国的死对头A国这段时间正在进行军事演习，所以C国间谍头子Derek和他手下Tidy又开始忙乎了。A国在海岸线沿直线布置了N个工兵营地,Derek和Ti<br>dy的任务就是要监视这些工兵营地的活动情况。由于采取了某种先进的监测手段，所以每个工兵营地的人数C国都掌握的一清二楚,每个工兵营地的人数都有可能发生变动，可<br>能增加或减少若干人手,但这些都逃不过C国的监视。<br>中央情报局要研究敌人究竟演习什么战术,所以Tidy要随时向Derek汇报某一段连续的工兵营地一共有多少人,例如Derek问:“Tidy,马上汇报第3个营地到<br>第10个营地共有多少人!”Tidy就要马上开始计算这一段的总人数并汇报。但敌兵营地的人数经常变动，而Derek每次询问的段都不一样，所以Tidy不得不每次都<br>一个一个营地的去数，很快就精疲力尽了，Derek对Tidy的计算速度越来越不满:”你个死肥仔，算得这么慢，我炒你鱿鱼!”Tidy想：“你自己来算算看，这可真<br>是一项累人的工作!我恨不得你炒我鱿鱼呢!”无奈之下，Tidy只好打电话向计算机专家Windbreaker求救,Windbreaker说：“死肥仔，叫你平时做<br>多点acm题和看多点算法书，现在尝到苦果了吧!”Tidy说：”我知错了。。。”但Windbreaker已经挂掉电话了。Tidy很苦恼，这么算他真的会崩溃的，<br>聪明的读者，你能写个程序帮他完成这项工作吗？不过如果你的程序效率不够高的话，Tidy还是会受到Derek的责骂的.</p></blockquote><h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><blockquote><p>第一行一个整数T，表示有T组数据。<br>每组数据第一行一个正整数N（N&lt;=50000）,表示敌人有N个工兵营地，接下来有N个正整数,第i个正整数ai代表第i个工兵营地里开始时有ai个人（1&lt;=ai<br>&lt;=50）。<br>接下来每行有一条命令，命令有4种形式：<br>(1) Add i j,i和j为正整数,表示第i个营地增加j个人（j不超过30）<br>(2)Sub i j ,i和j为正整数,表示第i个营地减少j个人（j不超过30）;<br>(3)Query i j ,i和j为正整数,i&lt;=j，表示询问第i到第j个营地的总人数;<br>(4)End 表示结束，这条命令在每组数据最后出现;<br>每组数据最多有40000条命令</p></blockquote><h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><blockquote><p>对第i组数据,首先输出“Case i:”和回车,<br>对于每个Query询问，输出一个整数并回车,表示询问的段中的总人数,这个数保持在int以内。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><blockquote><p>赤裸裸的一维区间求和，可以用线段树或者树状数组，我用的是线段树。</p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="hljs">#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;using namespace std;const int N = 50009;const int MAX = N&lt;&lt;2;int Sum[MAX];void build(int l, int r, int k)&#123;    if(l == r)    &#123;        cin&gt;&gt;Sum[k];        return;    &#125;    int mid = (l+r)&gt;&gt;1;    build(l, mid, k&lt;&lt;1);    build(mid+1, r, k&lt;&lt;1 | 1);    Sum[k] = Sum[k&lt;&lt;1] + Sum[k&lt;&lt;1 | 1];&#125;void update(int l, int r, int pos, int d, int k)&#123;    if(l == r)    &#123;        Sum[k] += d;        return;    &#125;    int mid = (l+r)&gt;&gt;1;    if(pos&lt;=mid)        update(l, mid, pos, d, k&lt;&lt;1);    else        update(mid+1, r, pos, d, k&lt;&lt;1 | 1);    Sum[k] = Sum[k&lt;&lt;1] + Sum[k&lt;&lt;1 | 1];&#125;int find(int l, int r, int tol, int tor, int k)&#123;    if(tol &lt;= l &amp;&amp; tor &gt;= r)        return Sum[k];    int mid = (l+r)&gt;&gt;1;    int ans = 0;    if(tol &lt;= mid)        ans += find(l, mid, tol, tor, k&lt;&lt;1);    if(tor &gt; mid)        ans += find(mid+1, r, tol, tor, k&lt;&lt;1 | 1);    return ans;&#125;int main()&#123;    ios_base::sync_with_stdio(false);    int T;    cin&gt;&gt;T;    for(int t=1; t&lt;=T; t++)    &#123;        cout&lt;&lt;&quot;Case &quot;&lt;&lt;t&lt;&lt;&quot;:&quot;&lt;&lt;endl;        int n;        cin&gt;&gt;n;        build(1, n, 1);        char str[10];        int i, j;        while(cin&gt;&gt;str)        &#123;            if(str[0] == &#39;E&#39;)                break;            cin&gt;&gt;i&gt;&gt;j;            if(str[0] == &#39;A&#39;)                update(1, n, i, j, 1);            else if(str[0] == &#39;S&#39;)                update(1, n, i, -j, 1);            else if(str[0] == &#39;Q&#39;)                cout&lt;&lt;find(1, n, i, j, 1)&lt;&lt;endl;        &#125;    &#125;    return 0;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>线段树&amp;amp;树状数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>FZU 1686 神龙的难题(重复覆盖问题&amp;舞蹈链)</title>
    <link href="/posts/64492.html"/>
    <url>/posts/64492.html</url>
    
    <content type="html"><![CDATA[<p>** 题目链接 ** ： <a href="http://acm.hust.edu.cn/vjudge/contest/view.action?cid=65998#problem/D"> [kuangbin带你飞]专题三 Dancing Links D - 神龙的难题 </a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><h4 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h4><blockquote><p>这是个剑与魔法的世界.英雄和魔物同在,动荡和安定并存.但总的来说,库尔特王国是个安宁的国家,人民安居乐业,魔物也比较少.但是.总有一些魔物不时会进入城市<br>附近,干扰人民的生活.就要有一些人出来守护居民们不被魔物侵害.魔法使艾米莉就是这样的一个人.她骑着她的坐骑,神龙米格拉一起消灭干扰人类生存的魔物,维护王国的<br>安定.艾米莉希望能够在损伤最小的前提下完成任务.每次战斗前,她都用时间停止魔法停住时间,然后米格拉他就可以发出火球烧死敌人.米格拉想知道,他如何以最快的速度<br>消灭敌人,减轻艾米莉的负担.</p></blockquote><h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><blockquote><p>数据有多组,你要处理到EOF为止.每组数据第一行有两个数,n,m,(1&lt;=n,m&lt;=15)表示这次任务的地区范围.<br>然后接下来有n行,每行m个整数,如为1表示该点有怪物,为0表示该点无怪物.然后接下一行有两个整数,n1,m1<br>(n1&lt;=n,m1&lt;=m)分别表示米格拉一次能攻击的行,列数(行列不能互换),假设米格拉一单位时间能发出一个火球,所有怪物都可一击必杀.</p></blockquote><h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><blockquote><p>输出一行,一个整数,表示米格拉消灭所有魔物的最短时间.</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><blockquote><p>精确覆盖是每次选取一行后，就要对这行的所有列诛九族。而本题是重复覆盖，所以删除时，只删除相关的列即可，不诛连。<br>本题需要进行剪枝，剪枝函数f()代码中已说明。<br>ps：a的第一道重复覆盖问题，因为数据范围被T了那么多次，欲哭无泪啊，把代码扫了一遍又一遍，就是想不到竟然是数据范围的原因。细心是王道啊。。。</p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="hljs">#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;using namespace std;const int N = 16*16;const int MAX = N*N;int G[N][N];//储存地图int P[MAX];//储存点编号int U[MAX], D[MAX], L[MAX], R[MAX];//数组模拟链表指向(上下左右)int C[MAX], M[MAX];//节点所在列与行int S[N];//储存每列的元素数量int H[N];//行头指针int ans;void init(int n, int m)&#123;    for(int i=0; i&lt;=m; i++)    &#123;        L[i+1] = i;        R[i] = i+1;        U[i] = D[i] = i;        S[i] = 0;    &#125;    for(int i=1; i&lt;=n; i++)        H[i] = -1;    L[0] = m;    R[m] = 0;&#125;void link(int row, int col, int id)//将节点加入链表&#123;    C[id] = col; M[id] = row;//记录行列    U[id] = U[col]; D[U[col]] = id;//上下连接    D[id] = col; U[col] = id;    if(H[row] == -1)//左右连接(使用表头方便头插)        H[row] = L[id] = R[id] = id;    else    &#123;        L[id] = L[H[row]]; R[L[H[row]]] = id;        L[H[row]] = id; R[id] = H[row];    &#125;    S[col]++;&#125;void remove(int col)//因为是重复覆盖，所以一次循环，只删除该列，不删除相关的&#123;    for(int i=D[col]; i!=col; i=D[i])    &#123;        L[R[i]] = L[i];        R[L[i]] = R[i];    &#125;&#125;void resume(int col)&#123;    for(int i=U[col]; i!=col; i=U[i])    &#123;        L[R[i]] = i;        R[L[i]] = i;    &#125;&#125;bool v[MAX];int f()//剪枝函数&#123;    int num = 0;    for(int i=R[0]; i!=0; i=R[i])//0代表未消灭        v[i] = 0;    for(int i=R[0]; i!=0; i=R[i])    &#123;        if(!v[i])        &#123;            v[i] = 1;            num++;            //(假设攻击范围最大化)能够杀掉它的所有攻击的全部范围进行消灭，类似以它为圆心画圆一样            for(int j=U[i]; j!=i; j=U[j])                for(int k=R[j]; k!=j; k=R[k])                    v[C[k]] = 1;        &#125;    &#125;    return num;&#125;void dance(int k)&#123;    if(k+f() &gt;= ans)        return;    if(!R[0])    &#123;        ans = min(ans, k);        return;    &#125;    int col = R[0];    for(int i=R[0]; i!=0; i=R[i])        if(S[i] &lt; S[col])            col = i;    for(int i=D[col]; i!=col; i=D[i])    &#123;        remove(i);        for(int j=R[i]; j!=i; j=R[j])            remove(j);        dance(k+1);        for(int j=L[i]; j!=i; j=L[j])            resume(j);        resume(i);    &#125;&#125;int main()&#123;    int n, m;    while(~scanf(&quot;%d%d&quot;, &amp;n, &amp;m))    &#123;        int num = 0;        for(int i=1; i&lt;=n; i++)            for(int j=1; j&lt;=m; j++)            &#123;                scanf(&quot;%d&quot;, &amp;G[i][j]);                if(G[i][j])                    P[j+(i-1)*m] = ++num;            &#125;        int r, c;        scanf(&quot;%d%d&quot;, &amp;r, &amp;c);        init((n-r+1)*(m-c+1), num);        int id = num+1;        for(int i=1; i&lt;=n-r+1; i++)        &#123;            for(int j=1; j&lt;=m-c+1; j++)                for(int x=i; x&lt;=i+r-1; x++)                    for(int y=j; y&lt;=j+c-1; y++)                    &#123;                        if(G[x][y])                            link(j+(i-1)*(m-c+1), P[y+(x-1)*m], id++);                    &#125;        &#125;        ans = 0x3f3f3f3f;        dance(0);        printf(&quot;%d\n&quot;, ans);    &#125;    return 0;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>舞蹈链－Dance Link</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ZOJ 3209 Treasure Map(精确覆盖问题&amp;舞蹈链)</title>
    <link href="/posts/23306.html"/>
    <url>/posts/23306.html</url>
    
    <content type="html"><![CDATA[<p>** 题目链接 ** ： <a href="http://acm.hust.edu.cn/vjudge/contest/view.action?cid=65998#problem/B"> [kuangbin带你飞]专题三 Dancing Links B - Treasure Map </a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><blockquote><p>给一矩形和k个小矩形，问选取最小数量为多少的小矩形可以对大矩形进行精确覆盖。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><blockquote><p>仍然是个模版题，把二维的n<em>m的大矩形看作是一维的n</em>m的一条线。k个小矩形同理，那么就转化成01矩阵精确覆盖的问题了。</p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="hljs">#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;using namespace std;const int N = 1009;const int MAX = 1000009;int U[MAX], D[MAX], L[MAX], R[MAX];//数组模拟链表指向(上下左右)int C[MAX], M[MAX];//节点所在列与行int S[N];//储存每列的元素数量int H[N];//行头指针int ans;void init(int n, int m)&#123;    for(int i=0; i&lt;=m; i++)    &#123;        L[i+1] = i;        R[i] = i+1;        U[i] = D[i] = i;        S[i] = 0;    &#125;    for(int i=1; i&lt;=n; i++)        H[i] = -1;    L[0] = m;    R[m] = 0;&#125;void link(int row, int col, int id)//将节点加入链表&#123;    C[id] = col; M[id] = row;//记录行列    U[id] = U[col]; D[U[col]] = id;//上下连接    D[id] = col; U[col] = id;    if(H[row] == -1)//左右连接(使用表头方便头插)        H[row] = L[id] = R[id] = id;    else    &#123;        L[id] = L[H[row]]; R[L[H[row]]] = id;        L[H[row]] = id; R[id] = H[row];    &#125;    S[col]++;&#125;void remove(int col)//删除列&#123;    R[L[col]] = R[col];    L[R[col]] = L[col];    for(int i=D[col]; i!=col; i=D[i])    &#123;        for(int j=R[i]; j!=i; j=R[j])        &#123;            U[D[j]] = U[j];            D[U[j]] = D[j];            S[C[j]]--;        &#125;    &#125;&#125;void resume(int col)//恢复列(先删的后恢复，后删的先恢复，所以跟remove反向操作)&#123;    R[L[col]] = col;    L[R[col]] = col;    for(int i=U[col]; i!=col; i=U[i])    &#123;        for(int j=L[i]; j!=i; j=L[j])        &#123;            U[D[j]] = j;            D[U[j]] = j;            S[C[j]]++;        &#125;    &#125;&#125;void dance(int k)&#123;    if(ans!=-1 &amp;&amp; k&gt;=ans)        return;    if(!R[0])    &#123;        ans = k;        return;    &#125;    int col = R[0];    for(int i=R[0]; i!=0; i=R[i])        if(S[i] &lt; S[col])            col = i;    remove(col);    for(int i=D[col]; i!=col; i=D[i])    &#123;        for(int j=R[i]; j!=i; j=R[j])            remove(C[j]);        dance(k+1);        for(int j=L[i]; j!=i; j=L[j])            resume(C[j]);    &#125;    resume(col);&#125;int main()&#123;    int n, m, k, T;    scanf(&quot;%d&quot;, &amp;T);    while(T--)    &#123;        scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;k);        init(k, n*m);        int id = n*m+1;        for(int i=1; i&lt;=k; i++)        &#123;            int x1, x2, y1, y2;            scanf(&quot;%d%d%d%d&quot;, &amp;x1, &amp;y1, &amp;x2, &amp;y2);            for(int x=x1+1; x&lt;=x2; x++)                for(int y=y1+1; y&lt;=y2; y++)                    link(i, y+(x-1)*m, id++);        &#125;        ans = -1;        dance(0);        printf(&quot;%d\n&quot;, ans);    &#125;    return 0;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>舞蹈链－Dance Link</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HUST 1017 Exact cover(舞蹈链&amp;不能为了ac而ac)</title>
    <link href="/posts/38813.html"/>
    <url>/posts/38813.html</url>
    
    <content type="html"><![CDATA[<p>** 题目链接 ** ： <a href="http://acm.hust.edu.cn/vjudge/contest/view.action?cid=65998#problem/A"> [kuangbin带你飞]专题三 Dancing Links A - Exact cover </a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><blockquote><p>给定一01矩阵，问是否能够精确覆盖(就是选取任意行，这些行的1所在的列互不冲突且完整覆盖所有列)，若有输出行号(要按递增顺序输出)，否则输出NO。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>ps：两个礼拜前大略看了下舞蹈链(虽然英文名听起来更高端，但还是更喜欢它的中文名字)，很精妙但也让人一看就惰性必生不愿再看，今天耐心再仔细理解了下，总算是a<br>的刷题生涯第一道精确覆盖题(人有时候还是要逼自己一把，战胜惰性才能进步)。</p><blockquote><p>没什么思路，标准的舞蹈链模版题，理解了舞蹈链就能a了。<br>学习舞蹈链，推荐此博文，相当清晰: <a href="http://www.cnblogs.com/grenet/p/3145800.html"> 跳跃的舞者，舞蹈链（Dancing Links）算法——求解精确覆盖问题</a><br>代码上有详细的注释，但有一处有必要分享一下。</p></blockquote><pre><code class="hljs">for(int i=R[0]; i!=0; i=R[i])        if(S[i] &lt; S[col])            col = i;</code></pre><blockquote><p>上面这段代码作用是每次选取元素最少的列进行操作，可以有效减少递归层数，从而加快程序效率。<br>因为本人好奇，取消了它试了一下，发现wrong(按理也应该是timelimit啊)，一试再试，发现是得出的行号没有排序的原因，加上对结果的排序就好了。<br>但本人又好奇了，一再思索，终究还是想不出来上述代码为什么能够使结果递增序，于是做了一组数据：<br>5 5<br>2 4 5<br>3 1 3 4<br>1 5<br>1 2<br>2 1 5<br>测试后发现 ** 无论加不加上述代码结果都不是递增序的 ** ，也就是说 ** 上述代码只是加速的功能 ** 而已。<br>也就是说，测试数据太水，所有 ** 没加排序的代码都应该被wrong **<br>。(很好奇那么多题解为什么没有一个带排序的，希望自己不要成为为了ac而ac的人)。</p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="hljs">#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;using namespace std;const int N = 1009;const int MAX = 1000009;int U[MAX], D[MAX], L[MAX], R[MAX];//数组模拟链表指向(上下左右)int C[MAX], M[MAX];//节点所在列与行int S[N];//储存每列的元素数量int H[N];//行头指针int ANS[N];//结果保存数组void link(int row, int col, int id)//将节点加入链表&#123;    C[id] = col; M[id] = row;//记录行列    U[id] = U[col]; D[U[col]] = id;//上下连接    D[id] = col; U[col] = id;    if(H[row] == -1)//左右连接(使用表头方便头插)        H[row] = L[id] = R[id] = id;    else    &#123;        L[id] = L[H[row]]; R[L[H[row]]] = id;        L[H[row]] = id; R[id] = H[row];    &#125;    S[col]++;&#125;void remove(int col)//删除列&#123;    R[L[col]] = R[col];    L[R[col]] = L[col];    for(int i=D[col]; i!=col; i=D[i])    &#123;        for(int j=R[i]; j!=i; j=R[j])        &#123;            U[D[j]] = U[j];            D[U[j]] = D[j];            S[C[j]]--;        &#125;    &#125;&#125;void resume(int col)//恢复列(先删的后恢复，后删的先恢复，所以跟remove反向操作)&#123;    R[L[col]] = col;    L[R[col]] = col;    for(int i=U[col]; i!=col; i=U[i])    &#123;        for(int j=L[i]; j!=i; j=L[j])        &#123;            U[D[j]] = j;            D[U[j]] = j;            S[C[j]]++;        &#125;    &#125;&#125;bool dance(int k)&#123;    if(!R[0])//列辅助数组为空表示已得解    &#123;        printf(&quot;%d&quot;, k);        sort(ANS, ANS+k);//对结果排序。        for(int i=0; i&lt;k; i++)            printf(&quot; %d&quot;, ANS[i]);        printf(&quot;\n&quot;);        return true;    &#125;    int col = R[0];    for(int i=R[0]; i!=0; i=R[i])//加速，上文已说明        if(S[i] &lt; S[col])            col = i;    remove(col);//删除列    for(int i=D[col]; i!=col; i=D[i])//尝试该列每行一次做为解    &#123;        ANS[k] = M[i];// 记录行号        for(int j=R[i]; j!=i; j=R[j])//删除该行元素说相关的列            remove(C[j]);        if(dance(k+1))            return true;        for(int j=L[i]; j!=i; j=L[j])//恢复            resume(C[j]);    &#125;    resume(col);//恢复列    return false;&#125;int main()&#123;    int n, m;    while(~scanf(&quot;%d%d&quot;, &amp;n, &amp;m))    &#123;        for(int i=0; i&lt;=m; i++)//初始化        &#123;            L[i+1] = i;            R[i] = i+1;            U[i] = D[i] = i;            S[i] = 0;        &#125;        L[0] = m;        R[m] = 0;        int id = m+1;        for(int i=1; i&lt;=n; i++)        &#123;            int num;            scanf(&quot;%d&quot;, &amp;num);            H[i] = -1;            while(num--)            &#123;                int col;                scanf(&quot;%d&quot;, &amp;col);                link(i, col, id++);            &#125;        &#125;        if(!dance(0))            printf(&quot;NO\n&quot;);    &#125;    return 0;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>舞蹈链－Dance Link</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU 4513 吉哥系列故事――完美队形II(Manacher)</title>
    <link href="/posts/12463.html"/>
    <url>/posts/12463.html</url>
    
    <content type="html"><![CDATA[<p>** 题目链接 ** ： <a href="http://acm.hust.edu.cn/vjudge/contest/view.action?cid=70325#problem/V"> [kuangbin带你飞]专题十六 KMP &amp; 扩展KMP &amp; Manacher V - 吉哥系列故事――完美队形II </a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><blockquote><p>吉哥又想出了一个新的完美队形游戏！<br>假设有n个人按顺序站在他的面前，他们的身高分别是h[1], h[2] …<br>h[n]，吉哥希望从中挑出一些人，让这些人形成一个新的队形，新的队形若满足以下三点要求，则就是新的完美队形：</p></blockquote><blockquote></blockquote><blockquote><p>1、挑出的人保持原队形的相对顺序不变，且必须都是在原队形中连续的；<br>2、左右对称，假设有m个人形成新的队形，则第1个人和第m个人身高相同，第2个人和第m-1个人身高相同，依此类推，当然如果m是奇数，中间那个人可以任意；<br>3、从左到中间那个人，身高需保证不下降，如果用H表示新队形的高度，则H[1] &lt;= H[2] &lt;= H[3] …. &lt;= H[mid]。</p></blockquote><blockquote></blockquote><blockquote><p>现在吉哥想知道：最多能选出多少人组成新的完美队形呢？</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><blockquote><p>跟 <a href="http://blog.csdn.net/to_be_better/article/details/50697171"> HDU 3068 最长回文(Manacher)</a><br>差不多，也是求回文串长度，区别就是多了一个非递减的约束条件，加上判断即可。</p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="hljs">#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;using namespace std;const int N = 100009;int s[N*2], p[N*2];int manacher(int len)&#123;    int mx = 0, id = 0, ans = 1;    p[0] = 0;    for(int i=1; i&lt;len; i++)    &#123;        p[i] = 1;        if(mx &gt; i)            p[i] = min(mx-i, p[2*id-i]);        while(s[i-p[i]] == s[i+p[i]] &amp;&amp; s[i-p[i]] &lt;= s[i-p[i]+2])            p[i]++;        if(i+p[i] &gt; mx)            mx = i+p[i], id = i;        if(ans &lt; p[i]-1)            ans = p[i]-1;    &#125;    return ans;&#125;int main()&#123;    int T;    scanf(&quot;%d&quot;, &amp;T);    while(T--)    &#123;        int n;        scanf(&quot;%d&quot;, &amp;n);        s[0] = -1;        for(int i=1; i&lt;=n; i++)        &#123;            s[i*2-1] = 0;            scanf(&quot;%d&quot;, &amp;s[i*2]);        &#125;        s[2*n+1] = 0;        printf(&quot;%d\n&quot;, manacher(2*n+1));    &#125;    return 0;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>KMP&amp;amp;Manacher</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU 3068 最长回文(Manacher)</title>
    <link href="/posts/16378.html"/>
    <url>/posts/16378.html</url>
    
    <content type="html"><![CDATA[<p>** 题目链接 ** ： <a href="http://acm.hust.edu.cn/vjudge/contest/view.action?cid=70325#problem/X"> [kuangbin带你飞]专题十六 KMP &amp; 扩展KMP &amp; Manacher </a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><blockquote><p>给出一个只由小写英文字符a,b,c…y,z组成的字符串S,求S中最长回文串的长度.<br>回文就是正反读都是一样的字符串,如aba, abba等</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><blockquote><p>用特殊字符插入到s串中每两个字符中间，实现每个回文串都是奇数，再用manacher算法进行求解。</p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="hljs">#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;using namespace std;const int N = 110009;char s[N], t[N&lt;&lt;1];int p[N&lt;&lt;1];int manacher(int len)&#123;    int id = 1, mx=0;    p[0] = 1;    for(int i=1; i&lt;len; i++)    &#123;        if(mx &gt; i)            p[i] = min(mx-i, p[2*id-i]);        else            p[i] = 1;        while(t[i+p[i]] == t[i-p[i]])            p[i]++;        if(mx &lt; p[i]+i)        &#123;            mx = p[i]+i;            id = i;        &#125;    &#125;    int ans = p[1];    for(int i=1; i&lt;len; i++)        if(ans &lt; p[i])            ans = p[i];    return ans-1;&#125;int main()&#123;    while(~scanf(&quot;%s&quot;, s))    &#123;        t[0] = &#39;@&#39;;        t[1] = &#39;#&#39;;        int len = strlen(s);        for(int i=0; i&lt;len; i++)        &#123;            t[i*2+2] = s[i];            t[i*2+3] = &#39;#&#39;;        &#125;        printf(&quot;%d\n&quot;, manacher(len*2+2));    &#125;    return 0;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>KMP&amp;amp;Manacher</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU 3652 B-number(数位dp&amp;记忆化搜索)</title>
    <link href="/posts/10413.html"/>
    <url>/posts/10413.html</url>
    
    <content type="html"><![CDATA[<p>** 题目链接 ** ： <a href="http://acm.hust.edu.cn/vjudge/contest/view.action?cid=70324#problem/G"> [kuangbin带你飞]专题十五 数位DP G - B-number </a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><blockquote><p>求1～n的范围里含有13且能被13整除的数字的个数。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><blockquote><p>首先，了解这样一个式子：a％m == ((b%m)*c+d)%m;<br>式子的正确是显然的，就不证明了。<br>那么判断数是否可以被13整除就可以分解为一位一位进行处理。<br>当然，我们也只需要储存取余后的值。<br>** dfs(len, num, mod, flag) **<br>** mod记录数字对13取余后的值 **<br>** len表示当前位数 **<br>** num＝＝0 不含13且上一位不为1 **<br>** pre＝＝1 不含13且上一位为1 **<br>** pre＝＝2 含13 **<br>** flag表示是否可以任意取值(判断范围)。 **<br>如此，记忆化搜索即可得解。</p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="hljs">#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;using namespace std;#define LL long long#define MOD 13LL dp[20][3][13];int dis[20];LL dfs(int len, int type, int mod, bool flag)&#123;    if(len &lt; 0)        return type == 2 &amp;&amp; mod == 0;    if(!flag &amp;&amp; dp[len][type][mod]!=-1)        return dp[len][type][mod];    int end = flag?dis[len]:9;    int ans = 0;    for(int i=0; i&lt;=end; i++)    &#123;        if(type == 2 || (type == 1 &amp;&amp; i == 3))            ans += dfs(len-1, 2, (mod*10+i)%MOD, flag&amp;&amp;i==end);        else            ans += dfs(len-1, i==1?1:0, (mod*10+i)%MOD, flag&amp;&amp;i==end);    &#125;    if(!flag)        dp[len][type][mod] = ans;    return ans;&#125;LL solve(LL n)&#123;    int len = 0;    while(n)    &#123;        dis[len++] = n%10;        n /= 10;    &#125;    return dfs(len-1, 0, 0, 1);&#125;int main()&#123;    int n;    memset(dp, -1, sizeof(dp));    while(cin&gt;&gt;n)        cout&lt;&lt;solve(n)&lt;&lt;endl;    return 0;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ 3252 Round Numbers(数位dp&amp;记忆化搜索)</title>
    <link href="/posts/28652.html"/>
    <url>/posts/28652.html</url>
    
    <content type="html"><![CDATA[<p>** 题目链接 ** ： <a href="http://acm.hust.edu.cn/vjudge/contest/view.action?cid=70324#problem/E"> [kuangbin带你飞]专题十五 数位DP E - Round Numbers </a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><blockquote><p>给定区间，求转化为二进制后其中0比1多或相等的数字的个数。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><blockquote><p>将数字转化为二进制进行数位dp，因为一个二进制数的最高位必须为1，所以设置变量first记录前面位是否有1，若有1，则可任意放，否则，只可放1。<br>同时，上面的判断决定了搜索时len的大小与二进制本身的长度不一定相等，所以需两个变量对1和0的个数进行记录。<br>用dp[a][b][c]保存长度a，b个0，c个1的数字个数，记忆化搜索。</p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="hljs">#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;using namespace std;#define LL long longint dp[33][33][33];int dis[33];int dfs(int len, int cnt0, int cnt1, bool first, bool flag)&#123;    if(len &lt; 0)        return (first || cnt0&gt;cnt1);    if(!flag &amp;&amp; !first &amp;&amp; dp[len][cnt0][cnt1]!=-1)        return dp[len][cnt0][cnt1];    int end = flag?dis[len]:1;    int ans = 0;    for(int i=0; i&lt;=end; i++)    &#123;        if(first)        &#123;            if(i)                ans += dfs(len-1, 0, 0, 0, flag&amp;&amp;i==end);            else                ans += dfs(len-1, 0, 0, 1, flag&amp;&amp;i==end);        &#125;        else        &#123;            if(i)                ans += dfs(len-1, cnt0, cnt1+1, 0, flag&amp;&amp;i==end);            else                ans += dfs(len-1, cnt0+1, cnt1, 0, flag&amp;&amp;i==end);        &#125;    &#125;    if(!flag &amp;&amp; !first)        dp[len][cnt0][cnt1] = ans;    return ans;&#125;int solve(int n)&#123;    int len = 0;    while(n)    &#123;        dis[len++] = n&amp;1;        n &gt;&gt;= 1;    &#125;    return dfs(len-1, 0, 0, 1, 1);&#125;int main()&#123;    int l, r;    memset(dp, -1, sizeof(dp));    while(cin&gt;&gt;l&gt;&gt;r)        cout&lt;&lt;solve(r)-solve(l-1)&lt;&lt;endl;    return 0;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU 3555 Bomb(数位dp&amp;记忆化搜索)</title>
    <link href="/posts/8174.html"/>
    <url>/posts/8174.html</url>
    
    <content type="html"><![CDATA[<p>** 题目链接 ** ： <a href="http://acm.hust.edu.cn/vjudge/contest/view.action?cid=70324#problem/D"> [kuangbin带你飞]专题十五 数位DP D - Bomb </a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><blockquote><p>求1～n的范围里含有49的数字的个数。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><blockquote><p>记忆化搜索<br>dfs(len, pre, flag)<br>len表示当前位数<br>pre＝＝0 不含49且上一位不为4<br>pre＝＝1 不含49且上一位为4<br>pre＝＝2 含49<br>flag表示是否可以任意取值(判断范围)。<br>即可。</p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="hljs">#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;using namespace std;#define LL long longLL dp[20][3];int dis[20];LL dfs(int len, int pre, bool flag)&#123;    if(len &lt; 0)        return pre==2;    if(!flag &amp;&amp; dp[len][pre]!=-1)        return dp[len][pre];    int end = flag?dis[len]:9;    LL ans = 0;    for(int i=0; i&lt;=end; i++)    &#123;        if(pre==2 || pre==1 &amp;&amp; i==9)            ans += dfs(len-1, 2, flag&amp;&amp;i==end);        else if(i==4)            ans += dfs(len-1, 1, flag&amp;&amp;i==end);        else            ans += dfs(len-1, 0, flag&amp;&amp;i==end);    &#125;    if(!flag)        dp[len][pre] = ans;    return ans;&#125;LL solve(LL n)&#123;    int len = 0;    while(n)    &#123;        dis[len++] = n%10;        n /= 10;    &#125;    return dfs(len-1, 0, 1);&#125;int main()&#123;    int T;    cin&gt;&gt;T;    memset(dp, -1, sizeof(dp));    while(T--)    &#123;        LL n;        cin&gt;&gt;n;        cout&lt;&lt;solve(n)&lt;&lt;endl;    &#125;    return 0;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HUST 1010 The Minimum Length(最小循环节)</title>
    <link href="/posts/16814.html"/>
    <url>/posts/16814.html</url>
    
    <content type="html"><![CDATA[<p>** 题目链接 ** ： <a href="http://acm.hust.edu.cn/vjudge/contest/view.action?cid=70325#problem/F"> [kuangbin带你飞]专题十六 KMP &amp; 扩展KMP &amp; Manacher F - The Minimum Length </a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><blockquote><p>有一个字符串A，假设是”abcdefg”，由A可以重复组成AAA，即”abcdefgabcdefgabcdefg”，从中截取一部分(至少包含一个以上完整<br>A)为B。<br>现给出字符串B，求A最短的长度。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><blockquote><p>因为是重复组成的，所以abcd＝＝bcda＝＝cdab＝＝dabc，即<br>直接对字符串B进行最短循环节求解，循环节的长度即为A的最短长度。<br>ps：此题有一大易wrong点，我整整wrong了10多次，改到哭，甚至坚信是系统出问题。<br>今再看，尝试了用gets输入，竟然成功。<br>改回用scanf，加上对str的清零操作，也成功。<br>基本可以确定是\0惹的祸，查了下发现<br>gets函数会读入截止字符\n， 同时将\n自动替换为\0.<br>scanf遇到截止字符时不会继续读取，截止字符将存储于输入缓冲中。<br>因为没有\0，所以无法获取正确的字符串长度，所以wrong。</p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="hljs">#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;using namespace std;char a[1000009];int p[1000009];void init(int m)&#123;    memset(p, 0, sizeof(p));    for(int i=1, k=0; i&lt;m; i++)    &#123;        while(k&gt;0 &amp;&amp; a[i]!=a[k]) k = p[k-1];        if(a[i] == a[k]) k++;        p[i] = k;    &#125;&#125;void solve(int n)&#123;    init(n);    printf(&quot;%d\n&quot;, n-p[n-1]);&#125;int main()&#123;    while(~scanf(&quot;%s&quot;, a))    &#123;        solve(strlen(a));        memset(a, 0, sizeof(a));    &#125;    return 0;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>KMP&amp;amp;Manacher</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU 2089 不要62(数位dp&amp;记忆化搜索)</title>
    <link href="/posts/190.html"/>
    <url>/posts/190.html</url>
    
    <content type="html"><![CDATA[<p>** 题目链接 ** ： <a href="http://acm.hust.edu.cn/vjudge/contest/view.action?cid=70324#problem/C"> [kuangbin带你飞]专题十五 数位DP C - 不要62 </a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><blockquote><p>杭州人称那些傻乎乎粘嗒嗒的人为62（音：laoer）。<br>杭州交通管理局经常会扩充一些的士车牌照，新近出来一个好消息，以后上牌照，不再含有不吉利的数字了，这样一来，就可以消除个别的士司机和乘客的心理障碍，更安全地服<br>务大众。<br>不吉利的数字为所有含有4或62的号码。例如：<br>62315 73418 88914<br>都属于不吉利号码。但是，61152虽然含有6和2，但不是62连号，所以不属于不吉利数字之列。<br>你的任务是，对于每次给出的一个牌照区间号，推断出交管局今次又要实际上给多少辆新的士车上牌照了。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><blockquote><p>dp[i][j]表示当前为第i位且上一位(是／不是)6的数的个数<br>知道上一位是否为六，对当前为进行if(i!=4 &amp;&amp; !(pre&amp;&amp;i==2))即可筛选。记忆化搜索即可。</p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="hljs">#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;using namespace std;int dp[10][2];int dis[10];int dfs(int len, bool pre, bool flag)&#123;    if(len &lt; 0)        return 1;    if(!flag &amp;&amp; dp[len][pre]!=-1)        return dp[len][pre];    int ans = 0;    int end = flag?dis[len]:9;    for(int i=0; i&lt;=end; i++)    &#123;        if(i!=4 &amp;&amp; !(pre&amp;&amp;i==2))            ans += dfs(len-1, i==6, flag&amp;&amp;i==end);    &#125;    if(!flag)        dp[len][pre] = ans;    return ans;&#125;int solve(int n)&#123;    int len = 0;    while(n)    &#123;        dis[len++] = n%10;        n /= 10;    &#125;    return dfs(len-1, 0, 1);&#125;int main()&#123;    int l, r;    memset(dp, -1, sizeof(dp));    while(~scanf(&quot;%d%d&quot;, &amp;l, &amp;r) &amp;&amp; l &amp;&amp; r)    &#123;        printf(&quot;%d\n&quot;, solve(r)-solve(l-1));    &#125;    return 0;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU 4352 XHXJ&#39;s LIS(数位dp&amp;状态压缩)</title>
    <link href="/posts/26360.html"/>
    <url>/posts/26360.html</url>
    
    <content type="html"><![CDATA[<p>** 题目链接 ** ： <a href="http://acm.hust.edu.cn/vjudge/contest/view.action?cid=70324#problem/B"> [kuangbin带你飞]专题十五 数位DP B - XHXJ’s LIS </a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><blockquote><p>给定区间，求出有多少个数满足最长上升子序列(将数看作字符串)的长度为k。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><blockquote><p>一个数的上升子序列最大长度为10，所以每一个上升子序列的状态都可以用10个二进制位来表示。<br>上升子序列的变化可以用LIS的方式来更新。<br>dp[len][num][k]<br>len为当前的位，num为当前上升子序列的状态，k表示子序列的长度。<br>next[s][num]为记录预处理的子序列的状态变化。<br>cnt [num]记录各个状态的最长上升子序列的长度。</p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="hljs">#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;using namespace std;#define LL long longLL dp[20][1&lt;&lt;10][11];int dis[20];int cnt[1&lt;&lt;10];int nxt[10][1&lt;&lt;10];int getnext(int num, int s)&#123;    for(int i=s; i&lt;10; i++)    &#123;        if(num &amp; (1&lt;&lt;i))            return (num^(1&lt;&lt;i)) | 1&lt;&lt;s;    &#125;    return num | 1&lt;&lt;s;&#125;LL dfs(int k, int len, int num, bool flag, bool zero)&#123;    if(len &lt; 0)        return cnt[num] == k;    if(!flag &amp;&amp; dp[len][num][k]!=-1)        return dp[len][num][k];    LL ans = 0;    int end = flag?dis[len]:9;    for(int i=0; i&lt;=end; i++)        ans += dfs(k, len-1, (zero&amp;&amp;i==0)?num:nxt[i][num], flag&amp;&amp;i==end, zero&amp;&amp;i==0);    if(!flag)        dp[len][num][k] = ans;    return ans;&#125;LL solve(LL n, int k)&#123;    int pos = 0;    while(n)    &#123;        dis[pos++] = n%10;        n /= 10;    &#125;    return dfs(k, pos-1, 0, 1, 1);&#125;void init()&#123;    memset(dp, -1, sizeof(dp));    for(int i=0; i&lt;1&lt;&lt;10; i++)    &#123;        cnt[i] = 0;        for(int j=0; j&lt;10; j++)        &#123;            if(i &amp; (1&lt;&lt;j))                cnt[i]++;            nxt[j][i] = getnext(i, j);        &#125;    &#125;&#125;int main()&#123;    int T;    scanf(&quot;%d&quot;, &amp;T);    init();    for(int i=1; i&lt;=T; i++)    &#123;        long long l, r, k;        scanf(&quot;%lld%lld%lld&quot;, &amp;l, &amp;r, &amp;k);        printf(&quot;Case #%d: %lld\n&quot;, i, solve(r, k)-solve(l-1, k));    &#125;    return 0;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CodeForces 55D Beautiful numbers(数位dp+离散化)</title>
    <link href="/posts/41985.html"/>
    <url>/posts/41985.html</url>
    
    <content type="html"><![CDATA[<p>** 题目链接 ** ： <a href="http://acm.hust.edu.cn/vjudge/contest/view.action?cid=70324#problem/A"> [kuangbin带你飞]专题十五 数位DP A - Beautiful numbers </a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>ps：第一道数位dp，题真好，虽然是参考大牛方法悟过才a，但仍收获不少。</p><blockquote><p>求一个区间内的Beautiful numbers有多少个。Beautiful numbers指：一个数能整除所有组成它的非0数字。<br>例如15可以被1和5整除，所以15是Beautiful numbers。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><blockquote><p>Beautiful numbers指：一个数能整除所有组成它的非0数字。<br>等同于 一个数能整除 所有组成它的非0数字的最小公倍数。<br>我们看到数据的范围是1 ≤ li ≤ ri ≤ 9 ·1018，根本无法记录。<br>所以，缩小范围成为第一要做的事。<br>先看一个小式子。</p></blockquote><pre><code class="hljs">    sum%(x*n)%x == sum%x;证明：设sum ＝ k*x+b    等号左边:        sum%(x*n)%x -&gt; (k*x+b)%(x*n)%x        将k转为ka*n + kb代入;        (ka*n*x+kb*x+b)%(x*n)%x -&gt; (kb*x+b)%x -&gt; b%x -&gt; b    等号右边:        b左右相等，证明成立</code></pre><blockquote><p>那么我们就可以用上式中的x<em>n对num进行取余，记录其取余后的值，显然，1～9的最小公倍数2520是最合理的x</em>n。<br>而在逐位统计时，可以直接由前面位取余后的值来得到包含新一位的新数字取余后的值。<br>例如 RX(R是已知前面位取余后的值)，那么Rx%2520 == (R*10+x)%2520。就不在此废话证了。<br>我们使用记忆化搜索。<br><strong>dfs(len, num, lcm, flag)<br>len表示迭代的长度，<br>num为截止当前位的数对2520取余后的值。<br>lcm为截止当前位的所有数的最小公倍数。<br>flag表示当前数是否可以任意取值(对取值上限进行判断)</strong><br>则可用dp[len][num][lcm]来对其进行记录。<br>但lcm按2520取值根本开不下，所以对lcm进行离散化，因为lcm一定可以整除2520，所以将1～2520可以整除2520的数进行标记即可，测试后发现只有<br>48个，满足当前情况。</p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="hljs">#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;using namespace std;#define LL long longconst int MOD = 2520;LL dp[20][50][2550];int dis[20];int Hash[2550];LL gcd(LL a, LL b)&#123;    return b?gcd(b,a%b):a;&#125;LL dfs(int len, int num, int lcm, bool flag)&#123;    if(-1==len) return num%lcm == 0;    if(!flag &amp;&amp; -1==dp[len][Hash[lcm]][num]) return dp[len][Hash[lcm]][num];    LL ans = 0;    int end = flag?dis[len]:9;    for(int i=0; i&lt;=end; i++)        ans += dfs(len-1, (num*10+i)%MOD, i?lcm*i/gcd(lcm,i):lcm, flag&amp;&amp;i==end);    if(!flag) dp[len][Hash[lcm]][num] = ans;    return ans;&#125;LL solve(LL n)&#123;    int pos = 0;    while(n)    &#123;        dis[pos++] = n%10;        n /= 10;    &#125;    return dfs(pos-1, 0, 1, 1);&#125;int main()&#123;    int T;    scanf(&quot;%d&quot;, &amp;T);    int cnt = 0;    for(int i=1; i&lt;=MOD; i++)        if(MOD%i == 0)            Hash[i] = cnt++;    memset(dp, -1, sizeof(dp));    while(T--)    &#123;        long long l, r;        scanf(&quot;%lld%lld&quot;, &amp;l, &amp;r);        printf(&quot;%lld\n&quot;, solve(r)-solve(l-1));    &#125;    return 0;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU 1358 Period</title>
    <link href="/posts/37541.html"/>
    <url>/posts/37541.html</url>
    
    <content type="html"><![CDATA[<p>** 题目链接 ** ： <a href="http://acm.hust.edu.cn/vjudge/contest/view.action?cid=70325#problem/E"> [kuangbin带你飞]专题十六 KMP &amp; 扩展KMP &amp; Manacher E - Period </a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><blockquote><p>给一字符串，求其所有完整循环的前缀与循环节的长度。<br>例：aaa<br>长度2前缀，循环节为a，个数为2<br>长度3前缀，循环节为a，个数为3</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><blockquote><p>kmp求出字符串前后缀重复数，遍历所有前缀子串进行下面操作：<br>字符串前后缀重复数next[L]，则循环节的长度为L-L%next[L]，如果L%循环节长度为0，则说明是完整循环，输出解。</p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="hljs">#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;using namespace std;char a[1000009];int p[1000009];void init(int m)&#123;    memset(p, 0, sizeof(p));    for(int i=1, k=0; i&lt;m; i++)    &#123;        while(k&gt;0 &amp;&amp; a[i]!=a[k]) k = p[k-1];        if(a[i] == a[k]) k++;            p[i] = k;    &#125;&#125;void solve(int n)&#123;    init(n);    for(int i=1; i&lt;n; i++)    &#123;        int l = i+1-p[i];        if(l != i+1 &amp;&amp; (i+1)%l == 0)            printf(&quot;%d %d\n&quot;, i+1, (i+1)/l);    &#125;&#125;int main()&#123;    int n, T = 1;    while(~scanf(&quot;%d&quot;, &amp;n) &amp;&amp; n)    &#123;        scanf(&quot;%s&quot;, a);        printf(&quot;Test case #%d\n&quot;, T++);        solve(n);        printf(&quot;\n&quot;);    &#125;    return 0;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>KMP&amp;amp;Manacher</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU 3746 Cyclic Nacklace(kmp求循环节)</title>
    <link href="/posts/32264.html"/>
    <url>/posts/32264.html</url>
    
    <content type="html"><![CDATA[<p>** 题目链接 ** ： <a href="http://acm.hust.edu.cn/vjudge/contest/view.action?cid=70325#problem/D"> [kuangbin带你飞]专题十六 KMP &amp; 扩展KMP &amp; Manacher D - Cyclic Nacklace </a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><blockquote><p>给一字符串，求在其尾部添加最少多少个字符，可以使其内部循环两次以上。<br>例：ababa，需后面添加b即可 ababc需后面添加ababc。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><blockquote><p>kmp求出字符串前后缀重复数next[n-1]，则尾部不能循环的部分长度为L＝n－next[n-1]，需要补充的长度为L - n%L;</p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="hljs">#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;using namespace std;char a[100009];int p[100009];void init(int m)&#123;    memset(p, 0, sizeof(p));    for(int i=1, k=0; i&lt;m; i++)    &#123;        while(k&gt;0 &amp;&amp; a[i]!=a[k]) k = p[k-1];        if(a[i] == a[k]) k++;        p[i] = k;    &#125;&#125;int solve(int n)&#123;    init(n);    int l = n-p[n-1];    if(l != n &amp;&amp; n%l == 0)        return 0;    return l - n%l;&#125;int main()&#123;    int T;    scanf(&quot;%d&quot;, &amp;T);    while(T--)    &#123;        scanf(&quot;%s&quot;, a);        printf(&quot;%d\n&quot;, solve(strlen(a)));    &#125;    return 0;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>KMP&amp;amp;Manacher</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>51Nod 1405 树的距离之和(dp)</title>
    <link href="/posts/8273.html"/>
    <url>/posts/8273.html</url>
    
    <content type="html"><![CDATA[<p><a href="http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1405"> 1405 树的距离之和</a><br><img src="http://www.51nod.com/images/icon/ok.png"></p><p>基准时间限制：1 秒 空间限制：131072 KB 分值: 40 <a href="http://www.51nod.com/onlineJudge/problemList.html#!groupId=5"> 难度：4级算法题</a></p><p><img src="http://www.51nod.com/images/icon/star.png"> 收藏</p><p><img src="http://www.51nod.com/images/icon/plus.png"> 关注</p><p>给定一棵无根树，假设它有n个节点，节点编号从1到n, 求任意两点之间的距离（最短路径）之和。</p><p>Input</p><pre><code class="hljs">第一行包含一个正整数n (n &lt;= 100000)，表示节点个数。后面(n - 1)行，每行两个整数表示树的边。</code></pre><p>Output</p><pre><code class="hljs">每行一个整数，第i(i = 1,2,...n)行表示所有节点到第i个点的距离之和。</code></pre><p>Input示例</p><pre><code class="hljs">41 23 24 2</code></pre><p>Output示例</p><pre><code class="hljs">5355</code></pre><p>思路：</p><p>首先，任选一个节点，设定为树的根。</p><p>用num[x]表示以节点x为根的子树的节点总数(包含x自身)</p><p>假如设定节点1为根，则先求出dp[1]，  表示所有节点到节点1的距离之和，</p><p>对根而言也是所有节点的深度之和。</p><p>若x是y的子结点，则有</p><p>dp[x] = dp[y] + (n-num[x]) - num[x];</p><p>因为x为根的子树的所有节点到x的距离比到y的距离少1，所以减num[x]</p><p>其余节点到x的距离比到y的距离多1，所以加 n-num[x]</p><p>代码：</p><pre><code class="hljs">#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;#pragma comment(linker, &quot;/STACK:10240000,10240000&quot;)//递归太深，导致爆栈，所以使用扩栈语句using namespace std;const int N = 100009;int dp[N] = &#123;&#125;, num[N];vector&lt;int&gt; p[N];bool f[N] = &#123;&#125;;void dfs(int s, int depth)&#123;    int len = p[s].size();    f[s] = 1;    num[s] = 1;    dp[1] += depth;    for(int i=0; i&lt;len; i++)    &#123;        if(!f[p[s][i]])        &#123;            dfs(p[s][i], depth+1);            num[s] += num[p[s][i]];        &#125;    &#125;&#125;void solve(int s, int n)&#123;    int len = p[s].size();    f[s] = 1;    for(int i=0; i&lt;len; i++)    &#123;        if(!f[p[s][i]])        &#123;            dp[p[s][i]] = dp[s]+n-num[p[s][i]]*2;            solve(p[s][i], n);        &#125;    &#125;&#125;int main()&#123;    int n;    scanf(&quot;%d&quot;, &amp;n);    for(int i=1; i&lt;n; i++)    &#123;        int a, b;        scanf(&quot;%d%d&quot;, &amp;a, &amp;b);        p[a].push_back(b);        p[b].push_back(a);    &#125;    dfs(1, 0);    memset(f, 0, sizeof(f));    solve(1, n);    for(int i=1; i&lt;=n; i++)        printf(&quot;%d\n&quot;, dp[i]);    return 0;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ 3616 Milking Time(最大递增子序列)</title>
    <link href="/posts/55307.html"/>
    <url>/posts/55307.html</url>
    
    <content type="html"><![CDATA[<p>** 题目链接 ** ： <a href="http://acm.hust.edu.cn/vjudge/contest/view.action?cid=68966#problem/R"> [kuangbin带你飞]专题十二 基础DP1 R - Milking Time </a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><blockquote><p>奶牛为自己规划下面n时间内的产奶，m个时间段，每个段有a，b，c表示从a时到b时共可产奶c。<br>挤奶工每次挤奶必须挤完完整的时间段，且每次挤完需要休息r时，求最终可获得的牛奶最大值<br>ps. 上面的n简直了，不仔细看题很容易误解，差点让我简单问题复杂化，所有的时间段的时间都不会超出1～n的范围，所以可以忽略这个数值。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><blockquote><p>时间为判断条件，且必然由小到大。<br>以开始时间为条件对时间段进行排序，求最大递增子序列。</p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="hljs">#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;using namespace std;const int N = 1009;int dp[N];struct Node&#123;    int l, r, v;    bool operator &lt;(const Node &amp;t) const    &#123;        return l &lt; t.l;    &#125;&#125;a[N];int main()&#123;    int n, m, r;    scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;r);    for(int i=0; i&lt;m; i++)        scanf(&quot;%d%d%d&quot;, &amp;a[i].l ,&amp;a[i].r, &amp;a[i].v);    sort(a, a+m);    int ans = 0;    for(int i=0; i&lt;m; i++)    &#123;        int mmax = 0;        for(int j=0; j&lt;i; j++)            if(a[j].r+r&lt;=a[i].l &amp;&amp; mmax&lt;dp[j])                mmax = dp[j];        dp[i] = mmax+a[i].v;        ans = max(ans, dp[i]);    &#125;    cout&lt;&lt;ans&lt;&lt;endl;    return 0;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU 2859 Phalanx</title>
    <link href="/posts/39070.html"/>
    <url>/posts/39070.html</url>
    
    <content type="html"><![CDATA[<p>** 题目链接 ** ： <a href="http://acm.hust.edu.cn/vjudge/contest/view.action?cid=68966#problem/Q"> [kuangbin带你飞]专题十二 基础DP1 Q - Phalanx </a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><blockquote><p>给定矩阵，求符合对称矩阵的最大子矩阵的宽度。 这里的对称矩阵是以 ** 左下至右上 ** 为轴的。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><blockquote><p>一个n＊n的对称矩阵，对角线上的元素上方与右方的相同元素数量，一定比其左下方少1。<br>例如<br>123<br>412<br>541<br>上面矩阵对角线上<br>3的相同元素数量为1(包括自身)，<br>1为2，5为3<br>所以可以把每个矩阵视为其所在矩阵的对角线上的元素，如果其相同元素大于右上方，则它当前所在对称矩阵的最大宽度为右上方的最大宽度加1</p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="1-第一次ac"><a href="#1-第一次ac" class="headerlink" title="1. 第一次ac"></a>1. 第一次ac</h3><pre><code class="hljs">#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;using namespace std;const int N = 1009;int dp[N][N];char s[N][N];int main()&#123;    int n;    while(cin&gt;&gt;n &amp;&amp; n)    &#123;        memset(dp, 0, sizeof(dp));        for(int i=0; i&lt;n; i++)        &#123;            cin&gt;&gt;s[i];            dp[0][i] = 1;        &#125;        int ans = 1;        for(int i=1; i&lt;n; i++)        &#123;            for(int j=n-1; j&gt;=0; j--)            &#123;                int x = i-1, y = j+1;                int num = 1;                while(x&gt;=0 &amp;&amp; x&lt;n &amp;&amp; y&gt;=0 &amp;&amp; y&lt;n &amp;&amp; s[x][j] == s[i][y])                &#123;                    num++;                    x--;                    y++;                &#125;                if(num &gt; dp[i-1][j+1])                    dp[i][j] = dp[i-1][j+1]+1;                else                    dp[i][j] = num;                ans = max(dp[i][j], ans);            &#125;        &#125;        cout&lt;&lt;ans&lt;&lt;endl;    &#125;    return 0;&#125;</code></pre><h3 id="2-第二次ac，发现dp数组可以从二维降至一维"><a href="#2-第二次ac，发现dp数组可以从二维降至一维" class="headerlink" title="2. 第二次ac，发现dp数组可以从二维降至一维"></a>2. 第二次ac，发现dp数组可以从二维降至一维</h3><pre><code class="hljs">#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;using namespace std;const int N = 1009;int dp[N];char s[N][N];int main()&#123;    int n;    while(~scanf(&quot;%d&quot;, &amp;n) &amp;&amp; n)    &#123;        memset(dp, 0, sizeof(dp));        for(int i=0; i&lt;n; i++)            scanf(&quot;%s&quot;, s[i]);        int ans = 1;        for(int i=0; i&lt;n; i++)        &#123;            for(int j=0; j&lt;n; j++)            &#123;                int x = i-1, y = j+1;                int num = 1;                while(x&gt;=0 &amp;&amp; x&lt;n &amp;&amp; y&gt;=0 &amp;&amp; y&lt;n &amp;&amp; s[x][j] == s[i][y])                &#123;                    num++;                    x--;                    y++;                &#125;                if(num &gt; dp[j+1])                    dp[j] = dp[j+1]+1;                else                    dp[j] = num;                ans = max(dp[j], ans);            &#125;        &#125;        printf(&quot;%d\n&quot;, ans);    &#125;    return 0;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU 1078 FatMouse and Cheese(记忆化搜索)</title>
    <link href="/posts/32414.html"/>
    <url>/posts/32414.html</url>
    
    <content type="html"><![CDATA[<p>** 题目链接 ** ： <a href="http://acm.hust.edu.cn/vjudge/contest/view.action?cid=68966#problem/P"> [kuangbin带你飞]专题十二 基础DP1 P - FatMouse and Cheese </a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><blockquote><p>给n＊n地图，老鼠初始位置在(0,0)，它每次行走要么横着走要么竖着走，每次最多可以走出k个单位长度，且落脚点的权值必须比上一个落脚点的权值大，求最终可<br>以获得的最大权值<br>(题目很容易会理解错题意，道友小心)</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><blockquote><p>记忆化搜索，具体见代码注释</p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="hljs">#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include&lt;stack&gt;#include&lt;queue&gt;using namespace std;const int N = 109;int dp[N][N], a[N][N];int px[] = &#123;0, 0, -1, 1&#125;;int py[] = &#123;1, -1, 0, 0&#125;;int dfs(int n, int m, int x, int y)&#123;    if(!dp[x][y])    &#123;        int ans = 0;        for(int i=1; i&lt;=m; i++)//最多m步        &#123;            int temp = 0;//记录四个方向的下一次走法可以获得的权值总和            for(int j=0; j&lt;4; j++)//四个方向            &#123;                int tx = x + px[j]*i;//因为只能直走                int ty = y + py[j]*i;                if(tx&gt;=1 &amp;&amp; tx&lt;=n &amp;&amp; ty&gt;=1 &amp;&amp; ty&lt;=n &amp;&amp; a[tx][ty]&gt;a[x][y])                    temp = max(temp, dfs(n, m, tx, ty));            &#125;            ans = max(ans, temp);//m种情况选最大        &#125;        dp[x][y] = ans + a[x][y];//记录    &#125;    return dp[x][y];&#125;int main()&#123;    int n, m;    while(~scanf(&quot;%d%d&quot;, &amp;n, &amp;m) &amp;&amp; n!=-1 &amp;&amp; m!=-1)    &#123;        memset(dp, 0, sizeof(a));        for(int i=1; i&lt;=n; i++)            for(int j=1; j&lt;=n; j++)                scanf(&quot;%d&quot;, &amp;a[i][j]);        printf(&quot;%d\n&quot;, dfs(n, m, 1, 1));    &#125;    return 0;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ 3186 Treats for the Cows</title>
    <link href="/posts/13702.html"/>
    <url>/posts/13702.html</url>
    
    <content type="html"><![CDATA[<p>** 题目链接 ** ： <a href="http://acm.hust.edu.cn/vjudge/contest/view.action?cid=68966#problem/O"> [kuangbin带你飞]专题十二 基础DP1 O - Treats for the Cows </a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><blockquote><p>给长度为n的序列，每次只能从首或尾取一个数，第i次取的数权值为(数值*i)，求取完所有的数可以达到的最大权值。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><blockquote><p>dp[i][j]表示左边取了i个数，右边取了j个数<br>故<br>dp[i][j] = max(dp[i-1][j] + a[i]* (i+j), dp[i][j-1] + a[n-j+1]*(i+j));<br>注意当ij为0的边界判断即可。</p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="hljs">#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include&lt;stack&gt;#include&lt;queue&gt;using namespace std;const int N = 2009;int dp[N][N];int a[N];int main()&#123;    int n;    cin&gt;&gt;n;    for(int i=1; i&lt;=n; i++)        cin&gt;&gt;a[i];    for(int i=0; i&lt;=n; i++)    &#123;        for(int j=0; j+i&lt;=n; j++)            if(i == 0 &amp;&amp; j == 0)                dp[i][j] = 0;            else if(j == 0)                dp[i][j] = dp[i-1][j] + a[i]*(i+j);            else if(i == 0)                dp[i][j] = dp[i][j-1] + a[n-j+1]*(i+j);            else                dp[i][j] = max(dp[i-1][j] + a[i]*(i+j),                               dp[i][j-1] + a[n-j+1]*(i+j));    &#125;    int ans = 0;    for(int i=0; i&lt;=n; i++)        ans = max(ans, dp[i][n-i]);    cout&lt;&lt;ans&lt;&lt;endl;    return 0;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ 2533 Longest Ordered Subsequence</title>
    <link href="/posts/29307.html"/>
    <url>/posts/29307.html</url>
    
    <content type="html"><![CDATA[<p>** 题目链接 ** ： <a href="http://acm.hust.edu.cn/vjudge/contest/view.action?cid=68966#problem/N"> [kuangbin带你飞]专题十二 基础DP1 N - Longest Ordered Subsequence </a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><blockquote><p>求最大递增子序列的长度</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><blockquote><p>两种方法<br>1. dp[i] = max(dp[j]+1) 1&lt;=j&lt;=i-1(n^2)<br>2. LIS(nlogn)</p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="hljs">#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;stack&gt;#include&lt;queue&gt;using namespace std;const int N = 1009;int dp[N], a[N];int main()&#123;    int n;    cin&gt;&gt;n;    for(int i=0; i&lt;n; i++)        cin&gt;&gt;a[i];    int ans = 0;    for(int i=0; i&lt;n; i++)    &#123;        int mmax = 0;        for(int j=0; j&lt;i; j++)            if(a[j]&lt;a[i] &amp;&amp; mmax&lt;dp[j])                mmax = dp[j];        dp[i] = mmax+1;        ans = max(ans, dp[i]);    &#125;    cout&lt;&lt;ans&lt;&lt;endl;    return 0;&#125;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;stack&gt;#include&lt;queue&gt;using namespace std;const int N = 1009;int dp[N], a[N];int binary_search(int len, int x)&#123;    int start = 0;    while(start &lt; len)    &#123;        int mid = (start + len)/2;        if(dp[mid] == x)            return mid;        else if(dp[mid] &gt; x)            len = mid;        else            start = mid+1;    &#125;    return len;&#125;int main()&#123;    int n;    cin&gt;&gt;n;    for(int i=0; i&lt;n; i++)        cin&gt;&gt;a[i];    int len = 1;    dp[0] = -1;    for(int i=0; i&lt;n; i++)    &#123;        int pos = binary_search(len, a[i]);        if(pos == len)            len++;        dp[pos] = a[i];    &#125;    cout&lt;&lt;len-1&lt;&lt;endl;    return 0;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>博弈之 Nim 游戏&amp;poj 3537 Crosses and Crosses</title>
    <link href="/posts/38035.html"/>
    <url>/posts/38035.html</url>
    
    <content type="html"><![CDATA[<p>参考链接： [ 博弈之 Nim 游戏和 sg 函数 ](<a href="https://software.intel.com/zh-cn/blogs/2014/03/06">https://software.intel.com/zh-cn/blogs/2014/03/06</a><br>/nim-sg)<br>题目链接： <a href="http://acm.hust.edu.cn/vjudge/problem/viewProblem.action?id=14163"> poj 3537 Crosses and Crosses</a></p><h2 id="Nim游戏的定义"><a href="#Nim游戏的定义" class="headerlink" title="Nim游戏的定义"></a>Nim游戏的定义</h2><pre><code class="hljs">Nim游戏是组合游戏(Combinatorial Games)的一种，准确来说，属于“Impartial Combinatorial Games”（以下简称ICG）。满足以下条件的游戏是ICG（可能不太严谨）：</code></pre><blockquote><ol><li>有两名选手；</li></ol></blockquote><blockquote><ol start="2"><li>两名选手交替对游戏进行移动(move)，每次一步，选手可以在（一般而言）有限的合法移动集合中任选一种进行移动；</li></ol></blockquote><blockquote><ol start="3"><li>对于游戏的任何一种可能的局面，合法的移动集合只取决于这个局面本身，不取决于轮到哪名选手操作、以前的任何操作、骰子的点数或者其它什么因素；</li></ol></blockquote><blockquote><ol start="4"><li>如果轮到某名选手移动，且这个局面的合法的移动集合为空（也就是说此时无法进行移动），则这名选手负。</li></ol></blockquote><h2 id="必败必胜策略的定义"><a href="#必败必胜策略的定义" class="headerlink" title="必败必胜策略的定义"></a>必败必胜策略的定义</h2><blockquote><p>定义P-position和N-position，其中P代表Previous，N代表Next。直观的说，上一次move的人有必胜策略的局面是P-<br>position，也就是“后手可保证必胜”或者“先手必败”，现在轮到move的人有必胜策略的局面是N-<br>position，也就是“先手可保证必胜”。更严谨的定义是：1.无法进行任何移动的局面（也就是terminal position）是P-position；2<br>.可以移动到P-position的局面是N-position；3.所有移动都导致N-position的局面是P-<br>position。按照这个定义，如果局面不可能重现，或者说positions的集合可以进行拓扑排序，那么每个position或者是P-<br>position或者是N-position，而且可以通过定义计算出来。</p></blockquote><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><pre><code class="hljs">poj3537就是Nim游戏的一种：有个2人玩的游戏在一个规模为1*n的棋盘上进行，每次一个人选择一个地方画上’X’,一旦某个人画上X后出现了连续3个X，那么这个人就赢了。给你n（3≤n≤=2000）问先手和后手谁会赢。</code></pre><p>仔细思考一下我们发现，xxx的上一步只能是oxx，xox，xxo的其中一种，也就是说如果谁走出一步形成上述局面那么谁就必败。<br>再进一步说，如果你在第i个格子画x，那么i-1,i-2,i+1,i+2，都不可以画x，因为那样会必败。<br>这样题目就可以转化为，轮流画x，谁没有格子画x谁就输。<br>以上例来进行一下计算，假设N为3，也就是OOOO，当前局面有4个子局面，XOOO，OXOO，OOXO，OOOX。<br>1. XOOO对于当前玩家只有一步可走，就是XOOX(别忘了上面说过每走一步，该位置左右共4个位置都不能)，所以XOOO就是一个N－position局面(<br>后手输)。<br>2. OXOO对于当前玩家无步可走，所以是一个P－position(先手输)。<br>3. 4. OOXO,OOOX就不再赘述，前者P，后者N。<br>** 那么OOOO显然是一个N－position，因为他的子局面中有P－position(他当然会把这种局面留给自己的对手)。 **</p><p>根据上面这个过程，可以得到一个递归的算法——对于当前的局面，递归计算它的所有子局面的性质，如果存在某个子局面是P-<br>position，那么向这个子局面的移动就是必胜策略。当然，会存在大量的重叠子问题，可以用DP或者记忆化搜索的方法以提高效率。<br>但问题是，利用这个算法，对于某个Nim游戏的局面(a1,a2,…,an)来说，要想判断它的性质以及找出必胜策略，需要计算O(a1<em>a2</em>…*an)个局面的性<br>质，不管怎样记忆化都无法降低这个时间复杂度。所以我们需要更高效的判断Nim游戏的局面的性质的方法，也就是Bouton’s<br>Theorem，上面的参考链接里有这个的详细解释与证明，就不贴了。</p><p>** 总之，通过Bouton’s Theorem，可以得到，如果a的子局面a1^a2^..^an == 0，a就是一个N－position，否则a是P－position。 **<br>** 这也解清了我对好多人用异或的一个疑惑。 **</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="hljs">#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;stack&gt;#include&lt;queue&gt;using namespace std;const int N = 2009;int sg[N];int getsg(int n)&#123;    if(n&lt;=0)        return 0;    if(sg[n] != -1)        return sg[n];    bool f[N] = &#123;&#125;;//对当前局面的子局面进行标记    for(int i=1; i&lt;=n; i++)        f[getsg(i-3)^getsg(n-i-2)] = 1;//标记所有的子局面    for(int i=0; ; i++)//如果子局面没有0，则说明当前局面为P－position。        if(!f[i])            return sg[n] = i;&#125;int main()&#123;    int n;    while(cin&gt;&gt;n)    &#123;        memset(sg, -1, sizeof(sg));        if(getsg(n))            cout&lt;&lt;&quot;1&quot;&lt;&lt;endl;        else            cout&lt;&lt;&quot;2&quot;&lt;&lt;endl;    &#125;    return 0;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>博弈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ 1661 Help Jimmy</title>
    <link href="/posts/32253.html"/>
    <url>/posts/32253.html</url>
    
    <content type="html"><![CDATA[<p>** 题目链接 ** ： <a href="http://acm.hust.edu.cn/vjudge/contest/view.action?cid=68966#problem/M"> [kuangbin带你飞]专题十二 基础DP1 M - Help Jimmy </a></p><p>** 做中文题真开心，不用浪费时间在翻译上，上帝啊，让中文统治世界吧。 **</p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><blockquote><p>Description</p></blockquote><blockquote></blockquote><blockquote><p>“Help Jimmy” 是在下图所示的场景上完成的游戏。<br>场景中包括多个长度和高度各不相同的平台。地面是最低的平台，高度为零，长度无限。<br>![这里写图片描述](<a href="http://7xjob4.com1.z0.glb.clouddn.com/0b9f30603f1b35df0918f9dc606d9">http://7xjob4.com1.z0.glb.clouddn.com/0b9f30603f1b35df0918f9dc606d9</a><br>d8b)<br>Jimmy老鼠在时刻0从高于所有平台的某处开始下落，它的下落速度始终为1米/秒。当Jimmy落到某个平台上时，游戏者选择让它向左还是向右跑，它跑动的速度也是<br>1米/秒。当Jimmy跑到平台的边缘时，开始继续下落。Jimmy***每次下落的高度不能超过MAX米 _ * _ ，不然就会摔死，游戏也会结束。</p></blockquote><blockquote></blockquote><blockquote><p>设计一个程序，计算Jimmy到底地面时可能的最早时间。<br>Input<br>第一行是测试数据的组数t（0 &lt;= t &lt;= 20）。每组测试数据的第一行是四个整数N，X，Y，MAX，用空格分隔。N是平台的数目（不包括地面），X和Y是J<br>immy开始下落的位置的横竖坐标，MAX是一次下落的最大高度。接下来的N行每行描述一个平台，包括三个整数，X1[i]，X2[i]和H[i]。H[i]表示平台<br>的高度，X1[i]和X2[i]表示平台左右端点的横坐标。1 &lt;= N &lt;= 1000，-20000 &lt;= X, X1[i], X2[i] &lt;=<br>20000，0 &lt; H[i] &lt; Y &lt;= 20000（i = 1..N）。所有坐标的单位都是米。</p></blockquote><blockquote></blockquote><blockquote><p>Jimmy的大小和平台的厚度均忽略不计。 ** _ 如果Jimmy恰好落在某个平台的边缘，被视为落在平台上 _ **<br>。所有的平台均不重叠或相连。测试数据保证问题一定有解。<br>Output<br>对输入的每组测试数据，输出一个整数，Jimmy到底地面时可能的最早时间。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><blockquote><p>因为对于每一个台层，只有两种状态，向左走或向右走，所以可以用dp[N][2]来保存所有的状态。<br>老鼠下台子和上台子其实是等价的，所以把问题看作是从地面任意一点通向起始点的最短时间。<br>显然，高层台子一定是由它下方的偏低台子来到达的，那么<br>dp[i][0] = min(dp[k][0]+l[i]-l[k], dp[k][1]+r[i]-l[k]) + h[i]-h[k]; (左左和左右取最小)<br>dp[i][1] = min(dp[k][0]+r[i]-l[k], dp[k][1]+r[i]-r[k]) + h[i]-h[k];(右左和右右取最小)<br>要注意对下方直接为地面的台层的特殊处理，以及应当注意的细节题目都已说明，已在上面标记。</p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="hljs">#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;stack&gt;#include&lt;queue&gt;using namespace std;struct Node&#123;    int l, r, h;    bool operator &lt; (const Node &amp;t) const    &#123;        return h &lt; t.h;    &#125;&#125;node[1009];int dp[1009][2];int main()&#123;    int T;    cin&gt;&gt;T;    while(T--)    &#123;        int n, x, y, m;        cin&gt;&gt;n&gt;&gt;x&gt;&gt;y&gt;&gt;m;        memset(dp, 0x3f3f3f3f, sizeof(dp));        for(int i=0; i&lt;n; i++)            cin&gt;&gt;node[i].l&gt;&gt;node[i].r&gt;&gt;node[i].h;        node[n].l = x;        node[n].r = x;        node[n].h = y;        sort(node, node+n);        for(int j=0; j&lt;=n; j++)        &#123;            int lp, rp;            lp = rp = -1;            for(int k=j-1; k&gt;=0; k--)            &#123;                if(lp == -1 &amp;&amp; node[k].l&lt;=node[j].l &amp;&amp; node[k].r&gt;=node[j].l)                    lp = k;                if(rp == -1 &amp;&amp; node[k].l&lt;=node[j].r &amp;&amp; node[k].r&gt;=node[j].r)                    rp = k;            &#125;            if(lp == -1 &amp;&amp; node[j].h &lt;= m)                dp[j][0] = node[j].h;            if(rp == -1 &amp;&amp; node[j].h &lt;= m)                dp[j][1] = node[j].h;            if(lp != -1 &amp;&amp; node[j].h-node[lp].h &lt;= m)                dp[j][0] = min(dp[lp][0]+node[j].l-node[lp].l, dp[lp][1]+node[lp].r-node[j].l) + node[j].h-node[lp].h;            if(rp != -1 &amp;&amp; node[j].h-node[rp].h &lt;= m)                dp[j][1] = min(dp[rp][0]+node[j].r-node[rp].l, dp[rp][1]+node[rp].r-node[j].r) + node[j].h-node[rp].h;        &#125;        printf(&quot;%d\n&quot;, dp[n][1]);    &#125;    return 0;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU 1160 FatMouse&#39;s Speed</title>
    <link href="/posts/50295.html"/>
    <url>/posts/50295.html</url>
    
    <content type="html"><![CDATA[<p>题目链接： <a href="http://acm.hust.edu.cn/vjudge/contest/view.action?cid=68966#problem/J"> [kuangbin带你飞]专题十二 基础DP1 J - FatMouse’s Speed</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><blockquote><p>给n个老鼠的体重和速度，求找出一个最长的序列，此序列体重递增速度递减</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><blockquote><p>按体重递增排序，再求最长递增(此递增表示体重递增速度递减)子序列。<br>dp[i] = max(dp[j]+1) 0&lt;=j&lt;=i-1</p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="hljs">#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;stack&gt;#include&lt;queue&gt;using namespace std;const int N = 1006;struct Node&#123;    int a, b, i;    bool operator &lt;(const Node &amp;t) const    &#123;        return a &lt; t.a;    &#125;&#125;p[N];int dp[N], fa[N], ans[N];int main()&#123;    int pos = 0;    while(~scanf(&quot;%d%d&quot;, &amp;p[pos].a, &amp;p[pos].b))    &#123;        p[pos].i = pos+1;        pos++;    &#125;    sort(p, p+pos);    memset(fa, -1, sizeof(fa));    int ians = 0, amax = 0;    for(int i=0; i&lt;pos; i++)    &#123;        int mmax = 0;        for(int j=0; j&lt;i; j++)        &#123;            if(p[j].a &lt; p[i].a &amp;&amp; p[j].b &gt; p[i].b &amp;&amp; mmax &lt; dp[j])            &#123;                mmax = dp[j];                fa[i] = j;            &#125;        &#125;        dp[i] = mmax+1;        if(amax &lt; dp[i])        &#123;            amax = dp[i];            ians = i;        &#125;    &#125;    printf(&quot;%d\n&quot;, amax);    int i = 0;    while(i &lt; amax)    &#123;        ans[i++] = p[ians].i;        ians = fa[ians];    &#125;    while(i--)        printf(&quot;%d\n&quot;, ans[i]);    return 0;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU 1260 Tickets</title>
    <link href="/posts/55318.html"/>
    <url>/posts/55318.html</url>
    
    <content type="html"><![CDATA[<p>题目链接： <a href="http://acm.hust.edu.cn/vjudge/contest/view.action?cid=68966#problem/F"> [kuangbin带你飞]专题十二 基础DP1 H - Tickets</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><blockquote><p>给出T，表示有T组样例<br>给出n，表示有n个人买票<br>给出n个数表示这个人单独买票会花的时间..<br>给出n-1个数，表示这个人和前面那个人一起买票会花的时间<br>求最快多少分钟可以把票买完</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><blockquote><p>dp[i] = max(dp[i-1]+a[i], dp[i-2]+b[i])</p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="hljs">#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;stack&gt;#include&lt;queue&gt;using namespace std;const int N = 2006;int dp[N], a[N], b[N];int main()&#123;    int T;    scanf(&quot;%d&quot;, &amp;T);    while(T--)    &#123;        int n;        scanf(&quot;%d&quot;, &amp;n);        for(int i=1; i&lt;=n; i++)            scanf(&quot;%d&quot;, &amp;a[i]);        for(int i=2; i&lt;=n; i++)            scanf(&quot;%d&quot;, &amp;b[i]);        dp[1] = a[1];        for(int i=2; i&lt;=n; i++)        &#123;            dp[i] = min(dp[i-1]+a[i], dp[i-2]+b[i]);        &#125;        int s = dp[n]%60;        int m = dp[n]/60%60;        int h = (dp[n]/3600 + 8)%24;        if(h &gt; 12)            printf(&quot;%02d:%02d:%02d pm\n&quot;, h-12, m, s);        else            printf(&quot;%02d:%02d:%02d am\n&quot;, h, m, s);    &#125;    return 0;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU 1087 Super Jumping! Jumping! Jumping!(最大递增子串和)</title>
    <link href="/posts/19963.html"/>
    <url>/posts/19963.html</url>
    
    <content type="html"><![CDATA[<p>题目链接： <a href="http://acm.hust.edu.cn/vjudge/contest/view.action?cid=68966#problem/E"> [kuangbin带你飞]专题十二 基础DP1 E - Super Jumping! Jumping! Jumping!</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><blockquote></blockquote><p>起点(-无穷)终点(+无穷)中间有n个点，各有一个值，现想从起点到达终点，只能前行不能后退，且下一步必须比前面的点的值大，求所有走的点的值总和最大是多少。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><blockquote><p>dp[i] = max(dp[k] + a[j]); 1&lt;=k&lt;=i-1;<br>最大递增子串和。</p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="hljs">#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;stack&gt;#include&lt;queue&gt;using namespace std;const int N = 1006;int dp[N], a[N];int main()&#123;    int n;    while(~scanf(&quot;%d&quot;, &amp;n) &amp;&amp; n)    &#123;        int ans = 0;        for(int i=0; i&lt;n; i++)        &#123;            scanf(&quot;%d&quot;, &amp;a[i]);            dp[i] = a[i];            int mmax = 0;            for(int j=0; j&lt;i; j++)                if(a[j] &lt; a[i])                    mmax = max(dp[j], mmax);            dp[i] += mmax;            ans = max(ans, dp[i]);        &#125;        printf(&quot;%d\n&quot;, ans);    &#125;    return 0;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU 1074 Doing Homework(状态压缩dp)</title>
    <link href="/posts/4922.html"/>
    <url>/posts/4922.html</url>
    
    <content type="html"><![CDATA[<p>题目链接： <a href="http://acm.hust.edu.cn/vjudge/contest/view.action?cid=68966#problem/D"> [kuangbin带你飞]专题十二 基础DP1 D - Doing Homework</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><blockquote><p>有n门功课需要完成，每一门功课都有时间期限以及你完成所需要的时间，如果完成的时间超出时间期限多少单位，就会被减多少学分，问以怎样的功课完成顺序，会使减掉<br>的学分最少，有多个解时，输出功课名排列最小的一个。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><blockquote><p>利用二进制位的方法来解题用过不少次，但真正意义上的状态压缩dp，这是第一道，有纪念意义，当然，一开始也没想出来，看了前人思路才恍然大悟。<br>先大致说说状态压缩，假设有三门作业a，b，c<br>那么，abc都做完即111，111可由101，110，011任意一个来得到。而101可以从100或者001来得到，这就是状态压缩dp的一个基本的状态转移。<br>之前自己一直奇怪二进制10串怎么能跟全排列扯上关系，相通上面那么思路，当然就迎刃而解。</p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="hljs">#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;stack&gt;#include&lt;queue&gt;using namespace std;const int N = 16;struct Node&#123;    char str[109];    int want, need;&#125;node[N];struct DP&#123;    int now, sum, next, pos;&#125;dp[1&lt;&lt;N];void put_ans(int x)&#123;    if(dp[x].next != -1)    &#123;        put_ans(dp[x].next);        printf(&quot;%s\n&quot;, node[dp[x].pos].str);    &#125;&#125;int main()&#123;    int T;    scanf(&quot;%d&quot;, &amp;T);    while(T--)    &#123;        int n;        scanf(&quot;%d&quot;, &amp;n);        for(int i=0; i&lt;n; i++)            scanf(&quot;%s%d%d&quot;, node[i].str, &amp;node[i].want, &amp;node[i].need);        dp[0].now = dp[0].sum = 0;        dp[0].next = dp[0].pos = -1;        int m = (1&lt;&lt;n)-1;        for(int i=1; i&lt;=m; i++)        &#123;            dp[i].sum = 0x3f3f3f3f;            for(int j=0; j&lt;n; j++)            &#123;                if((1&lt;&lt;j) &amp; i)                &#123;                    int k = i - (1&lt;&lt;j);                    int v = dp[k].now + node[j].need - node[j].want;                    v = max(v, 0);                    if(dp[i].sum &gt;= dp[k].sum+v)                    &#123;                        dp[i].sum = dp[k].sum + v;                        dp[i].now = dp[k].now + node[j].need;                        dp[i].next = k;                        dp[i].pos = j;                    &#125;                &#125;            &#125;        &#125;        printf(&quot;%d\n&quot;, dp[m].sum);        put_ans(m);    &#125;    return 0;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU 1069 Monkey and Banana(最大递增子串)</title>
    <link href="/posts/41255.html"/>
    <url>/posts/41255.html</url>
    
    <content type="html"><![CDATA[<p>题目链接： <a href="http://acm.hust.edu.cn/vjudge/contest/view.action?cid=68966#problem/C"> [kuangbin带你飞]专题十二 基础DP1 C - Monkey and Banana</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="** 题意 **"></a>** 题意 **</h3><blockquote><p>给定箱子种类数量n，及对应长宽高，每个箱子数量无限，求其能叠起来的最大高度是多少(上面箱子的长宽严格小于下面箱子)</p></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="** 思路 **"></a>** 思路 **</h3><blockquote><p>每种箱子有三种放置方式且数量无限，故可将每个箱子按三个箱子看待。对所有箱子按主长副宽进行先大后小排序，那么问题就成了求最大递增子串。<br>因为n的范围特别小，只有30，所以直接两重循环dp即可</p></blockquote><h3 id="代码"><a href="#代码" class="headerlink" title="** 代码 **"></a>** 代码 **</h3><pre><code class="hljs">#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;stack&gt;#include&lt;queue&gt;using namespace std;const int N = 39;struct Node&#123;    int a, b, c;    bool operator &lt; (const Node &amp;t) const    &#123;        if(a == t.a)            return b &gt; t.b;        return a &gt; t.a;    &#125;&#125;node[N*3];int dp[N*3];void add(int i, int a, int b, int c)&#123;    node[i].a = a;    node[i].b = b;    node[i].c = c;&#125;int main()&#123;    int n, T = 1;    while(~scanf(&quot;%d&quot;, &amp;n) &amp;&amp; n)    &#123;        for(int i=0; i&lt;n; i++)        &#123;            int a, b, c;            scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);            add(i*3, max(a, b), min(a, b), c);            add(i*3+1, max(a, c), min(a, c), b);            add(i*3+2, max(c, b), min(c, b), a);        &#125;        sort(node, node+n*3);        dp[0] = node[0].c;        int ans = dp[0];        for(int i=1; i&lt;3*n; i++)        &#123;            int temp = 0;            dp[i] = node[i].c;            for(int j=0; j&lt;i; j++)            &#123;                if(node[i].a&lt;node[j].a &amp;&amp; node[i].b&lt;node[j].b)                    temp = max(temp, dp[j]);            &#125;            dp[i] += temp;            ans = max(ans, dp[i]);        &#125;        printf(&quot;Case %d: maximum height = %d\n&quot;, T++, ans);    &#125;    return 0;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU 1029 Ignatius and the Princess IV(水题亦有妙法)</title>
    <link href="/posts/32502.html"/>
    <url>/posts/32502.html</url>
    
    <content type="html"><![CDATA[<p>题目链接： <a href="http://acm.hust.edu.cn/vjudge/contest/view.action?cid=68966#problem/B"> [kuangbin带你飞]专题十二 基础DP1 B - Ignatius and the Princess IV</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="** 题意 **"></a>** 题意 **</h3><blockquote><p>给n(奇数)个数，定义特殊的数为在序列中出现次数不少于(n+1)/2次的数，找出这个特殊的数</p></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="** 思路 **"></a>** 思路 **</h3><blockquote><ol><li>我ac的思路是直接排序，然后一次循环进行对出现次数最大值的判断。</li></ol></blockquote><blockquote><ol start="2"><li>还有一种方法是排序后找第n/2大的数，因为特殊数出现次数超过一半，所以排序后中位数一定是特殊数。</li></ol></blockquote><blockquote><ol start="3"><li>看了大牛博客才发现还有更妙的一种方法，上面两种方法都基本是O(nlogn)，而这个方法是O(n)<br>设置一标志量num，按照原顺序依次迭代，随便假定一个解，如果a[i]==ans，num++，否则num–，当num为0时将当前a[i]作为新解。因为n为奇数<br>，且特殊值出现次数大于一半，所以任何情况下，特殊值做为解时代num不会小于1，所以最终的解一定就是特殊值。</li></ol></blockquote><h3 id="代码"><a href="#代码" class="headerlink" title="** 代码 **"></a>** 代码 **</h3><h4 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h4><pre><code class="hljs">#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;stack&gt;#include&lt;queue&gt;using namespace std;const int N = 1000009;int a[N];int main()&#123;    int n;    while(~scanf(&quot;%d&quot;, &amp;n))    &#123;        for(int i=0; i&lt;n; i++)            scanf(&quot;%d&quot;, &amp;a[i]);        sort(a, a+n);        int ans = a[0];        int num = 1;        int mmax = 0;        for(int i=1; i&lt;n; i++)        &#123;            if(a[i] == a[i-1])                num++;            else            &#123;                if(mmax &lt;= num)                &#123;                    mmax = num;                    ans = a[i-1];                &#125;                num = 1;            &#125;        &#125;        if(mmax &lt;= num)            ans = a[n-1];        printf(&quot;%d\n&quot;, ans);    &#125;    return 0;&#125;</code></pre><h4 id="思路3"><a href="#思路3" class="headerlink" title="思路3"></a>思路3</h4><pre><code class="hljs">#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;stack&gt;#include&lt;queue&gt;using namespace std;const int N = 1000009;int a[N];int main()&#123;    int n;    while(~scanf(&quot;%d&quot;, &amp;n))    &#123;        int num = 0;        int ans = -1;        for(int i=0; i&lt;n; i++)        &#123;            scanf(&quot;%d&quot;, &amp;a[i]);            if(num == 0)            &#123;                ++num;                ans = a[i];            &#125;            else            &#123;                if(ans != a[i])                    num--;                else                    num++;            &#125;        &#125;        printf(&quot;%d\n&quot;, ans);    &#125;    return 0;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU 1024 Max Sum Plus Plus</title>
    <link href="/posts/25907.html"/>
    <url>/posts/25907.html</url>
    
    <content type="html"><![CDATA[<p>题目链接： <a href="http://acm.hust.edu.cn/vjudge/contest/view.action?cid=68966#problem/A"> [kuangbin带你飞]专题十二 基础DP1 A - Max Sum Plus Plus</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="** 题意 **"></a>** 题意 **</h3><blockquote><p>给n个数，将其分为m部分，各部分之间不能有交叉重叠，求最大和</p></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="** 思路 **"></a>** 思路 **</h3><blockquote><p>dp[i][j]表示前j个数分为i部分的最大和，则<br>dp[i][j] = max(dp[i][j-1] + a[j], dp[i-1][k] + a[j]) i-1&lt;=k&lt;=j-1<br>前者是将第j个数加入到第i部分，后者是将第j个数做为第i部分的第一个数。</p></blockquote><blockquote></blockquote><blockquote><h4 id="两个关键点"><a href="#两个关键点" class="headerlink" title="两个关键点"></a>两个关键点</h4></blockquote><blockquote></blockquote><blockquote><ol><li>因为题目n值范围过大，显然二维数组不行。<br>而d[i][x]只与d[i-1][x]有关，所以可以将其降低至一维。<br>即dp[j]表示前j个数所分段后的和。</li></ol></blockquote><blockquote><ol start="2"><li>因为dp[i-1][k]的取值需要一重循环，极有可能导致超时，所以使用数组max存储当前层的最大值，以供下一层求值使用。<br>dp[j] = max(dp[j-1] + a[j], max[j-1] + a[j])</li></ol></blockquote><h3 id="代码"><a href="#代码" class="headerlink" title="** 代码 **"></a>** 代码 **</h3><pre><code class="hljs">#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;stack&gt;#include&lt;queue&gt;using namespace std;const int N = 1000009;int dp[N], a[N], mx[N];int main()&#123;    int n, m;    while(~scanf(&quot;%d%d&quot;, &amp;m, &amp;n))    &#123;        for(int i=1; i&lt;=n; i++)            scanf(&quot;%d&quot;, &amp;a[i]);        memset(mx, 0, sizeof(mx));        dp[0] = 0;        int mmax;        for(int i=1; i&lt;=m; i++)        &#123;            mmax = -100000000;            for(int j=i; j&lt;=n; j++)            &#123;                dp[j] = max(dp[j-1]+a[j], mx[j-1]+a[j]);                mx[j-1] = mmax;                mmax = max(mmax, dp[j]);            &#125;        &#125;        printf(&quot;%d\n&quot;, mmax);    &#125;    return 0;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU 4725 The Shortest Path in Nya Graph(好题)</title>
    <link href="/posts/61029.html"/>
    <url>/posts/61029.html</url>
    
    <content type="html"><![CDATA[<p>题目链接： <a href="http://acm.hust.edu.cn/vjudge/contest/view.action?cid=66569#problem/P"> kuangbin带你飞 专题四 最短路练习 P - The Shortest Path in Nya Graph</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="** 题意 **"></a>** 题意 **</h3><blockquote><p>共n个点，n层(每个点单独一层)，相邻的两层之间权值为w<br>还有m条额外的边，权值为v，求1到n的最短路</p></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="** 思路 **"></a>** 思路 **</h3><blockquote><p>本题可谓好题。时间空间都卡的相当死，硬把我从timeout逼到memorylimit。在求最短路上，本题没有什么难度，dijkstra＋heap或者sp<br>fa邻接表都行。但是在建图上，我一开始是将每个点所在的层数记录下来，然后两重循环进行判断是否相邻来赋权。丝毫没有意识到n的范围10**5，必然超时。<br>久思无果后参看大牛博客，才发现一种空间换时间的法子<br>给每个点两个辅助点，一个做出度，一个做入度，赋其与辅助点边权为0(因为原本就是一个点)，而且这两个辅助点完全可以按照层数来排列，这样就可以把建图优化到O(n<br>)<br>如果还超时，可以用双端队列来对spfa进行优化</p></blockquote><h3 id="代码"><a href="#代码" class="headerlink" title="** 代码 **"></a>** 代码 **</h3><pre><code class="hljs">#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;stack&gt;#include&lt;queue&gt;using namespace std;const int N = 100009;const int MAX = 0x3f3f3f3f;int d[3*N];bool vis[3*N];int h[3*N];struct Edge&#123;    int u, v, w, next;&#125;e[5*N];int num = 0;int spfa(int n)&#123;    memset(vis, 0, sizeof(vis));    memset(d, 0x3f3f3f3f, sizeof(d));    d[1] = 0;    vis[1] = 1;    deque&lt;int&gt; q;    q.push_back(1);    while(!q.empty())    &#123;        int x = q.front();        q.pop_front();        vis[x] = 0;        for(int i=h[x]; i!=-1; i=e[i].next)        &#123;            if(d[e[i].v] &gt; d[x] + e[i].w)            &#123;                d[e[i].v] = d[x] + e[i].w;                if(!vis[e[i].v])                &#123;                    if(d[e[i].v] &lt; d[q.front()] &amp;&amp; !q.empty())                        q.push_front(e[i].v);                    else                        q.push_back(e[i].v);                    vis[e[i].v] = 1;                &#125;            &#125;        &#125;    &#125;    if(d[n] == MAX)        return -1;    return d[n];&#125;void addedge(int u, int v, int w)&#123;    e[num].u = u;    e[num].v = v;    e[num].w = w;    e[num].next = h[u];    h[u] = num++;&#125;int main()&#123;    int T;    scanf(&quot;%d&quot;, &amp;T);    for(int tt=1; tt&lt;=T; tt++)    &#123;        int n,m,w;        num = 0;        memset(h, -1, sizeof(h));        scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;w);        for(int i=1; i&lt;=n; i++)        &#123;            int t;            scanf(&quot;%d&quot;, &amp;t);            addedge(i, n+t*2-1, 0);            addedge(n+t*2, i, 0);        &#125;        for(int i=1; i&lt;n; i++)        &#123;            addedge(n+2*i+1, n+2*i, w);            addedge(n+2*i-1, n+2*i+2, w);        &#125;        for(int i=1; i&lt;=m; i++)        &#123;            int a, b, c;            scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);            addedge(a, b, c);            addedge(b, a, c);        &#125;        printf(&quot;Case #%d: %d\n&quot;, tt, spfa(n));    &#125;    return 0;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>最短路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LightOJ 1074 O</title>
    <link href="/posts/9398.html"/>
    <url>/posts/9398.html</url>
    
    <content type="html"><![CDATA[<p>题目链接： <a href="http://acm.hust.edu.cn/vjudge/contest/view.action?cid=66569#problem/O"> kuangbin带你飞 专题四 最短路练习 O - Extended Traffic</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="** 题意 **"></a>** 题意 **</h3><blockquote><p>给定每条街的拥挤度p(x)，街a到街b的时间就是(p(b)-p(a))**3，求第一个点到第k个点的最短路，若无法到达或结果小于3，输出’?’。</p></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="** 思路 **"></a>** 思路 **</h3><blockquote><p>显然，题目可能存在负环，则所有负环上的点全应该输出’?’ ，因为它们必定小于3，所以，spfa判断负环，并进行标记，即可解决</p></blockquote><h3 id="代码"><a href="#代码" class="headerlink" title="** 代码 **"></a>** 代码 **</h3><pre><code class="hljs">#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;stack&gt;#include&lt;queue&gt;using namespace std;const int N = 209;const int MAX = 0x3f3f3f3f;int dis[N];int p[N];int h[N];int cnt[N];bool vis[N];bool r[N];int c[N];struct Node&#123;    int u, v, w, next;&#125;e[N*N];void dfs(int x)&#123;    r[x] = 1;    for(int i=h[x]; i!=-1; i=e[i].next)        if(!r[e[i].v])            dfs(e[i].v);&#125;void spfa(int n, int Q)&#123;    memset(cnt, 0, sizeof(cnt));    memset(vis, 0, sizeof(vis));    memset(r, 0, sizeof(r));    memset(dis, 0x3f3f3f3f, sizeof(dis));    queue&lt;int&gt; q;    q.push(1);    dis[1] = 0;    while(!q.empty())    &#123;        int x = q.front();        vis[x] = 0;        q.pop();        for(int i=h[x]; i!=-1; i=e[i].next)        &#123;            int v = e[i].v;            if(r[v])                continue;            if(dis[v] &gt; dis[x] + e[i].w)            &#123;                dis[v] = dis[x] + e[i].w;                if(!vis[v])                &#123;                    vis[v] = 1;                    q.push(v);                    if(++cnt[v] &gt;= n)                        dfs(v);                &#125;            &#125;        &#125;    &#125;    for(int i=0; i&lt;Q; i++)    &#123;        int to = c[i];        if(dis[to]==MAX || r[to] || dis[to] &lt; 3)            printf(&quot;?\n&quot;);        else            printf(&quot;%d\n&quot;, dis[to]);    &#125;&#125;int main()&#123;    int T;    scanf(&quot;%d&quot;, &amp;T);    for(int tt=1; tt&lt;=T; tt++)    &#123;        int n, m;        scanf(&quot;%d&quot;, &amp;n);        for(int i=1; i&lt;=n; i++)            scanf(&quot;%d&quot;, &amp;p[i]);        scanf(&quot;%d&quot;, &amp;m);        memset(h, -1, sizeof(h));        for(int i=0; i&lt;m; i++)        &#123;            int a, b;            scanf(&quot;%d%d&quot;, &amp;a, &amp;b);            e[i].u = a;            e[i].v = b;            e[i].w = (p[b]-p[a])*(p[b]-p[a])*(p[b]-p[a]);            e[i].next = h[a];            h[a] = i;        &#125;        int Q;        scanf(&quot;%d&quot;, &amp;Q);        for(int i=0; i&lt;Q; i++)            scanf(&quot;%d&quot;, &amp;c[i]);        printf(&quot;Case %d:\n&quot;, tt);        spfa(n, Q);    &#125;    return 0;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>最短路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ 1847 N</title>
    <link href="/posts/4438.html"/>
    <url>/posts/4438.html</url>
    
    <content type="html"><![CDATA[<p>题目链接： <a href="http://acm.hust.edu.cn/vjudge/contest/view.action?cid=66569#problem/N"> kuangbin带你飞 专题四 最短路练习 N - Tram</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>电动巴士在每个十字路口有一个默认方向，走向别的方向需要改动扳手。<br>第一行给定十字路口的数量和起点终点<br>剩余n行给定与第i个十字路口相通的方向，第一个为默认方向</p></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><blockquote><p>典型模版题。直接dijkstra<br>ps：读题好费时间，英语是硬伤</p></blockquote><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="hljs">#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;stack&gt;#include&lt;queue&gt;using namespace std;const int N = 109;const int MAX = 0x3f3f3f3f;int dis[N];bool vis[N];vector&lt;vector&lt;pair&lt;int, bool&gt; &gt; &gt; map(N);int dijkstra(int n, int s, int e)&#123;    memset(vis, 0, sizeof(vis));    memset(dis, 0x3f3f3f3f, sizeof(dis));    dis[s] = 0;    for(int i=1; i&lt;=n; i++)    &#123;        int x = -1;        int max = MAX;        for(int j=1; j&lt;=n; j++)        &#123;            if(!vis[j] &amp;&amp; dis[j] &lt; max)                max = dis[x = j];        &#125;        if(x == -1)            break;        vis[x] = 1;        vector&lt;pair&lt;int, bool&gt; &gt;::iterator begin = map[x].begin();        while(begin != map[x].end())        &#123;            int y = (*begin).first;            int val = (*begin).second + max;            if(!vis[y] &amp;&amp; dis[y] &gt; val)                dis[y] = val;            ++begin;        &#125;    &#125;    if(dis[e] == MAX)        return -1;    return dis[e];&#125;int main()&#123;    int n,s,e;    scanf(&quot;%d%d%d&quot;, &amp;n, &amp;s, &amp;e);    for(int i=1; i&lt;=n; i++)    &#123;        int num, t;        scanf(&quot;%d&quot;, &amp;num);        scanf(&quot;%d&quot;, &amp;t);        pair&lt;int, bool&gt; p(t, 0);        map[i].push_back(p);        for(int j=1; j&lt;num; j++)        &#123;            scanf(&quot;%d&quot;, &amp;t);            pair&lt;int, bool&gt; p(t, 1);            map[i].push_back(p);        &#125;    &#125;    printf(&quot;%d\n&quot;, dijkstra(n, s, e));    return 0;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>最短路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ 2502 Subway</title>
    <link href="/posts/59309.html"/>
    <url>/posts/59309.html</url>
    
    <content type="html"><![CDATA[<p>题目链接： <a href="http://acm.hust.edu.cn/vjudge/contest/view.action?cid=66569#problem/L"> kuangbin带你飞 专题四 最短路练习 L - Subway</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>小明步行的速度是10km/h，地铁速度是40km/h，给定家和学校的坐标，再给定多条地铁线路站点的坐标，问小明从家到学校所需的最短时间</p></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><blockquote><p>典型的最短路，直接套用dijkstra就行，此题在读入数据上麻烦一点。<br>还有一个重要问题，导致我茫然wrong了好几次。<br>因为我是将每条地铁线路的站点读入后，便对这条线的站点两两之间按照40km来赋权值。但 **<br>忽略了一个问题，地铁线路不一定是直的，如果是弯的呢，那么这样求出来的权值就会比实际权值要小。所以只能对同一线路的两两相邻站点进行赋值，才符合逻辑。 **</p></blockquote><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="hljs">#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;stack&gt;#include&lt;queue&gt;using namespace std;const int N = 209;const int MAX = 0x3f3f3f3f;int dx[N], dy[N];double v[N][N];bool vis[N];double dis[N];double dijkstra(int n)&#123;    memset(vis, 0, sizeof(vis));    for(int i=1; i&lt;n; i++)        dis[i] = v[0][i];    dis[0] = 0;    vis[0] = 1;    for(int i=1; i&lt;n; i++)    &#123;        int x = -1;        double max = MAX;        for(int j=0; j&lt;n; j++)        &#123;            if(!vis[j] &amp;&amp; dis[j] &lt; max)                max = dis[x = j];        &#125;        if(x == -1)            break;        vis[x] = 1;        for(int j=0; j&lt;n; j++)            if(!vis[j] &amp;&amp; dis[j] &gt; max + v[x][j])                dis[j] = max + v[x][j];    &#125;    return dis[1];&#125;int main()&#123;    scanf(&quot;%d%d%d%d&quot;, &amp;dx[0], &amp;dy[0], &amp;dx[1], &amp;dy[1]);    int t, pos;    t = pos = 2;    for(int i=0; i&lt;N; i++)        for(int j=0; j&lt;N; j++)            v[i][j] = MAX;    while(~scanf(&quot;%d%d&quot;, &amp;dx[pos], &amp;dy[pos]))    &#123;        pos++;        while(~scanf(&quot;%d%d&quot;, &amp;dx[pos], &amp;dy[pos]) &amp;&amp; dx[pos] != -1 &amp;&amp; dy[pos] != -1)        &#123;            v[pos-1][pos] = v[pos][pos-1] =                60*sqrt((dx[pos]-dx[pos-1])*(dx[pos]-dx[pos-1])                +(dy[pos]-dy[pos-1])*(dy[pos]-dy[pos-1]))/40000.0;            pos++;        &#125;    &#125;    for(int i=0; i&lt;pos; i++)    &#123;        for(int j=i+1; j&lt;pos; j++)            v[i][j] = v[j][i] =                min(v[i][j],                    60*sqrt((dx[i]-dx[j])*(dx[i]-dx[j])                            +(dy[i]-dy[j])*(dy[i]-dy[j]))/10000.0);    &#125;    printf(&quot;%.0f\n&quot;, dijkstra(pos));    return 0;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>最短路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ 3159 Candies(dijkstra+heap&amp;spfa+stack)</title>
    <link href="/posts/29859.html"/>
    <url>/posts/29859.html</url>
    
    <content type="html"><![CDATA[<p>题目链接： <a href="http://acm.hust.edu.cn/vjudge/contest/view.action?cid=66569#problem/K"> kuangbin带你飞 专题四 最短路练习 K - Candies</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>给n个人分糖果，m组数据a，b，c；意思是a比b少的糖果个数绝对不超过c个，也就是d(b)-d(a) &lt; c，求1比n少的糖果数的最大值。</p></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><blockquote><p>也是通过这个题第一次接触到差分约束这个东西，学习了下，很奇妙。<br>令x-y&lt;=z表示x最大比y大z。<br>若b-a&lt;=k1, c-b&lt;=k2, c-a&lt;=k3，那么c-a最大为多少呢？显然应该等于min(k1+k2, k3)。可以用下图来表示示(不擅图丑勿怪)<br><img src="http://img.blog.csdn.net/20160118213610070"><br>这样的情况跟图论里的最短路极其相似，故此我们可以将其转换为对1到n的最短路求解的问题。<br>最短路，dijkstra，spfa都可<br>本人一开始用spfa+queue，直接超时，看别人题解都说是<br>spfa用队列维护数据会超时，用栈可以通过，果然，直接ac(这点我相当奇怪，关于栈与队列在实现spfa上的效率一直没有什么定论。为何在本体上相差这么多(一个<br>500ms，一个1500ms还不够)。好多人说是测试数据的问题)<br>总之虽然用spfa+stack过了，但不知缘由的ac令人相当不舒服，所以又用dijkstra写了一遍(需要heap优化，否则也会超时)</p></blockquote><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="dijkstra-heap"><a href="#dijkstra-heap" class="headerlink" title="dijkstra+heap"></a>dijkstra+heap</h4><pre><code class="hljs">#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;stack&gt;#include&lt;queue&gt;using namespace std;const int N = 150009;const int MAX = 0x3f3f3f3f;bool vis[N];int d[N];int ans[N] = &#123;&#125;;int head[N];struct Edge&#123;    int u, v, w, next;&#125;e[N];struct Node&#123;    int x, v;    Node(int a, int b): x(a), v(b) &#123;&#125;    bool operator &lt; (const Node &amp;t) const    &#123;        return this-&gt;v &gt; t.v;    &#125;&#125;;int dijkstra(int n)&#123;    memset(vis, 0, sizeof(vis));    memset(d, 0x3f3f3f3f, sizeof(d));    priority_queue&lt;Node, vector&lt;Node&gt; &gt; q;    for(int i=head[1]; i!=-1; i=e[i].next)        d[e[i].v] = e[i].w;    for(int i=2; i&lt;=n; i++)        q.push(Node(i,d[i]));    d[1] = 0;    vis[1] = 1;    for(int k=1; k&lt;n &amp;&amp; !q.empty(); k++)    &#123;        Node t = Node(0, 0);        do&#123;            t = q.top();q.pop();        &#125;while(vis[t.x] &amp;&amp; !q.empty());        int x = t.x;        if(x == -1)            break;        vis[x] = 1;        for(int i=head[x]; i!=-1; i=e[i].next)        &#123;            if(!vis[e[i].v] &amp;&amp; d[e[i].v] &gt; d[x] + e[i].w)            &#123;                d[e[i].v] = d[x] + e[i].w;                q.push(Node(e[i].v, d[e[i].v]));            &#125;        &#125;    &#125;    return d[n];&#125;int main()&#123;    int n, m;    while(~scanf(&quot;%d%d&quot;, &amp;n, &amp;m))    &#123;        memset(ans, 0, sizeof(ans));        memset(head, -1, sizeof(head));        for(int i=0; i&lt;m; i++)        &#123;            scanf(&quot;%d%d%d&quot;, &amp;e[i].u, &amp;e[i].v, &amp;e[i].w);            e[i].next = head[e[i].u];            head[e[i].u] = i;        &#125;        printf(&quot;%d\n&quot;, dijkstra(n));    &#125;    return 0;&#125;</code></pre><h4 id="spfa-stack"><a href="#spfa-stack" class="headerlink" title="spfa+stack"></a>spfa+stack</h4><pre><code class="hljs">#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;stack&gt;using namespace std;const int N = 150009;const int MAX = 0x3f3f3f3f;bool vis[N];int d[N];int ans[N] = &#123;&#125;;int head[N];struct Edge&#123;    int u, v, w, next;&#125;e[N];int spfa(int n)&#123;    memset(vis, 0, sizeof(vis));    for(int i=1; i&lt;=n; i++)        d[i] = MAX;    d[1] = 0;    vis[1] = 1;    stack&lt;int&gt; s;    s.push(1);    while(!s.empty())    &#123;        int x = s.top();        s.pop();        vis[x] = 0;        for(int i=head[x]; i!=-1; i=e[i].next)        &#123;            if(d[e[i].v] &gt; d[x] + e[i].w)            &#123;                d[e[i].v] = d[x] + e[i].w;                if(!vis[e[i].v])                &#123;                    s.push(e[i].v);                    vis[e[i].v] = 1;                &#125;            &#125;        &#125;    &#125;    return d[n];&#125;int main()&#123;    int n, m;    while(~scanf(&quot;%d%d&quot;, &amp;n, &amp;m))    &#123;        memset(ans, 0, sizeof(ans));        memset(head, -1, sizeof(head));        for(int i=0; i&lt;m; i++)        &#123;            scanf(&quot;%d%d%d&quot;, &amp;e[i].u, &amp;e[i].v, &amp;e[i].w);            e[i].next = head[e[i].u];            head[e[i].u] = i;        &#125;        printf(&quot;%d\n&quot;, spfa(n));    &#125;    return 0;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>最短路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ 1511 Invitation Cards(正反图两次SPFA&amp;邻接表)</title>
    <link href="/posts/41755.html"/>
    <url>/posts/41755.html</url>
    
    <content type="html"><![CDATA[<p>题目链接： <a href="http://acm.hust.edu.cn/vjudge/contest/view.action?cid=66569#problem/J"> kuangbin带你飞 专题四 最短路练习 J - Invitation Cards</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>求源点到各点的往返最短路之和</p></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><blockquote><p>本体思路没什么难度，分别用正反图求两次单源最短路即可，邻接表不好逆置，直接在最初构建两个图即可。<br>数据量相当大，timeout了两次，第一次是直接spfa，第二次用vector做邻接表仍然超时，第三次自己构建邻接表算是过了</p></blockquote><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="hljs">#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int N = 1000009;const int MAX = 0x3f3f3f3f;bool vis[N];long long d[N];long long ans[N] = &#123;&#125;;int head1[N], head2[N];struct Edge&#123;    int u, v, w, next;&#125;e1[N], e2[N];void spfa(int n, Edge e[], int head[])&#123;    memset(vis, 0, sizeof(vis));    for(int i=1; i&lt;=n; i++)        d[i] = MAX;    d[1] = 0;    vis[1] = 1;    queue&lt;int&gt; q;    q.push(1);    while(!q.empty())    &#123;        int x = q.front();        q.pop();        vis[x] = 0;        for(int i=head[x]; i!=-1; i=e[i].next)        &#123;            if(d[e[i].v] &gt; d[x] + e[i].w)            &#123;                d[e[i].v] = d[x] + e[i].w;                if(!vis[e[i].v])                &#123;                    q.push(e[i].v);                    vis[e[i].v] = 1;                &#125;            &#125;        &#125;    &#125;    for(int i=1; i&lt;=n; i++)        ans[i] += d[i];&#125;int main()&#123;    int T;    scanf(&quot;%d&quot;, &amp;T);    while(T--)    &#123;        int n, m;        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);        memset(ans, 0, sizeof(ans));        memset(head1, -1, sizeof(head1));        memset(head2, -1, sizeof(head2));        for(int i=0; i&lt;m; i++)        &#123;            scanf(&quot;%d%d%d&quot;, &amp;e1[i].u, &amp;e1[i].v, &amp;e1[i].w);            e1[i].next = head1[e1[i].u];            head1[e1[i].u] = i;            e2[i].u = e1[i].v;            e2[i].v = e1[i].u;            e2[i].w = e1[i].w;            e2[i].next = head2[e2[i].u];            head2[e2[i].u] = i;        &#125;        spfa(n, e1, head1);        spfa(n, e2, head2);        long long rel = 0;        for(int i=1; i&lt;=n; i++)            rel += ans[i];        printf(&quot;%lld\n&quot;, rel);    &#125;    return 0;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>最短路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ 2240 Arbitrage</title>
    <link href="/posts/15193.html"/>
    <url>/posts/15193.html</url>
    
    <content type="html"><![CDATA[<p>题目链接： <a href="http://acm.hust.edu.cn/vjudge/contest/view.action?cid=66569#problem/I"> kuangbin带你飞 专题四 最短路练习 I - Arbitrage</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>给定多种货币之间的兑换关系，问是否可以套利</p></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><blockquote><p>可以判断正环是否存在，或者直接floyd后判断有没有v[i][i] &gt; 1，有则说明可以套利<br>因为数据量很小，所以直接floyd<br>输入数据存在 a x a，即a和a之间的汇率(好坑啊，害我wrong那么多次)</p></blockquote><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="hljs">#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int N = 35;const int MAX = 0x3f3f3f3f;double v[N][N];char s[N][50];bool floyd(int n)&#123;    for(int i=0; i&lt;n; i++)        for(int j=0; j&lt;n; j++)            for(int k=0; k&lt;n; k++)                if(v[j][k] &lt; v[j][i]*v[i][k])                    v[j][k] = v[j][i]*v[i][k];    for(int i=0; i&lt;n; i++)        if(v[i][i] &gt; 1)            return true;    return false;&#125;int main()&#123;    int n, m, T = 1;    while(~scanf(&quot;%d&quot;, &amp;n) &amp;&amp; n)    &#123;        memset(v, 0, sizeof(v));        for(int i=0; i&lt;n; i++)        &#123;            scanf(&quot;%s&quot;, s[i]);            v[i][i] = 1;        &#125;        scanf(&quot;%d&quot;, &amp;m);        for(int i=0; i&lt;m; i++)        &#123;            char a[50], b[50];            int x, y;            double c;            scanf(&quot;%s%lf%s&quot;, a, &amp;c, b);            for(int j=0; j&lt;n; j++)            &#123;                if(strcmp(s[j], a) == 0)                    x = j;                if(strcmp(s[j], b) == 0)                    y = j;            &#125;            v[x][y] = c;        &#125;        printf(&quot;Case %d: &quot;, T++);        if(floyd(n))            printf(&quot;Yes\n&quot;);        else            printf(&quot;No\n&quot;);    &#125;    return 0;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>最短路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ 3660 Cow Contest(Floyd)</title>
    <link href="/posts/36672.html"/>
    <url>/posts/36672.html</url>
    
    <content type="html"><![CDATA[<p>题目链接： <a href="http://acm.hust.edu.cn/vjudge/contest/view.action?cid=66569#problem/H"> kuangbin带你飞 专题四 最短路练习 H - Cow Contest</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>n个牛进行比赛，现已知m个关系， 牛u可以胜过牛v。<br>问最后可以确定排名位数的有几个牛</p></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><blockquote><p>Floyd获得两两牛之间的关系，如果一个牛可以胜过a个牛，b个牛可以胜过它，那么如果a＋b＝n－1，他的排名就可以确定</p></blockquote><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="hljs">#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int N = 109;const int MAX = 0x3f3f3f3f;bool v[N][N];int main()&#123;    int n, m;    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);    memset(v, 0, sizeof(v));    for(int i=1; i&lt;=m; i++)    &#123;        int a, b;        scanf(&quot;%d%d&quot;, &amp;a, &amp;b);        v[a][b] = 1;    &#125;    for(int i=1; i&lt;=n; i++)        for(int j=1; j&lt;=n; j++)            for(int k=1; k&lt;=n; k++)                v[k][j] |= v[k][i] &amp; v[i][j];    int ans = 0;    for(int i=1; i&lt;=n; i++)    &#123;        int cnt = 0;        for(int j=1; j&lt;=n; j++)        &#123;            if(v[j][i])                cnt++;            if(v[i][j])                cnt++;        &#125;        if(cnt == n-1)            ans++;    &#125;    printf(&quot;%d\n&quot;, ans);    return 0;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>最短路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ 1502 MPI Maelstrom(单源最短路)</title>
    <link href="/posts/28422.html"/>
    <url>/posts/28422.html</url>
    
    <content type="html"><![CDATA[<p>题目链接： <a href="http://acm.hust.edu.cn/vjudge/contest/view.action?cid=66569#problem/G"> kuangbin带你飞 专题四 最短路练习 G - MPI Maelstrom</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>n个处理器，第一个处理器要广播消息到其他所有的处理器，求需要时间最短是多少（从第一个点出发，求到其他点最短路的最大值）</p></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><blockquote><p>没什么可说的，单源最短路，dijkstra。</p></blockquote><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="hljs">#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int N = 509;const int MAX = 0x3f3f3f3f;int d[N];bool vis[N];int v[N][N];int dijkstra(int n)&#123;    memset(vis, 0, sizeof(vis));    for(int i=1; i&lt;=n; i++)        d[i] = v[1][i];    d[1] = 0;    vis[1] = 1;    for(int i=1; i&lt;n; i++)    &#123;        int x = -1, mmin = MAX;        for(int j=1; j&lt;=n; j++)            if(!vis[j] &amp;&amp; d[j] &lt; mmin)                mmin = d[x = j];        if(x == -1)            break;        vis[x] = 1;        for(int j=1; j&lt;=n; j++)        &#123;            if(!vis[j])                d[j] = min(d[j], d[x] + v[x][j]);        &#125;    &#125;    int mmax = 0;    for(int j=1; j&lt;=n; j++)        mmax = max(mmax, d[j]);    return mmax;&#125;int main()&#123;    int n;    scanf(&quot;%d&quot;, &amp;n);    memset(v, 0x3f3f3f3f, sizeof(v));    for(int i=2; i&lt;=n; i++)    &#123;        for(int j=1; j&lt;i; j++)        &#123;            char t[20];            scanf(&quot;%s&quot;, t);            if(t[0] != &#39;x&#39;)            &#123;                int k = 0;                int x = 0;                while(t[k] != &#39;\0&#39;)                    x = x*10 + t[k++]-&#39;0&#39;;                v[i][j] = v[j][i] = x;            &#125;        &#125;    &#125;    printf(&quot;%d\n&quot;, dijkstra(n));    return 0;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>最短路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ 3259 Wormholes(判断负环&amp;(Bellman-Ford|SPFA))</title>
    <link href="/posts/10575.html"/>
    <url>/posts/10575.html</url>
    
    <content type="html"><![CDATA[<p>题目链接： <a href="http://acm.hust.edu.cn/vjudge/contest/view.action?cid=66569#problem/F"> kuangbin带你飞 专题四 最短路练习 F - Wormholes</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>农场主拥有很多农场，在这些农场之间有很多条路，以及单向的虫洞，每条路走完会花费一定的时间，而冲动可以回到之前的时间，问农场主是否可以通过特定的路径看到出<br>发前的自己？(也就是回到自己出发时间前的出发点)</p></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><blockquote><p>将农场看做点，路和虫洞看做边，那么显然虫洞是负权边，这样题目就转化为求给定图中是否有负环的问题了。<br>Bellman-Ford和SPFA都可以进行负环的判断，因为这两个算法以前都没用过，索性就都写了一下，慢慢熟练。<br>SPFA是对Bellman-Ford进行队列优化的改进版，但提交后反而比Bellman-Ford慢，这点挺奇怪的。<br>不知道是数据的原因，还是什么？</p></blockquote><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="Bellman-Ford"><a href="#Bellman-Ford" class="headerlink" title="Bellman-Ford"></a>Bellman-Ford</h4><pre><code class="hljs">#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int N = 509;const int MAX = 0x3f3f3f3f;struct Edge&#123;    int u, v, r;&#125;edge[N*N+200];int d[N];bool Bellman_Ford(int n, int e, int src)&#123;    for(int i=1; i&lt;=n; i++)        d[i] = MAX;    d[src] = 0;    while(d[src] &gt;= 0)    &#123;        bool flag = true;        for(int i=0; i&lt;e; i++)        &#123;            int u = edge[i].u;            int v = edge[i].v;            int to = d[u] + edge[i].r;            if(d[v] &gt; to)            &#123;                d[v] = to;                flag = false;            &#125;        &#125;        if(flag)            return d[src] &lt; 0;    &#125;    return 1;&#125;int main()&#123;    int T;    scanf(&quot;%d&quot;, &amp;T);    while(T--)    &#123;        int n, m, w;        scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;w);        for(int i=0; i&lt;m; i++)        &#123;            int a, b, c;            scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);            edge[i].u = a;            edge[i].v = b;            edge[i].r = c;            edge[i+m].u = b;            edge[i+m].v = a;            edge[i+m].r = c;        &#125;        for(int i=0; i&lt;w; i++)        &#123;            int a, b, c;            scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);            edge[2*m+i].u = a;            edge[2*m+i].v = b;            edge[2*m+i].r = -c;        &#125;        if(Bellman_Ford(n, m*2+w, 1))            printf(&quot;YES\n&quot;);        else            printf(&quot;NO\n&quot;);    &#125;    return 0;&#125;</code></pre><h4 id="SPFA"><a href="#SPFA" class="headerlink" title="SPFA"></a>SPFA</h4><pre><code class="hljs">#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int N = 509;const int MAX = 0x3f3f3f3f;struct Edge&#123;    int u, v, r, next;&#125;edge[N*N+200];int d[N];int h[N];bool vis[N];int cnt[N];bool spfa(int n)&#123;    memset(vis, 0, sizeof(vis));    memset(cnt, 0, sizeof(cnt));    for(int i=1; i&lt;=n; i++)        d[i] = MAX;    d[1] = 0;    vis[1] = 1;    cnt[1]++;    queue&lt;int&gt; q;    q.push(1);    while(!q.empty())    &#123;        int x = q.front();        vis[x] = 0;        q.pop();        for(int i = h[x]; i!=-1; i = edge[i].next)        &#123;            int v = edge[i].v;            int to = edge[i].r + d[edge[i].u];            if(d[v] &gt; to)            &#123;                d[v] = to;                if(!vis[v])                &#123;                    vis[v] = 1;                    q.push(v);                    if(++cnt[v] &gt; n)                        return 1;                &#125;            &#125;        &#125;    &#125;    return 0;&#125;int main()&#123;    int T;    scanf(&quot;%d&quot;, &amp;T);    while(T--)    &#123;        int n, m, w;        memset(h, -1, sizeof(h));        scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;w);        for(int i=0; i&lt;m; i++)        &#123;            int a, b, c;            scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);            edge[i].next = h[a];            edge[i].u = a;            edge[i].v = b;            edge[i].r = c;            h[a] = i;            edge[i+m].next = h[b];            edge[i+m].u = b;            edge[i+m].v = a;            edge[i+m].r = c;            h[b] = i+m;        &#125;        for(int i=0; i&lt;w; i++)        &#123;            int a, b, c;            scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);            edge[2*m+i].next = h[a];            edge[2*m+i].u = a;            edge[2*m+i].v = b;            edge[2*m+i].r = -c;            h[a] = 2*m+i;        &#125;        if(spfa(n))            printf(&quot;YES\n&quot;);        else            printf(&quot;NO\n&quot;);    &#125;    return 0;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>最短路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ 1860 Currency Exchange(Bellman-Ford判断最长路是否含有正环)</title>
    <link href="/posts/57969.html"/>
    <url>/posts/57969.html</url>
    
    <content type="html"><![CDATA[<p>题目链接： <a href="http://acm.hust.edu.cn/vjudge/contest/view.action?cid=66569#problem/E"> kuangbin带你飞 专题四 最短路练习 E - Currency Exchange</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>有n种货币，你含有num面额的其中一种货币。<br>给定m种交易明细，即货币a和b之间的手续费与兑换率。双向兑换时，手续费与兑换率不一定相同。<br>求有没有可能，在多次兑换后你手中的货币大于num。</p></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><blockquote><p>以货币为点，交易情况为边，本题可转换为求最长路是否含正环的问题。<br>用Bellman-Ford，但要有所修改，原本松弛次数为n－1次，但本题可能有这种情况，给定图有正环，但需要多次迭代后才能大于初始金额，所以将松弛次数改为只<br>要边权有更新，则一直松弛下去。直到大于初始金额。</p></blockquote><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="hljs">#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int N = 109;const int MAX = 0x3f3f3f3f;struct Edge&#123;    int u, v;    double r, c;&#125;edge[N*2];double d[N];bool Bellman_Ford(int n, int e, int src, double num)&#123;    for(int i=1; i&lt;=n; i++)        d[i] = 0;    d[src] = num;    while(d[src] &lt; num + 1e-9)    &#123;        bool flag = true;        for(int i=0; i&lt;e; i++)        &#123;            int u = edge[i].u;            int v = edge[i].v;            double to = (d[u]-edge[i].c)*edge[i].r;            if(d[v] + 1e-9 &lt; to)            &#123;                d[v] = to;                flag = false;            &#125;        &#125;        if(flag)            return d[src] &gt; num;    &#125;    return 1;&#125;int main()&#123;    int n, m, src;    double num;    scanf(&quot;%d%d%d%lf&quot;, &amp;n, &amp;m, &amp;src, &amp;num);    for(int i=0; i&lt;m; i++)    &#123;        int a, b;        double rab, cab, rba, cba;        scanf(&quot;%d%d%lf%lf%lf%lf&quot;, &amp;a, &amp;b, &amp;rab, &amp;cab, &amp;rba, &amp;cba);        edge[i].u = a; edge[i].v = b;        edge[i].r = rab; edge[i].c = cab;        edge[i+m].u = b; edge[i+m].v = a;        edge[i+m].r = rba; edge[i+m].c = cba;    &#125;    if(Bellman_Ford(n, m*2, src, num))        printf(&quot;YES\n&quot;);    else        printf(&quot;NO\n&quot;);    return 0;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>最短路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ 3268 D</title>
    <link href="/posts/20093.html"/>
    <url>/posts/20093.html</url>
    
    <content type="html"><![CDATA[<p>题目链接： <a href="http://acm.hust.edu.cn/vjudge/contest/view.action?cid=66569#problem/D"> kuangbin带你飞 专题四 最短路练习 D - Silver Cow Party</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>n个农场，m条单向路，n个牛分别在n个农场，第x农场为终点，问每个牛从所在农场前往x农场的往返路程最小值是多少，求出n个牛中往返路程最小值最大是多少？</p></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><blockquote><p>一看到这种求多个点最短路的问题，第一想到floyd，<br>但1000^3，10亿，TimeLimit的可能性相当大，写完一交，果不然。<br>重新思考发现，所有牛的去途终点都为x，返途的起点也都为x，那么我们只用针对x进行求最短路就好了，所有牛返途的最短路程用一次以x为起点的dijkstra就可以<br>求出。<br>但是去途呢？我们可以将邻接矩阵逆置，也就是单向路转向，这样再以x为起点用一次dijkstra就可以求出所有牛的最短去途。</p></blockquote><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="floyd求解-会超时，既然写了就一并贴上吧"><a href="#floyd求解-会超时，既然写了就一并贴上吧" class="headerlink" title="floyd求解(会超时，既然写了就一并贴上吧)"></a>floyd求解(会超时，既然写了就一并贴上吧)</h4><pre><code class="hljs">#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int N = 1009;const int MAX = 0x3f3f3f3f;int v[N][N];int main()&#123;    int n, m, to;    scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;to);    memset(v, 0x3f3f3f3f, sizeof(v));    for(int i=0; i&lt;m; i++)    &#123;        int a, b, c;        scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);        v[a][b] = c;    &#125;    for(int i=1;i&lt;=n;i++)    &#123;        for(int j=1; j&lt;=n; j++)        &#123;            for(int k=1; k&lt;=n;k++)            &#123;                if(v[i][j] &gt; v[i][k] + v[k][j])                    v[i][j] = v[i][k] + v[k][j];            &#125;        &#125;    &#125;    int ans = 0;    for(int i=1;i&lt;=n;i++)    &#123;        ans = max(ans, v[i][to] + v[to][i]);    &#125;    printf(&quot;%d\n&quot;, ans);    return 0;&#125;</code></pre><h4 id="两次dijkstra求解"><a href="#两次dijkstra求解" class="headerlink" title="两次dijkstra求解"></a>两次dijkstra求解</h4><pre><code class="hljs">#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int N = 1009;const int MAX = 0x3f3f3f3f;int v[N][N];bool vis[N];int d[N];int ans[N] = &#123;&#125;;void dijkstra(int n, int to)&#123;    memset(vis, 0, sizeof(vis));    for(int i=1; i&lt;=n; i++)        d[i] = v[to][i];    d[to] = 0;    vis[to] = 1;    for(int i=1; i&lt;n; i++)    &#123;        int x = -1, max = MAX;        for(int j=1; j&lt;=n; j++)        &#123;            if(!vis[j] &amp;&amp; d[j] &lt; max)                max = d[x = j];        &#125;        if(x == -1)            break;        vis[x] = 1;        for(int j=1; j&lt;=n; j++)        &#123;            if(!vis[j] &amp;&amp; d[j] &gt; d[x]+v[x][j])                d[j] = d[x] + v[x][j];        &#125;    &#125;    for(int i=1; i&lt;=n; i++)        ans[i] += d[i];&#125;int main()&#123;    int n, m, to;    scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;to);    memset(v, 0x3f3f3f3f, sizeof(v));    for(int i=0; i&lt;m; i++)    &#123;        int a, b, c;        scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);        v[a][b] = c;    &#125;    dijkstra(n, to);    for(int i=1; i&lt;=n; i++)        for(int j=i+1; j&lt;=n; j++)            swap(v[i][j], v[j][i]);    dijkstra(n, to);    int rel = 0;    for(int i=1; i&lt;=n; i++)        rel = max(rel, ans[i]);    printf(&quot;%d\n&quot;, rel);    return 0;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>最短路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ 1797 Heavy Transportation</title>
    <link href="/posts/10553.html"/>
    <url>/posts/10553.html</url>
    
    <content type="html"><![CDATA[<p>题目链接： <a href="http://acm.hust.edu.cn/vjudge/contest/view.action?cid=66569#problem/B"> kuangbin带你飞 专题四 最短路练习 C - Heavy Transportation</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>有n个城市，n个城市之间有m条公路或桥梁，每个公路或桥都有一个最大载重量，问从城市1到城市n所能运送到货物到最大重量是多少</p></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><blockquote><p>显然1到n的最大承重量为所有公路的承重量的最小值<br>那么本题就是要求1到n的所有可能路径中最大承重量最大的一条路，即所经过所有公路的载重量最小值 最大的一条路。<br>对dijkstra进行修改，令d[i]表示1到i的所有可能路径中载重量最小值最大的一条路的最小值，最终的解就是d[n];</p></blockquote><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="hljs">#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int N = 1009;const int MAX = 0x3f3f3f3f;int v[N][N];bool vis[N];int d[N];int dijkstra(int n)&#123;    memset(vis, 0, sizeof(vis));    for(int i=1; i&lt;=n; i++)        d[i] = v[1][i];    vis[1] = 1;    for(int i=1; i&lt;n; i++)    &#123;        int x = -1, max = 0;        for(int j=1; j&lt;=n; j++)        &#123;            if(!vis[j] &amp;&amp; d[j] &gt; max)                max = d[x = j];        &#125;        if(x == -1)            break;        vis[x] = 1;        for(int j=1; j&lt;=n; j++)        &#123;            if(!vis[j])            &#123;                int mmin = min(max, v[j][x]);                if(mmin &gt; d[j])                &#123;                    d[j] = mmin;                &#125;            &#125;        &#125;    &#125;    return d[n];&#125;int main()&#123;    int T;    cin&gt;&gt;T;    for(int C=1; C&lt;=T; C++)    &#123;        int n, m;        cin&gt;&gt;n&gt;&gt;m;        memset(v, 0, sizeof(v));        for(int i=0; i&lt;m; i++)        &#123;            int a, b, c;            scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);            v[a][b] = v[b][a] = c;        &#125;        cout&lt;&lt;&quot;Scenario #&quot;&lt;&lt;C;        cout&lt;&lt;&quot;:&quot;&lt;&lt;endl;        cout&lt;&lt;dijkstra(n)&lt;&lt;endl&lt;&lt;endl;    &#125;    return 0;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>最短路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ 1062 昂贵的聘礼</title>
    <link href="/posts/17067.html"/>
    <url>/posts/17067.html</url>
    
    <content type="html"><![CDATA[<p>题目链接： <a href="http://acm.hust.edu.cn/vjudge/contest/view.action?cid=66569#problem/M"> [kuangbin带你飞]专题四 最短路练习 M - 昂贵的聘礼</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>年轻的探险家来到了一个印第安部落里。在那里他和酋长的女儿相爱了，于是便向酋长去求亲。酋长要他用10000个金币作为聘礼才答应把女儿嫁给他。探险家拿不出这<br>么多金币，便请求酋长降低要求。酋长说：”嗯，如果你能够替我弄到大祭司的皮袄，我可以只要8000金币。如果你能够弄来他的水晶球，那么只要5000金币就行了。”<br>探险家就跑到大祭司那里，向他要求皮袄或水晶球，大祭司要他用金币来换，或者替他弄来其他的东西，他可以降低价格。探险家于是又跑到其他地方，其他人也提出了类似的要<br>求，或者直接用金币换，或者找到其他东西就可以降低价格。不过探险家没必要用多样东西去换一样东西，因为不会得到更低的价格。探险家现在很需要你的帮忙，让他用最少的<br>金币娶到自己的心上人。另外他要告诉你的是，在这个部落里，等级观念十分森严。地位差距超过一定限制的两个人之间不会进行任何形式的直接接触，包括交易。他是一个外来<br>人，所以可以不受这些限制。但是如果他和某个地位较低的人进行了交易，地位较高的的人不会再和他交易，他们认为这样等于是间接接触，反过来也一样。因此你需要在考虑所<br>有的情况以后给他提供一个最好的方案。<br>为了方便起见，我们把所有的物品从1开始进行编号，酋长的允诺也看作一个物品，并且编号总是1。每个物品都有对应的价格P，主人的地位等级L，以及一系列的替代品Ti<br>和该替代品所对应的”优惠”Vi。如果两人地位等级差距超过了M，就不能”间接交易”。你必须根据这些数据来计算出探险家最少需要多少金币才能娶到酋长的女儿。</p></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><blockquote><p>将两两物品之间的交易详情看做边，每个物品看做点，可用最短路求解，但是题目里等级的设置让问题变得麻烦了些。<br>题目关键的地方是：不仅是交易的双方等级不能差距M，而是所有有过交易的物品两两之间等级都不能差距M。<br>因为最终都要交换到第一件物品，也就是酋长的承诺，所以由酋长的等级，和M可以产生一个等级区间，等级在此区间内的物品才可以交换。所以对等级区间进行枚举，求最短路<br>便可解决此问题。</p></blockquote><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="hljs">#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int N = 209;int v[N][N] = &#123;&#125;;int d[N];bool vis[N] = &#123;&#125;;int p[N], l[N], q[N];bool f[N] = &#123;&#125;;int dijkstra(int n)&#123;    memset(vis, 0, sizeof(vis));    for(int i=1;i&lt;=n;i++)    &#123;        d[i] = v[0][i];    &#125;    d[0] = 0;    vis[0] = 1;    for(int i=1; i&lt;=n; i++)    &#123;        int x = 0, mmin = 0x3f3f3f3f;        for(int i=1;i&lt;=n;i++)        &#123;            if(!vis[i] &amp;&amp; f[i] &amp;&amp; mmin &gt; d[i])                mmin = d[x = i];        &#125;        vis[x] = 1;        for(int i=1;i&lt;=n;i++)        &#123;            if(!vis[i] &amp;&amp; f[i] &amp;&amp; d[i] &gt; d[x] + v[x][i])            &#123;                d[i] = d[x] + v[x][i];            &#125;        &#125;    &#125;    return d[1];&#125;int main()&#123;    int n, m;    cin&gt;&gt;m&gt;&gt;n;    memset(v, 0x3f3f3f3f, sizeof(v));    for(int i=1;i&lt;=n;i++)    &#123;        int t;        cin&gt;&gt;p[i]&gt;&gt;l[i]&gt;&gt;t;        v[0][i] = p[i];        for(int j=0;j&lt;t;j++)        &#123;            int a, b;            cin&gt;&gt;a&gt;&gt;b;            v[a][i] = b;        &#125;    &#125;    int ans = 0x3f3f3f3f;    for(int i=0; i&lt;=m; i++)    &#123;        memset(f, 0, sizeof(f));        for(int j=1; j&lt;=n; j++)        &#123;            if(l[j] &gt;= l[1]-m+i &amp;&amp; l[j] &lt;= l[1]+i)                f[j] = 1;        &#125;        ans = min(ans, dijkstra(n));    &#125;    cout&lt;&lt;ans&lt;&lt;endl;    return 0;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>最短路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ 2253 Frogger</title>
    <link href="/posts/6885.html"/>
    <url>/posts/6885.html</url>
    
    <content type="html"><![CDATA[<p>题目链接： <a href="http://acm.hust.edu.cn/vjudge/contest/view.action?cid=66569#problem/B"> [kuangbin带你飞]专题四 最短路练习 B - Frogger</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>给定n个点，点1为起点，点2为终点，求点一到点二的所有路径中，求在所有路径中每条路径最大段的最小值</p></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><blockquote><p>用dijkstra，d[i]表示1到i的路径中最大路段的最小值</p></blockquote><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="hljs">#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdio&gt;using namespace std;const int N = 209;double v[N][N] = &#123;&#125;;double d[N];bool vis[N] = &#123;&#125;;int x[N], y[N];double dijkstra(int n)&#123;    for(int i=1;i&lt;=n;i++)        d[i] = v[i][1];    d[1] = 0;    memset(vis, 0, sizeof(vis));    vis[1] = true;    for(int i=1;i&lt;n;i++)    &#123;        int mini = 0;        double min = 99999999;        for(int j=1;j&lt;=n;j++)        &#123;            if(!vis[j] &amp;&amp; d[j] &lt; min)            &#123;                mini = j; min = d[j];            &#125;        &#125;        vis[mini] = true;        for(int j=1;j&lt;=n;j++)        &#123;            if(!vis[j])            &#123;                double mmax = max(min, v[j][mini]);                if(mmax &lt; d[j])                    d[j] = mmax;            &#125;        &#125;    &#125;    return d[2];&#125;int main()&#123;    int n, T = 1;    while(cin&gt;&gt;n &amp;&amp; n)    &#123;        if(T != 1)            cout&lt;&lt;endl;        for(int i=1;i&lt;=n;i++)        &#123;            cin&gt;&gt;x[i]&gt;&gt;y[i];        &#125;        for(int i=1;i&lt;=n;i++)        &#123;            for(int j=i+1;j&lt;=n;j++)                v[i][j] = v[j][i] = sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]));        &#125;        cout&lt;&lt;&quot;Scenario #&quot;&lt;&lt;T++&lt;&lt;endl;        cout&lt;&lt;&quot;Frog Distance = &quot;;        printf(&quot;%.3f\n&quot;, dijkstra(n));    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>最短路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Alpha-Beta搜索</title>
    <link href="/posts/41571.html"/>
    <url>/posts/41571.html</url>
    
    <content type="html"><![CDATA[<p>《对弈程序基本技术》专题</p><p>** Alpha-Beta ** 搜索</p><p>Bruce Moreland /  文</p><p>** 最小 ** ** - ** ** 最大的问题 **<br>Alpha-Beta  同“ <a href="http://blog.csdn.net/to_be_better/article/details/50464280"> 最小  -  最大</a> ”非常相似，事实上只多了一条额外<br>的语句。最小最大运行时要检查整个博弈树，然后尽可能选择最好的线路。这是非常好理解的，但效率非常低。每次搜索更深一层时，树的大小就呈指数式增长。</p><p>通常一个国际象棋局面都有  35  个左右的合理着法，所以用最小  -  最大搜索来搜索一层深度，就有  35<br>个局面要检查，如果用这个函数来搜索两层，就有  35  2<br>个局面要搜索。这就已经上千了，看上去还不怎样，但是数字增长得非常迅速，例如六层的搜索就接近是二十亿，而十层的搜索就超过两千万亿了。</p><p>要想通过检查搜索树的前面几层，并且在叶子结点上用启发式的评价，那么做尽可能深的搜索是很重要的。最小  -<br>最大搜索无法做到很深的搜索，因为有效的分枝因子实在太大了。</p><p>** 口袋的例子 **<br>幸运的是我们有办法来减小分枝因子，这个办法非常可靠，实际上这样做绝对没有坏处，纯粹是个有益的办法。这个方法是建立在一个思想上的，如果你已经有一个不太坏的选择<br>了，那么当你要作别的选择并知道它不会更好时，你没有必要确切地知道它有多坏。有了最好的选择，任何不比它更好的选择就是足够坏的，因此你可以撇开它而不需要完全了解<br>它。只要你能证明它不比最好的选择更好，你就可以完全抛弃它。</p><p>你可能仍旧不明白，那么我就举个例子。比如你的死敌面前有很多口袋，他和你打赌赌输了，因此他必须从中给你一样东西，而挑选规则却非常奇怪：</p><p>每个口袋里有几件物品，你能取其中的一件，你来挑这件物品所在的口袋，而他来挑这个口袋里的物品。你要赶紧挑出口袋并离开，因为你不愿意一直做在那里翻口袋而让你的死<br>敌盯着你。</p><p>假设你一次只能找一只口袋，在找口袋时一次只能从里面摸出一样东西。</p><p>很显然，当你挑出口袋时，你的死敌会把口袋里最糟糕的物品给你，因此你的目标是挑出“诸多最糟的物品当中是最好的”那个口袋。</p><p>你很容易把最小  -<br>最大原理运用到这个问题上。你是最大一方棋手，你将挑出最好的口袋。而你的死敌是最小一方棋手，他将挑出最好的口袋里尽可能差的物品。运用最小  -<br>最大原理，你需要做的就是挑一个有“最好的最差的”物品的口袋。</p><p>假设你可以估计口袋里每个物品的准确价值的话，最小  -  最大原理可以让你作出正确的选择。我们讨论的话题中，准确评价并不重要，因为它同最小  -<br>最大或  Alpha-Beta  的工作原理没有关系。现在我们假设你可以正确地评价物品。</p><p>最小  -  最大原理刚才讨论过，它的问题是效率太低。你必须看每个口袋里的每件物品，这就需要花很多时间。</p><p>那么怎样才能做得比最小  -  最大更高效呢？</p><p>我们从第一个口袋开始，看每一件物品，并对口袋作出评价。比方说口袋里有一只花生黄油三明治和一辆新汽车的钥匙。你知道三明治更糟，因此如果你挑了这只口袋就会得到三<br>明治。事实上只要我们假设对手也会跟我们一样正确评价物品，那么口袋里的汽车钥匙就是无关紧要的了。</p><p>现在你开始翻第二个口袋，这次你采取的方案就和最小  -  最大方案不同了。你每次看一件物品，并跟你能得到的最好的那件物品  (  三明治  )<br>去比较。只要物品比三明治更好，那么你就按照最小  -<br>最大方案来办——去找最糟的，或许最糟的要比三明治更好，那么你就可以挑这个口袋，它比装有三明治的那个口袋好。</p><p>比方这个口袋里的第一件物品是一张  20<br>美元的钞票，它比三明治好。如果包里其他东西都没比这个更糟了，那么如果你选了这个口袋，它就是对手必须给你的物品，这个口袋就成了你的选择。</p><p>这个口袋里的下一件物品是六合装的流行唱片。你认为它比三明治好，但比  20<br>美元差，那么这个口袋仍旧可以选择。再下一件物品是一条烂鱼，这回比三明治差了。于是你就说“不谢了”，把口袋放回去，不再考虑它了。</p><p>无论口袋里还有什么东西，或许还有另一辆汽车的钥匙，也没有用了，因为你会得到那条烂鱼。或许还有比烂鱼更糟的东西  (  那么你看着办吧  )<br>。无论如何烂鱼已经够糟的了，而你知道挑那个有三明治的口袋肯定会更好。</p><p>** 算法 **<br>Alpha-Beta  就是这么工作的，并且只能用递归来实现。稍后我们再来谈最小一方的策略，我希望这样可以更明白些。</p><p>这个思想是在搜索中传递两个值，第一个值是  Alpha  ，即搜索到的最好值，任何比它更小的值就没用了，因为策略就是知道  Alpha<br>的值，任何小于或等于  Alpha  的值都不会有所提高。</p><p>第二个值是  Beta  ，即对于对手来说最坏的值。这是对手所能承受的最坏的结果，因为我们知道在对手看来，他总是会找到一个对策不比  Beta<br>更坏的。如果搜索过程中返回  Beta  或比  Beta  更好的值，那就够好的了，走棋的一方就没有机会使用这种策略了。</p><p>在搜索着法时，每个搜索过的着法都返回跟  Alpha  和  Beta  有关的值，它们之间的关系非常重要，或许意味着搜索可以停止并返回。</p><p>如果某个着法的结果小于或等于  Alpha  ，那么它就是很差的着法，因此可以抛弃。因为我前面说过，在这个策略中，局面对走棋的一方来说是以  Alpha<br>为评价的。</p><p>如果某个着法的结果大于或等于  Beta<br>，那么整个结点就作废了，因为对手不希望走到这个局面，而它有别的着法可以避免到达这个局面。因此如果我们找到的评价大于或等于  Beta<br>，就证明了这个结点是不会发生的，因此剩下的合理着法没有必要再搜索。</p><p>如果某个着法的结果大于  Alpha  但小于  Beta  ，那么这个着法就是走棋一方可以考虑走的，除非以后有所变化。因此  Alpha<br>会不断增加以反映新的情况。有时候可能一个合理着法也不超过  Alpha<br>，这在实战中是经常发生的，此时这种局面是不予考虑的，因此为了避免这样的局面，我们必须在博弈树的上一个层局面选择另外一个着法。</p><p>在第二个口袋里找到烂鱼就相当于超过了  Beta  ，如果口袋里没有烂鱼，那么考虑六盒装流行唱片的口袋会比三明治的口袋好，这就相当于超过了  Alpha(<br>在上一层  )  。算法如下，醒目的部分是在最小  -  最大算法上改过的：</p><pre><code class="hljs"> int  AlphaBeta  (int depth  , int alpha, int beta  ) &#123; if (depth == 0) &#123; return Evaluate(); &#125; GenerateLegalMoves(); while (MovesLeft()) &#123; MakeNextMove(); val = -  AlphaBeta  (depth - 1  , -beta, -alpha  ); UnmakeMove(); if (val &gt;= beta) &#123; return beta; &#125; if (val &gt; alpha) &#123; alpha = val; &#125; &#125; return alpha; &#125;</code></pre><p>把醒目的部分去掉，剩下的就是最小-最大函数。可以看出现在的算法没有太多的改变。</p><p>这个函数需要传递的参数有：需要搜索的深度，负无穷大即  Alpha  ，以及正无穷大即  Beta  ：</p><pre><code class="hljs"> val = AlphaBeta(5, -INFINITY, INFINITY);</code></pre><p>这样就完成了  5  层的搜索。我在写最小  -  最大函数时，用了一个诀窍来避免用了“  Min  ”还用“  Max<br>”函数。在那个算法中，我从递归中返回时简单地对返回值取了负数。这样就使函数值在每一次递归中改变评价的角度，以反映双方棋手的交替着子，并且它们的目标是对立的。</p><p>在  Alpha-Beta  函数中我们做了同样的处理。唯一使算法感到复杂的是，  Alpha  和  Beta  是不断互换的。当函数递归时，<br>Alpha  和  Beta  不但取负数而且位置交换了，这就使得情况比口袋的例子复杂，但是可以证明它只是比最小  -  最大算法更好而已。</p><p>最终出现的情况是，在搜索树的很多地方，  Beta  是很容易超过的，因此很多工作都免去了。</p><p>可能的弱点</p><p>这个算法严重依赖于着法的寻找顺序。如果你总是先去搜索最坏的着法，那么  Beta  截断就不会发生，因此该算法就如同最小  -<br>最大一样，效率非常低。该算法最终会找遍整个博弈树，就像最小  -  最大算法一样。</p><p>如果程序总是能挑最好的着法来首先搜索，那么数学上有效分枝因子就接近于实际分枝因子的平方根。这是  Alpha-Beta  算法可能达到的最好的情况。</p><p>由于国际象棋的分枝因子在  35  左右，这就意味着  Alpha-Beta  算法能使国际象棋搜索树的分枝因子变成  6  。</p><p>这是很大的改进，在搜索结点数一样的情况下，可以使你的搜索深度达到原来的两倍。这就是为什么使用  Alpha-Beta  搜索时，着法顺序至关重要的原因。</p><p>原文： <a href="http://www.seanet.com/~brucemo/topics/alphabeta.htm"> http://www.seanet.com/~brucemo/topics/alphabeta.htm</a></p><p>译者：象棋百科全书网  (  <a href="mailto:webmaster@xqbase.com"> webmaster@xqbase.com  </a> )</p>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>人机对弈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最小-最大搜索</title>
    <link href="/posts/22963.html"/>
    <url>/posts/22963.html</url>
    
    <content type="html"><![CDATA[<p>《对弈程序基本技术》专题</p><p>最小  -  最大搜索</p><p>Bruce Moreland /  文</p><p>** 从浅显的地方开始 **<br>在国际象棋里，双方棋手都知道每个棋子在哪里，他们轮流走并且可以走任何合理的着法。下棋的目的就是将死对方，或者避免被将死，或者有时争取和棋是最好的选择。</p><p>国际象棋程序通过使用“搜索”函数来寻找着法。搜索函数获得棋局信息，然后寻找对于程序一方来说最好的着法。</p><p>一个浅显的搜索函数用“树状搜索”  (Tree-Searching)  来实现。一个国际象棋棋局通常可以看作一个很大的  _ n _ 叉树  (  “  _<br>n _ 叉树”意思是树的每个结点有任意多个分枝通向其他结点  )  ，棋盘上目前的局面就是“根局面”  (Root Position)  或“根结点”<br>(Root Node)  。从根局面走一步棋，局面就到达根局面的“分枝”  (Branch)  ，这些局面称为“后续局面”  (Successor<br>Position)  或“后续结点”  (Successor Nodes)  。每个后续局面后面还有一系列分枝，每个分枝就是这个局面的一个合理的着法。</p><p>国际象棋的树非常庞大  (  通常每个局面有  35  个分枝  )  ，又非常深。</p><p>每盘棋局都是一棵巨大的  _ n _ 叉树，如果能通过树状搜索找到棋局中对双方来说都最好的着法就好了。这个浅显的算法在这里称为“最小  -  最大搜索”<br>(Min-max Search)  。</p><p>用最小  -  最大搜索来解诸如井字棋的简单棋局是可行的  (  即完全了解每一种变化  )<br>。井字棋的博弈树既不烦琐也不深，所以整个树可以遍历，棋局的所有变化都可以知道，任何局面都可以保证找到一步最佳着法。</p><p>数学上用这种方法处理国际象棋也是可以的，但是目前和不久的将来用计算机去实现，却是不可行的。即便如此，我们仍然可以用基于最小  -<br>最大搜索的程序来下国际象棋。相比最小  -<br>最大地搜索整个树，在一个给定的局面下搜索前几步则是可能的。由于叶子结点的局面没能搜索出杀棋或和棋，所以要用一个称为“评价”  (Evaluate)<br>的启发函数给这些局面赋值。尽管程序设计师希望这些值能够通过知识来得到，但它们确实都是猜的。</p><p>** 基于最小-最大的评价函数 **<br>我不打算在这里谈很多关于评价函数的细节。这里我只说明它是怎样确定的，在以后的章节中会详细展开。评价函数首先应该返回局面的准确值，在没办法得到准确值的情况下，<br>如果可能的话启发值也可以。它可以由两种方法来决定：</p><p>(1)  如果黑方被将死了，那么评价函数返回一个充分大的正数；如果白方被将死了，那么返回一个充分大的负数；如果棋局是和棋  (<br>例如某一方逼和，或者双方都只有王  )<br>，那么返回一个常数，通常是零或接近零。如果不是棋局结束局面，那么它返回一个启发值。我将不详细介绍这个启发值是如何确定的，但是我有把握说子力平衡是首先要考虑的<br>(  如果白方盘面上多子的话，这个值就大  )  ，而其他位置上的考虑  (  兵型、王的安全性、重要的子力等等  )  也需要加上。如果白方是赢棋或者很有<br>希望赢，那么启发函数通常会返回正数；如果黑方是赢棋或者很有希望赢，那么返回负数；如果棋局是均势或者是和棋，那么返回在零左右的数值。</p><p>(2)  这个函数的工作原理跟第一个一样，只是如果当前局面要走子的一方优势，那么它返回正数，反之是负数。</p><p>** 最小 ** ** - ** ** 最大搜索是如何运作的 **<br>最小  -<br>最大搜索是一对几乎一样的函数，或者说两个逻辑上重复的函数。我写了很少的代码，用一个更好的函数来完成同一件事，但是写出来时却收到一些意见，因此我首先写出纯粹的<br>(  不完美的  )  最小  -  最大函数，代码如下：</p><pre><code class="hljs"> int MinMax(int depth) &#123; if (SideToMove() == WHITE) &#123;　// 白方是“最大”者 return Max(depth); &#125; else &#123;　　　　　　　　　　　// 黑方是“最小”者 return Min(depth); &#125; &#125; int Max(int depth) &#123; int best = -INFINITY; if (depth &lt;= 0) &#123; return Evaluate(); &#125; GenerateLegalMoves(); while (MovesLeft()) &#123; MakeNextMove(); val = Min(depth - 1); UnmakeMove(); if (val &gt; best) &#123; best = val; &#125; &#125; return best; &#125; int Min(int depth) &#123; int best = INFINITY;　// 注意这里不同于“最大”算法 if (depth &lt;= 0) &#123; return Evaluate(); &#125; GenerateLegalMoves(); while (MovesLeft()) &#123; MakeNextMove(); val = Max(depth - 1); UnmakeMove(); if (val &lt; best) &#123; 　// 注意这里不同于“最大”算法 best = val; &#125; &#125; return best; &#125;</code></pre><p>上面的代码可以这样调用：</p><pre><code class="hljs"> val = MinMax(5);</code></pre><p>这样可以返回当前局面的评价，它是向前看  5  步的结果。</p><p>这里的“评价”函数用的是我上面所说第一种定义，它总是返回对于白方来说的局面。</p><p>我简要描述一下这个函数是如何运作的。假设根局面  (  棋盘上当前局面  )  是白方走，那么调用的是“  Max<br>”函数，它产生白方所有合理着法。在每个后续局面中，调用的是“  Min<br>”函数，它对局面作出评价并返回。由于现在是白走，因此白方需要让评价尽可能地大，能得到最大值的那个着法被认为是最好的，因此返回这个着法的评价。</p><p>“  Min  ”函数正好相反，当黑方走时调用“  Min  ”函数，而黑方需要尽可能地小，因此选择能得到最小值的那个着法。</p><p>这两个函数是互相递归的，即它们互相调用，直到达到所需要的深度为止。当函数到达最底层时，它们就返回“  Evaluate  ”函数的值。</p><p>如果在深度为  1  时调用“  MinMax  ”函数，那么“  Evaluate<br>”函数在走完每个合理着法之后就调用，选择一个能达到最佳值的那个着法导致的局面。如果层数大于  1  ，那么另一方有权选择局面，并找一个最好的。</p><p>以上内容应该不难理解，但是代码很长，下面有个更好的办法。</p><p>** 负值最大函数 **<br>负值最大只是对最小-最大的优化，“评价”函数返回我所说的第二种定义，对于当前结点上要走的一方，占优的情况返回正值，其他结点也是对于要走的一方而言的。这个值返<br>回后要加上负号，因为返回以后就是对另一方而言了。代码如下：</p><pre><code class="hljs"> int NegaMax(int depth) &#123; int best = -INFINITY; if (depth &lt;= 0) &#123; return Evaluate(); &#125; GenerateLegalMoves(); while (MovesLeft()) &#123; MakeNextMove(); val = -NegaMax(depth - 1); // 注意这里有个负号。 UnmakeMove(); if (val &gt; best) &#123; best = val; &#125; &#125; return best; &#125;</code></pre><p>在这个函数里，当走子一方改变时就要对返回值取负值，以反映当前局面评价的更改。就根结点是白先走的情况，如果没有剩下的层数，那么“评价”返回的值是就白方而言的，<br>如果有剩下的层数，就产生后续局面，函数对这些局面逐一做递归，每个次递归都得到就黑方而言的评价，黑方走得越好值就越大。当评价值返回时，它们被取负数，变成就白方<br>而言的评价。</p><p>该函数在遍历时结点的顺序同“最小  -<br>最大”搜索的函数是一样的，产生的返回值也一样。它的代码更短，同时减少了移植代码时出错的可能，代码维护起来也比较方便。</p><p>原文： <a href="http://www.seanet.com/~brucemo/topics/minmax.htm"> http://www.seanet.com/~brucemo/topics/minmax.htm</a></p><p>译者：象棋百科全书网  (  <a href="mailto:webmaster@xqbase.com"> webmaster@xqbase.com  </a> )</p>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>人机对弈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ 1679 The Unique MST(判断最小生成树是否唯一)</title>
    <link href="/posts/28173.html"/>
    <url>/posts/28173.html</url>
    
    <content type="html"><![CDATA[<h3 id="题目链接：-kuangbin带你飞-专题六-最小生成树-K-The-Unique-MST"><a href="#题目链接：-kuangbin带你飞-专题六-最小生成树-K-The-Unique-MST" class="headerlink" title="题目链接： [ kuangbin带你飞 专题六 最小生成树 K - The Unique MST"></a>题目链接： [ kuangbin带你飞 专题六 最小生成树 K - The Unique MST</h3><p>](<a href="http://acm.hust.edu.cn/vjudge/contest/view.action?cid=66965#problem/K">http://acm.hust.edu.cn/vjudge/contest/view.action?cid=66965#problem/K</a>)</p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>给定一无向图，判断最小生成树是否唯一。</p></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><blockquote><p>先求出最小生成树，记录结果，依次删除树中各边，再求最小生成树，看与最初结果是否相同，若相同则不唯一</p></blockquote><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="hljs">////  main.cpp//  demo////  Created by shiyi－mac on 16/1/2.//  Copyright © 2016年 shiyi－mac. All rights reserved.//#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;const int N = 109;const int MAX = 100000000;int d[N];int g[N][N];int fa[N];pair&lt;int, int&gt; v[N];int prim(int n, int m, bool f)&#123;    for(int i=0;i&lt;n;i++)    &#123;        d[i] = g[0][i];        fa[i] = 0;    &#125;    d[0] = -1;    int ans = 0;    for(int i=1;i&lt;n;i++)    &#123;        int min = MAX, mini = -1;        for(int j=0;j&lt;n;j++)        &#123;            if(d[j]!=-1 &amp;&amp; d[j]&lt;min)            &#123;                min = d[j];                mini = j;            &#125;        &#125;        if(mini == -1)            return -1;        d[mini] = -1;        if(f)        &#123;            v[i].first = mini;            v[i].second = fa[mini];        &#125;        ans += min;        for(int j=0;j&lt;n;j++)            if(d[j]!=-1 &amp;&amp; d[j] &gt; g[mini][j])            &#123;                fa[j] = mini;                d[j] = g[mini][j];            &#125;    &#125;    return ans;&#125;int main()&#123;    int T;    scanf(&quot;%d&quot;,&amp;T);    while(T--)    &#123;        int n, m;        memset(g, 0x3f, sizeof(g));        scanf(&quot;%d%d&quot;,&amp;n, &amp;m);        int a, b, c;        for(int i=0;i&lt;m;i++)        &#123;            scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);            g[a-1][b-1] = g[b-1][a-1] = c;        &#125;        int ans = prim(n, m, 1);        for(int i=1;i&lt;n;i++)        &#123;            int t = g[v[i].first][v[i].second];            g[v[i].first][v[i].second]            = g[v[i].second][v[i].first] = MAX;            if(ans == prim(n, m, 0))            &#123;                ans = -1;                break;            &#125;            g[v[i].first][v[i].second]            = g[v[i].second][v[i].first] = t;        &#125;        if(ans == -1)            printf(&quot;Not Unique!\n&quot;);        else            printf(&quot;%d\n&quot;,ans);    &#125;    return 0;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>最小生成树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ 3026 Borg Maze</title>
    <link href="/posts/15034.html"/>
    <url>/posts/15034.html</url>
    
    <content type="html"><![CDATA[<h3 id="题目链接：-kuangbin带你飞-专题六-最小生成树J-Borg-Maze"><a href="#题目链接：-kuangbin带你飞-专题六-最小生成树J-Borg-Maze" class="headerlink" title="题目链接： [ kuangbin带你飞 专题六 最小生成树J - Borg Maze"></a>题目链接： [ kuangbin带你飞 专题六 最小生成树J - Borg Maze</h3><p>](<a href="http://acm.hust.edu.cn/vjudge/contest/view.action?cid=66965#problem/J">http://acm.hust.edu.cn/vjudge/contest/view.action?cid=66965#problem/J</a>)</p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>题目好难懂啊，英文题读起来好痛苦。<br>大概意思就是，给定一起点，和n个点有外星人，你有一个搜索集团，让你去同化这些外星人。在起点和每同化一个外星人时，该集团可能会分裂成两个或两个以上的组织(但他<br>们的意识仍然是集体)。搜索迷宫的成本是一共所走过的总距离。<br>求最小的成本是多少。</p></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><blockquote><p>因为只能在起点和外星人所在点进行分裂，那么这些点可看做结点，任意两点间的距离看做边权值，则显然是一个最小生成树问题。将A和S点的坐标提取出来，通过bfs<br>，计算任意两点之间的距离，然后prim即可。<br>另外，此题数据较坑。提交时无辜的wrong了好几次。输入数据每行的最后面都有一个空格，要注意gets()处理。</p></blockquote><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="hljs">////  main.cpp//  demo////  Created by shiyi－mac on 16/1/2.//  Copyright © 2016年 shiyi－mac. All rights reserved.//#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;const int N = 109;const int MAX = 1000000;int g[N][N];int d[N];char s[59][59];int qx[] = &#123;-1, 1, 0, 0&#125;;int qy[] = &#123;0, 0, 1, -1&#125;;bool vist[59][59];struct Node&#123;    int x, y, num;&#125;spot[N];int find(int x, int y, int len)&#123;    for(int i=0;i&lt;len;i++)        if(spot[i].x == x &amp;&amp; spot[i].y == y)            return i;    return -1;&#125;void bfs(int pos, int x, int y, int xlen, int ylen, int plen)&#123;    queue&lt;Node&gt; q;    spot[pos].num = 0;    q.push(spot[pos]);    vist[x][y] = 1;    while(!q.empty())    &#123;        Node t = q.front();        q.pop();        if(s[t.x][t.y] == &#39;A&#39; || s[t.x][t.y] == &#39;S&#39;)        &#123;            int tpos = find(t.x, t.y, plen);            g[pos][tpos] = g[tpos][pos] = t.num;        &#125;        int dx, dy;        for(int i=0;i&lt;4;i++)        &#123;            dx = qx[i] + t.x;            dy = qy[i] + t.y;            if(dx&gt;=0 &amp;&amp; dx&lt;xlen &amp;&amp; dy&gt;=0 &amp;&amp; dy&lt;ylen               &amp;&amp; !vist[dx][dy] &amp;&amp; s[dx][dy]!=&#39;#&#39;)            &#123;                Node p = &#123;dx, dy, t.num+1&#125;;                q.push(p);                vist[dx][dy] = 1;            &#125;        &#125;    &#125;&#125;int prim(int n)&#123;    for(int i=0;i&lt;n;i++)        d[i] = g[0][i];    d[0] = -1;    int ans = 0;    for(int i=1;i&lt;n;i++)    &#123;        int min = MAX;        int imin = -1;        for(int j=0;j&lt;n;j++)            if(d[j]!=-1 &amp;&amp; min &gt; d[j])                min = d[j], imin = j;        ans += min;        d[imin] = -1;        for(int j=0;j&lt;n;j++)            if(d[j]!=-1 &amp;&amp; d[j] &gt; g[imin][j])                d[j] = g[imin][j];    &#125;    return ans;&#125;int main()&#123;    int n;    scanf(&quot;%d&quot;,&amp;n);    while(n--)    &#123;        int y, x;        int num = 0;        scanf(&quot;%d%d&quot;, &amp;y, &amp;x);        gets(s[0]);        for(int i=0;i&lt;x;i++)            gets(s[i]);        for(int i=0;i&lt;x;i++)        &#123;            for(int j=0;j&lt;y;j++)                if(s[i][j] == &#39;A&#39; || s[i][j] == &#39;S&#39;)                    spot[num++] = &#123;i, j&#125;;        &#125;        for(int i=0;i&lt;num;i++)        &#123;            memset(vist, 0, sizeof(vist));            s[spot[i].x][spot[i].y] = &#39; &#39;;            bfs(i, spot[i].x, spot[i].y, x, y, num);        &#125;        printf(&quot;%d\n&quot;,prim(num));    &#125;    return 0;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>最小生成树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ 1751 Highways</title>
    <link href="/posts/24271.html"/>
    <url>/posts/24271.html</url>
    
    <content type="html"><![CDATA[<h3 id="题目链接：-kuangbin带你飞-专题六-最小生成树-H-Highways"><a href="#题目链接：-kuangbin带你飞-专题六-最小生成树-H-Highways" class="headerlink" title="题目链接： [ kuangbin带你飞 专题六 最小生成树 H - Highways"></a>题目链接： [ kuangbin带你飞 专题六 最小生成树 H - Highways</h3><p>](<a href="http://acm.hust.edu.cn/vjudge/contest/view.action?cid=66965#problem/H">http://acm.hust.edu.cn/vjudge/contest/view.action?cid=66965#problem/H</a>)</p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>n个城市，需要修高速公路，将所有城市联通，已经修建好了m条高速公路，剩下未修的公路，怎样修能够使长度最小，输出这些公路的左右两端城市</p></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><blockquote><p>典型的最小生成树，因为需要输出边左右结点，维护一个fa[N]数组即可。将已经见好的公路所对应边的权值置为0。还是prim</p></blockquote><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="hljs">////  main.cpp//  demo////  Created by shiyi－mac on 16/1/2.//  Copyright © 2016年 shiyi－mac. All rights reserved.//#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;const int N = 759;const int MAX = 1000000;double g[N][N];double d[N];int x[N], y[N];int fa[N];void prim(int n)&#123;    for(int i=2;i&lt;=n;i++)    &#123;        d[i] = g[1][i];        fa[i] = 1;    &#125;    d[1] = -1;    int pos = 0;    for(int i=1;i&lt;n;i++)    &#123;        double min = MAX;        int imin = -1;        for(int j=1;j&lt;=n;j++)            if(d[j]!=-1 &amp;&amp; min &gt; d[j])                min = d[j], imin = j;        if(min != 0)            printf(&quot;%d %d\n&quot;, imin, fa[imin]);        d[imin] = -1;        for(int j=1;j&lt;=n;j++)            if(d[j]!=-1 &amp;&amp; d[j] &gt; g[imin][j])            &#123;                d[j] = g[imin][j];                fa[j] = imin;            &#125;    &#125;&#125;int main()&#123;    int n;    scanf(&quot;%d&quot;,&amp;n);    for(int i=1;i&lt;=n;i++)    scanf(&quot;%d%d&quot;,&amp;x[i], &amp;y[i]);    for(int i=1;i&lt;=n;i++)        for(int j=i+1;j&lt;=n;j++)        &#123;            double l = sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]));            g[j][i] = g[i][j] = l;        &#125;    int q;    scanf(&quot;%d&quot;,&amp;q);    for(int i=0;i&lt;q;i++)    &#123;        int a, b;        scanf(&quot;%d%d&quot;,&amp;a, &amp;b);        g[a][b] = g[b][a] = 0;    &#125;    prim(n);    return 0;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>最小生成树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ 2349 Arctic Network</title>
    <link href="/posts/251.html"/>
    <url>/posts/251.html</url>
    
    <content type="html"><![CDATA[<h3 id="题目链接：-kuangbin带你飞-专题六-最小生成树-G-Arctic-Network"><a href="#题目链接：-kuangbin带你飞-专题六-最小生成树-G-Arctic-Network" class="headerlink" title="题目链接： [ kuangbin带你飞 专题六 最小生成树 G - Arctic Network"></a>题目链接： [ kuangbin带你飞 专题六 最小生成树 G - Arctic Network</h3><p>](<a href="http://acm.hust.edu.cn/vjudge/contest/view.action?cid=66965#problem/G">http://acm.hust.edu.cn/vjudge/contest/view.action?cid=66965#problem/G</a>)</p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>n个前哨，s个卫星频道。任意两个前哨可以通过卫星频道或者无线电来通信，前者无视距离，后者最大距离为d，与无线电装置的能量相关。每个前哨的无线电能量都相同<br>，问在所有前哨都可以直接或间接通信的情况下，最小的d是多少</p></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><blockquote><p>显然，此题是最小生成树问题。特殊的是，有s个卫星频道可以无视距离。<br>将n前哨的最小生成树求出并对n-1条边排序，后s-1条边使用卫星，那么剩余边中最大的边长即为所求的d。<br>问题也就可以转化为求最小生成树第k大边问题，在本题是，求第n－s大边的问题。</p></blockquote><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="hljs">////  main.cpp//  demo////  Created by shiyi－mac on 16/1/2.//  Copyright © 2016年 shiyi－mac. All rights reserved.//#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;const int N = 509;const int MAX = 1000000;double g[N][N];double d[N], p[N];int x[N], y[N];double prim(int s, int n)&#123;    for(int i=2;i&lt;=n;i++)        d[i] = g[1][i];    d[1] = -1;    for(int i=1;i&lt;n;i++)    &#123;        double min = MAX;        int imin = -1;        for(int j=1;j&lt;=n;j++)            if(d[j]!=-1 &amp;&amp; min &gt; d[j])                min = d[j], imin = j;        p[i] = min;        //cout&lt;&lt;min&lt;&lt;endl;        d[imin] = -1;        for(int j=1;j&lt;=n;j++)            if(d[j]!=-1 &amp;&amp; d[j] &gt; g[imin][j])                d[j] = g[imin][j];    &#125;    sort(p+1, p+n);    return p[n-s];&#125;int main()&#123;    int n;    scanf(&quot;%d&quot;,&amp;n);    while(n--)    &#123;        int s, p;        scanf(&quot;%d%d&quot;,&amp;s, &amp;p);        for(int i=1;i&lt;=p;i++)            scanf(&quot;%d%d&quot;,&amp;x[i], &amp;y[i]);        for(int i=1;i&lt;=p;i++)            for(int j=i+1;j&lt;=p;j++)            &#123;                double l = sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]));                g[j][i] = g[i][j] = l;            &#125;        printf(&quot;%.2f\n&quot;, prim(s, p));    &#125;    return 0;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>最小生成树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ1789 Truck History</title>
    <link href="/posts/15447.html"/>
    <url>/posts/15447.html</url>
    
    <content type="html"><![CDATA[<h3 id="题目链接：-kuangbin带你飞-专题六-最小生成树-F-Truck-History"><a href="#题目链接：-kuangbin带你飞-专题六-最小生成树-F-Truck-History" class="headerlink" title="题目链接： [ kuangbin带你飞 专题六 最小生成树 F - Truck History"></a>题目链接： [ kuangbin带你飞 专题六 最小生成树 F - Truck History</h3><p>](<a href="http://acm.hust.edu.cn/vjudge/contest/view.action?cid=66965#problem/F">http://acm.hust.edu.cn/vjudge/contest/view.action?cid=66965#problem/F</a>)</p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>英语不好，看题好费劲，大概意思是：<br>一个汽车公司每个卡车都用一个长度为7的字符串来表示，每个卡车之间都可以进行派生，而且派生会有代价<br>A ： aaaaaaa<br>B ： baaaaab<br>A车和B车有两个地方不同，所以它们之间派生的代价是2<br>问以任意一个卡车开始，依次派生出所有卡车，需要的最小代价是多少</p></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><blockquote><p>题目分类就是最小生成树，很明确，题目意思看懂后，也很好理解，将车看做点，互相之间派生以及代价可看做无向有权边，然后求最小生成树，prim即可</p></blockquote><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="hljs">////  main.cpp//  demo////  Created by shiyi－mac on 16/1/2.//  Copyright © 2016年 shiyi－mac. All rights reserved.//#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;const int N = 2009;const int MAX = 1000000;int g[N][N];int d[N], p[N];char s[N][7];int prim(int n)&#123;    for(int i=2;i&lt;=n;i++)        d[i] = g[1][i];    d[1] = -1;    int ans = 0;    for(int i=1;i&lt;n;i++)    &#123;        int min = MAX;        int imin = -1;        for(int j=1;j&lt;=n;j++)            if(d[j]!=-1 &amp;&amp; min &gt; d[j])                min = d[j], imin = j;        ans += min;        //cout&lt;&lt;min&lt;&lt;&quot;==&quot;&lt;&lt;imin&lt;&lt;endl;        d[imin] = -1;        for(int j=1;j&lt;=n;j++)            if(d[j]!=-1 &amp;&amp; d[j] &gt; g[imin][j])                d[j] = g[imin][j];    &#125;    return ans;&#125;int main()&#123;    int n;    while(~scanf(&quot;%d&quot;,&amp;n) &amp;&amp; n)    &#123;        memset(g, 0, sizeof(g));        for(int i=1;i&lt;=n;i++)            scanf(&quot;%s&quot;,s[i]);        for(int i=1;i&lt;=n;i++)            for(int j=i+1;j&lt;=n;j++)            &#123;                for(int k=0;k&lt;7;k++)                    if(s[i][k] != s[j][k])                        g[i][j]++, g[j][i]++;            &#125;        printf(&quot;The highest possible quality is 1/%d.\n&quot;, prim(n));    &#125;    return 0;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>最小生成树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>哈夫曼编码压缩解压缩实现&amp;不同类型文件压缩比的测试</title>
    <link href="/posts/44265.html"/>
    <url>/posts/44265.html</url>
    
    <content type="html"><![CDATA[<h2 id="压缩原理及步骤-amp-amp-压缩比的计算"><a href="#压缩原理及步骤-amp-amp-压缩比的计算" class="headerlink" title="压缩原理及步骤&amp;&amp;压缩比的计算"></a>压缩原理及步骤&amp;&amp;压缩比的计算</h2><h3 id="压缩原理及步骤"><a href="#压缩原理及步骤" class="headerlink" title="压缩原理及步骤"></a>压缩原理及步骤</h3><h4 id="压缩的第一步："><a href="#压缩的第一步：" class="headerlink" title="压缩的第一步："></a>压缩的第一步：</h4><blockquote><p>将一个文件以各个字符出现的次数为权值建立哈夫曼树，这样每个字符可以用 ** _ 从树根到该字符所在到叶子节点的路径 _ ** 来表示。(左为0,右为1)</p></blockquote><h4 id="压缩第二步："><a href="#压缩第二步：" class="headerlink" title="压缩第二步："></a>压缩第二步：</h4><blockquote><p>哈夫曼编码有一个很重要的特性： ** _ 每个字符编码不会成为另一个编码的前缀 _ **<br>。这个特性保证了即使我们把不同长度的编码存在一起，仍然也可以把它们分离开，不会出现 ** _ 认错人 _ ** 的冲突。<br>那么我们就可以把所有的字符按照原有顺序用其编码替换，构建新的字符串作为其压缩后的串。</p></blockquote><h4 id="压缩第三步："><a href="#压缩第三步：" class="headerlink" title="压缩第三步："></a>压缩第三步：</h4><blockquote><p>有的小伙伴可能要问了，这样一搞不是越变越多了么，哪是什么压缩。哈哈，大部分孩子可能已经想到啦，既然单位编码除了0就是1为什么还要用字节来存呢， ** _<br>用位来保存，8个单位编码为1位 _ ** 。这样转化完成后的串才是真正压缩后的串。</p></blockquote><p>** _ 当然，因为我们还要进行解压，所以这里构建的树也要和串一并加入到文件。 _ **</p><h3 id="压缩比的计算"><a href="#压缩比的计算" class="headerlink" title="压缩比的计算"></a>压缩比的计算</h3><p>介绍完步骤，我们来计算一下哈夫曼编码的压缩比。</p><p>_ 用len表示串长度，path(i)表示每i个字符的编码长度 _ ，那么根据上文所介绍的原理，我们可以很容易知道，串通过哈夫曼压缩后的长度为</p><pre><code class="hljs"> sum(path(i)) 1&lt;=i&lt;=len</code></pre><p>这个式子虽然正确但不能直观的感受的压缩比，所以我们来假设一种平均情况进行估算</p><p>假如一个 _ 串长度为n _ ，一共包含 _ m个不同的字符 _ ，那么所构建成的哈夫曼树的 _ 总结点数为 2*m-1 _ 。</p><p>假设，n很大，那么可以忽略树的保存所占用的空间。如果假设此串中每个字符出现的次数都是相同的，那么也可以假设，它们所生成的哈夫曼树是完全二叉树.</p><p>即每个叶子(字符)的 _ 深度为log(m)+1，则路径长度为log(m) _<br>。log(m)即为该串字符的平均路径长度，那么压缩后的串长为log(m)/8。</p><p>由上可以得出平均压缩比的公式为：</p><pre><code class="hljs"> n*log(2*m-1)/8/n = log(2*m-1)/8;</code></pre><p>可见压缩比的大小主要与m有关，即不同的字符越少越好。</p><p>ascii码的范围为0～255，共有256种不同字符，代入上式得</p><pre><code class="hljs"> log(2*256-1) ＝ 6.23 …</code></pre><p>向上取整为7(路径个数哪有小数)<br>7/8 = 0.875 = %87.5<br>所以哈夫曼编码的平均压缩比为%87.5。</p><h4 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h4><blockquote><p>** 上述的假设在计算情况中忽略了对哈夫曼树的保存，所以只在文件总长度与不同字符总数相差很大时才生效。 **</p></blockquote><h3 id="考虑ascii码外的其它语言"><a href="#考虑ascii码外的其它语言" class="headerlink" title="考虑ascii码外的其它语言"></a>考虑ascii码外的其它语言</h3><blockquote><p>一开始为考虑这个钻了牛角尖，想着去统一用wchar_t保存或是转为Unicode等等什么的。但其实不必那么复杂，因为汉字(不仅仅汉字，任何字符都是这样的<br>)都是以字节为单位的，由多个字节组成的，将其分开对待，因为最终解压时恢复原串还是按照原有顺序组装，所以和纯英文文件的实现没有什么区别)；</p></blockquote><h3 id="需要注意的地方"><a href="#需要注意的地方" class="headerlink" title="需要注意的地方"></a>需要注意的地方</h3><blockquote><p>所有字符路径的总长不一定整除8，所以在按为保存时，要注意最后一项不足8的情况，进行补零，且要将补零的个数保存起来。</p></blockquote><h2 id="代码对不同类型文档的压缩比测试情况"><a href="#代码对不同类型文档的压缩比测试情况" class="headerlink" title="代码对不同类型文档的压缩比测试情况"></a>代码对不同类型文档的压缩比测试情况</h2><h4 id="英语文章"><a href="#英语文章" class="headerlink" title="英语文章"></a>英语文章</h4><h5 id="样例文档：西游记英文节选"><a href="#样例文档：西游记英文节选" class="headerlink" title="样例文档：西游记英文节选"></a>样例文档：西游记英文节选</h5><blockquote><p>原大小：7720<br>压缩后：10476<br>压缩比：1.356 – %135<br>此处的文件压缩后不降反增，因为文件本身大小与不同字符的数量相差并不大，加上对树的保存后，空间大于压缩前。</p></blockquote><h5 id="纯汉语文档"><a href="#纯汉语文档" class="headerlink" title="纯汉语文档"></a>纯汉语文档</h5><blockquote><p>样例文档：西游记<br>原大小：1921978<br>压缩后：1781234<br>压缩比：0.926 – %92<br>不同汉字的数量多。</p></blockquote><h5 id="程序代码"><a href="#程序代码" class="headerlink" title="程序代码"></a>程序代码</h5><blockquote><p>样例文档：github网页源代码<br>原大小：46500<br>压缩后：35116<br>压缩比：0.755 – %76<br>源代码中全是英文字母与符号，不超过100种，总大小与其相差近500倍，且代码重复词比较多。</p></blockquote><h5 id="英语单词文档"><a href="#英语单词文档" class="headerlink" title="英语单词文档"></a>英语单词文档</h5><blockquote><p>样例文档：英语单词5000<br>原大小：20813<br>压缩后：13523<br>压缩比：0.649 – %65</p></blockquote><p><img src="http://img.blog.csdn.net/20151230002934527" alt="测试情况"></p><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><h3 id="压缩程序源文件-compress-cpp"><a href="#压缩程序源文件-compress-cpp" class="headerlink" title="压缩程序源文件 compress.cpp"></a>压缩程序源文件 compress.cpp</h3><pre><code class="hljs">#include &lt;iostream&gt;#include &lt;locale&gt;#include &lt;cstdlib&gt;#include &lt;fstream&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;const long long MAX_SIZE = 10000000000;//const int MAX_TYPE = 300;unsigned int *f = new unsigned int[MAX_TYPE];//计数unsigned int *p = new unsigned int[MAX_TYPE];//计下标char *v = new char[MAX_TYPE];char filename[20];char *s[MAX_TYPE];struct Node&#123;    unsigned int weight, parent, lson, rson;    Node()&#123;&#125;;&#125;HuffmanTree[MAX_TYPE&lt;&lt;1];struct NodeCmp&#123;    bool operator()(int a, int b)    &#123;        return HuffmanTree[a].weight &gt; HuffmanTree[b].weight;    &#125;&#125;;int CreatTree(char *str, long long len)&#123;    int num = 1;    for(int i=0;i&lt;len;i++)        f[str[i]]++;    cout&lt;&lt;&quot;len::&quot;&lt;&lt;len&lt;&lt;endl;    for(int i=0;i&lt;len;i++)    &#123;        if(f[str[i]])        &#123;            HuffmanTree[num].weight = f[str[i]];            HuffmanTree[num].lson = 0;            HuffmanTree[num].rson = 0;            f[str[i]] = 0;            if(p[str[i]] == 0)                p[str[i]] = num;            v[num] = str[i];            ++num;        &#125;    &#125;    cout&lt;&lt;&quot;num::&quot;&lt;&lt;num&lt;&lt;endl;    return num;&#125;void CodingTree(int num)&#123;    priority_queue&lt;int, vector&lt;int&gt;, NodeCmp&gt; q;    for(int i=1;i&lt;num;i++)        q.push(i);    int len = num;    for(int i=0;i&lt;num-2;i++)    &#123;        int x = q.top(); q.pop();        int y = q.top(); q.pop();        HuffmanTree[len].weight = HuffmanTree[x].weight + HuffmanTree[y].weight;        HuffmanTree[x].parent = HuffmanTree[y].parent = len;        HuffmanTree[len].lson = y;        HuffmanTree[len].rson = x;        q.push(len++);    &#125;&#125;void FindPath(int num)&#123;    char *t = new char[num];    t[num-1] = &#39;\0&#39;;    for(int i=1;i&lt;num;i++)    &#123;        int son = i, father = HuffmanTree[i].parent;        int start = num-1;        while(father != 0)        &#123;            --start;            if(HuffmanTree[father].rson == son)                t[start] = &#39;1&#39;;            else                t[start] = &#39;0&#39;;            son = father;            father = HuffmanTree[father].parent;        &#125;        s[i] = new char[num - start];        strcpy(s[i], &amp;t[start]);    &#125;&#125;void print(int num, long long len, char *str)&#123;    ofstream fout(filename, ios::out);    fout&lt;&lt;num&lt;&lt;endl;    for(int i=1;i&lt;num;i++)    &#123;        fout&lt;&lt;s[i]&lt;&lt;endl;        fout&lt;&lt;v[i]&lt;&lt;endl;    &#125;    long long pos = 0;    char *ans = new char[MAX_SIZE];    int now = 7;    for(long long i=0;i&lt;len;i++)    &#123;        int k = 0;        while(s[p[str[i]]][k] != &#39;\0&#39;)        &#123;            ans[pos] |= (s[p[str[i]]][k]-&#39;0&#39;)&lt;&lt;now--;            if(now &lt; 0)            &#123;                now = 7;                pos++;            &#125;            ++k;        &#125;    &#125;    int zero = 0;    if(now != 7) zero = now%7+1, pos++;    fout&lt;&lt;zero&lt;&lt;&quot; &quot;&lt;&lt;pos&lt;&lt;endl;    fout.write(ans, sizeof(char)*pos);    fout.close();    cout&lt;&lt;&quot;zero::&quot;&lt;&lt;zero&lt;&lt;endl;&#125;int main(int argc, char **argv)&#123;    sprintf(filename, &quot;%s.temp&quot;, argv[1]);    ifstream fin(argv[1],ios::ate | ios::in);    if(!fin)    &#123;        cout&lt;&lt;&quot;File open error!&quot;&lt;&lt;endl;        return 0;    &#125;    long long size = fin.tellg();    if(size &gt; MAX_SIZE)    &#123;        cout&lt;&lt;&quot;Too long!&quot;&lt;&lt;endl;        return 0;    &#125;    fin.seekg(0, ios::beg);    char *str = new char[size+1];    fin.read(str,size);    fin.close();    int num = CreatTree(str, size);    CodingTree(num);    FindPath(num);    print(num, size, str);    return 0;&#125;</code></pre><h3 id="解压程序源文件-compress-cpp"><a href="#解压程序源文件-compress-cpp" class="headerlink" title="解压程序源文件 compress.cpp"></a>解压程序源文件 compress.cpp</h3><pre><code class="hljs">#include &lt;iostream&gt;#include &lt;locale&gt;#include &lt;cstdlib&gt;#include &lt;fstream&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;char filename[20];const long long MAX_SIZE = 10000000000;//const int MAX_TYPE = 300;struct Node&#123;    char v;    int parent, lson, rson;    Node()&#123;&#125;;&#125;HuffmanTree[MAX_TYPE&lt;&lt;1];char *str = new char[MAX_SIZE];char *ans = new char[MAX_SIZE];void CreatTree(char *t, char v, int &amp;pos)&#123;    int root = 0;    for(int i=0;t[i]!=&#39;\0&#39;;i++)    &#123;        if(t[i] == &#39;1&#39;)        &#123;            if(HuffmanTree[root].rson == 0)                HuffmanTree[root].rson = pos++;            root = HuffmanTree[root].rson;        &#125;        else        &#123;            if(HuffmanTree[root].lson == 0)                HuffmanTree[root].lson = pos++;            root = HuffmanTree[root].lson;        &#125;    &#125;    HuffmanTree[root].v = v;&#125;void print(int zero, int len, char *str)&#123;    long long start = 0;    int root = 0;    int end = 0;    for(int i=0;i&lt;len;i++)    &#123;        char t = str[i];        if(i == len-1)            end = zero;        for(int j=7;j&gt;=end;j--)        &#123;            if((1&lt;&lt;j) &amp; t)                root = HuffmanTree[root].rson;            else                root = HuffmanTree[root].lson;            if(HuffmanTree[root].lson == 0 &amp;&amp; HuffmanTree[root].rson == 0)            &#123;                ans[start++] = HuffmanTree[root].v;                root = 0;            &#125;        &#125;    &#125;    cout&lt;&lt;&quot;len::&quot;&lt;&lt;start&lt;&lt;endl;    ofstream out(filename, ios::out);    out.write(ans, sizeof(char)*(start));    out.close();&#125;int main(int argc, char **argv)&#123;    strcpy(filename, argv[1]);    filename[strlen(filename)-4] = &#39;o&#39;;    filename[strlen(filename)-3] = &#39;u&#39;;    filename[strlen(filename)-2] = &#39;t&#39;;    filename[strlen(filename)-1] = &#39;\0&#39;;    ifstream fin(argv[1], ios::in);    if(!fin)    &#123;        cout&lt;&lt;&quot;File open error!&quot;&lt;&lt;endl;        return 0;    &#125;    int num;    char *t = new char[num];    char *v = new char[3];    fin&gt;&gt;num;    fin.getline(t,num);    cout&lt;&lt;&quot;size::&quot;&lt;&lt;num&lt;&lt;endl;    int pos = 1;    for(int i=1;i&lt;num;i++)    &#123;        fin.getline(t,num);        fin.getline(v,num);        if(v[0] == &#39;\0&#39;)        &#123;            fin.getline(v,num);            v[0] = &#39;\n&#39;;        &#125;        CreatTree(t, v[0], pos);        v[0]=0;    &#125;    int zero;    long long size;    fin&gt;&gt;zero; fin&gt;&gt;size;    fin.getline(t,num);    fin.read(str,sizeof(char)*size);    print(zero, size, str);    cout&lt;&lt;&quot;zero::&quot;&lt;&lt;zero&lt;&lt;endl;    return 0;&#125;</code></pre><p>** _ 代码读写操作用文件流实现，所以在时间效率方面还有很多可优化的地方，待日后闲了再说，毕竟考试在即。。。如果哪里有错误，欢迎砸砖，便于在下提升修正。 _ **</p>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>utf8编码原理与发展历程</title>
    <link href="/posts/35867.html"/>
    <url>/posts/35867.html</url>
    
    <content type="html"><![CDATA[<p>很久很久以前，有一群人，他们决定用8个可以开合的晶体管来组合成不同的状态，以表示世界上的万物。他们认为8个开关状态作为原子单位很好，于是他们把这称为”字节”<br>。</p><p>再后来，他们又做了一些可以处理这些字节的机器，机器开动了，可以用字节来组合出更多的状态，状态开始变来变去。他们看到这样是好的，于是它们就这机器称为”计算机”<br>。</p><p>开始计算机只在美国用。八位的字节一共可以组合出256（2的8次方）种不同的状态。</p><p>他们把其中的编号从0开始的32种状态分别规定了特殊的用途，一但终端设备或者打印机遇上这些约定好的字节时，就要做一些约定的动作。遇上 00x10,<br>终端就换行，遇上0x07, 终端就向人们嘟嘟叫，例好遇上0x1b,<br>打印机就打印反白的字，对于终端就用彩色显示字母。他们看到这样很好，于是就把这些0x20（十进制32）以下的字节状态称为”控制码”。</p><p>他们又把所有的空格、标点符号、数字、大小写字母分别用连续的字节状态表示，一直编到了第127号，这样计算机就可以用不同字节来存储英语的<br>文字了。大家看到这样，都感觉很好，于是大家都把这个方案叫做 ANSI 的”Ascii”编码（American Standard Code for<br>Information Interchange，美国信息互换标准代码）。当时世界上所有的计算机都用同样的ASCII方案来保存英文文字。</p><p>后来，就像建造巴比伦塔一样，世界各地的都开始使用计算机，但是很多国家用的不是英文，他们用到的许多字母在ASCII中根本没有，为了也可以在计算机中保存他们的文<br>字，他们决定采用127号之后的空位来表示这些新的字母、符号，还加入了很多画表格时需要用下到的横线、竖线、交叉等形状，一直把序号编到了最后一个状态255。从1<br>28到255这一页的字符集被称”扩展字符集”。从此之后，贪婪的人类再没有新的状态可以用了，美帝国主义可能没有想到还有第三世界国家的人们也希望可以用到计算机吧<br>！</p><p>等中国人们得到计算机时，已经没有可以利用的字节状态来表示汉字，况且有6000多个常用汉字需要保存呢。但是这难不倒智慧的中国人民，我们不客气地把那些127号之<br>后的奇异符号们直接取消掉，并且规定：一个小于127的字符的意义与原来相同，但两个大于127的字符连在一起时，就表示一个汉字，前面的一个字节（他称之为高字节）<br>从0xA1用到 0xF7，后面一个字节（低字节）从0xA1到0xFE，这样我们就可以组合出大约7000多个简体汉字了。在这些编码里，我们还把数学符号、罗马希<br>腊的字母、日文的假名们都编进去了，连在 ASCII<br>里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的”全角”字符，而原来在127号以下的那些就叫”半角”字符了。</p><p>中国人民看到这样很不错，于是就把这种汉字方案叫做”GB2312”。GB2312 是对 ASCII 的中文扩展。</p><p>但是中国的汉字太多了，我们很快就就发现有许多人的人名没有办法在这里打出来，特别是某些很会麻烦别人的国家领导人（如朱镕基的“镕”字）。于是我们不得不继续把<br>GB2312 没有用到的码位找出来老实不客气地用上。</p><p>后来还是不够用，于是干脆不再要求低字节一定是127号之后的内码，只要第一个字节是大于127就固定表示这是一个汉字的开始，不管后面跟的是不是扩展字符集里的内容<br>。结果扩展之后的编码方案被称为 GBK 标准，GBK 包括了 GB2312 的所有内容，同时又增加了近20000个新的汉字（包括繁体字）和符号。</p><p>后来少数民族也要用电脑了，于是我们再扩展，又加了几千个新的少数民族的字，GBK 扩成了 GB18030。从此之后，中华民族的文化就可以在计算机时代中传承了。</p><p>中国的程序员们看到这一系列汉字编码的标准是好的，于是通称他们叫做 “DBCS”（Double Byte Charecter Set 双字节字符集）。在DBC<br>S系列标准里，最大的特点是两字节长的汉字字符和一字节长的英文字符并存于同一套编码方案里，因此他们写的程序为了支持中文处理，必须要注意字串里的每一个字节的值，<br>如果这个值是大于127的，那么就认为一个双字节字符集里的字符出现了。那时候凡是受过加持，会编程的计算机僧侣们都要每天念下面这个咒语数百遍：</p><p>“一个汉字算两个英文字符！一个汉字算两个英文字符……”</p><p>因为当时各个国家都像中国这样搞出一套自己的编码标准，结果互相之间谁也不懂谁的编码，谁也不支持别人的编码，连大陆和台湾这样只相隔了150海里，使用着同一种语言<br>的兄弟地区，也分别采用了不同的 DBCS 编码方案——当时的中国人想让电脑显示汉字，就必须装上一个”汉字系统”，专门用来处理汉字的显示、输入的问题，但是那个<br>台湾的愚昧封建人士写的算命程序就必须加装另一套支持 BIG5<br>编码的什么”倚天汉字系统”才可以用，装错了字符系统，显示就会乱了套！这怎么办？而且世界民族之林中还有那些一时用不上电脑的穷苦人民，他们的文字又怎么办？</p><p>真是计算机的巴比伦塔命题啊！</p><p>正在这时，大天使加百列及时出现了——一个叫 ISO （国际标谁化组织）的国际组织决定着手解决这个问题。他们采用的方法很简单：废了所有的地区性编码方案，重新搞<br>一个包括了地球上所有文化、所有字母和符号的编码！他们打算叫它”Universal Multiple-Octet Coded Character<br>Set”，简称 UCS, 俗称 “UNICODE”。</p><p>UNICODE 开始制订时，计算机的存储器容量极大地发展了，空间再也不成为问题了。于是 ISO<br>就直接规定必须用两个字节，也就是16位来统一表示所有的字符，对于ascii里的那些”半角”字符，UNICODE<br>包持其原编码不变，只是将其长度由原来的8位扩展为16位，而其他文化和语言的字符则全部重新统一编码。由于”半角”英文符号只需要用到低8位，所以其高<br>8位永远是0，因此这种大气的方案在保存英文文本时会多浪费一倍的空间。</p><p>这时候，从旧社会里走过来的程序员开始发现一个奇怪的现象：他们的strlen函数靠不住了，一个汉字不再是相当于两个字符了，而是一个！是 的，从 UNICODE<br>开始，无论是半角的英文字母，还是全角的汉字，它们都是统一的”一个字符”！同时，也都是统一的”两个字节”，请注意”字符”和”字节”两个术语的不同，<br>“字节”是一个8位的物理存贮单元，而”字符”则是一个文化相关的符号。在UNICODE 中，一个字符就是两个字节。一个汉字算两个英文字符的时代已经快过去了。</p><p>从前多种字符集存在时，那些做多语言软件的公司遇上过很大麻烦，他们为了在不同的国家销售同一套软件，就不得不在区域化软件时也加持那个双字节字符集咒语，不仅要处处<br>小心不要搞错，还要把软件中的文字在不同的字符集中转来转去。UNICODE 对于他们来说是一个很好的一揽子解决方案，于是从 Windows NT 开始，MS<br>趁机把它们的操作系统改了一遍，把所有的核心代码都改成了用 UNICODE 方式工作的版本，从这时开始，WINDOWS<br>系统终于无需要加装各种本土语言系统，就可以显示全世界上所有文化的字符了。</p><p>但是，UNICODE 在制订时没有考虑与任何一种现有的编码方案保持兼容，这使得 GBK 与UNICODE<br>在汉字的内码编排上完全是不一样的，没有一种简单的算术方法可以把文本内容从UNICODE编码和另一种编码进行转换，这种转换必须通过查表来进行。</p><p>如前所述，UNICODE 是用两个字节来表示为一个字符，他总共可以组合出65535不同的字符，这大概已经可以覆盖世界上所有文化的符号。如果还不够也没有关系<br>，ISO已经准备了UCS-<br>4方案，说简单了就是四个字节来表示一个字符，这样我们就可以组合出21亿个不同的字符出来（最高位有其他用途），这大概可以用到银河联邦成立那一天吧！</p><p>UNICODE 来到时，一起到来的还有计算机网络的兴起，UNICODE 如何在网络上传输也是一个必须考虑的问题，于是面向传输的众多 UTF（UCS<br>Transfer<br>Format）标准出现了，顾名思义，UTF8就是每次8个位传输数据，而UTF16就是每次16个位，只不过为了传输时的可靠性，从UNICODE到<br>UTF时并不是直接的对应，而是要过一些算法和规则来转换。</p><p>受到过网络编程加持的计算机僧侣们都知道，在网络里传递信息时有一个很重要的问题，就是对于数据高低位的解读方式，一些计算机是采用低位先发送的方法，例如我们PC机<br>采用的 INTEL 架构；而另一些是采用高位先发送的方式。在网络中交换数据时，为了核对双方对于高低位的认识是否是一致的，采用了一种很简便的方法，就是在文本流<br>的开始时向对方发送一个标志符——如果之后的文本是高位在位，那就发送”FEFF”，反之，则发送”FFFE”。不信你可以用二进制方式打开一个UTF-<br>X格式的文件，看看开头两个字节是不是这两个字节？</p><p>下面是Unicode和UTF-8转换的规则</p><blockquote><p>Unicode</p></blockquote><blockquote></blockquote><blockquote><p>UTF-8</p></blockquote><blockquote></blockquote><blockquote><p>0000 - 007F</p></blockquote><blockquote></blockquote><blockquote><p>0xxxxxxx</p></blockquote><blockquote></blockquote><blockquote><p>0080 - 07FF</p></blockquote><blockquote></blockquote><blockquote><p>110xxxxx 10xxxxxx</p></blockquote><blockquote></blockquote><blockquote><p>0800 - FFFF</p></blockquote><blockquote></blockquote><blockquote><p>1110xxxx 10xxxxxx 10xxxxxx</p></blockquote><p>例如”汉”字的Unicode编码是6C49。6C49在0800-FFFF之间，所以要用3字节模板：1110xxxx 10xxxxxx<br>10xxxxxx。将6C49写成二进制是：0110 1100 0100 1001，将这个比特流按三字节模板的分段方法分为0110 110001<br>001001，依次代替模板中的x，得到：1110-0110 10-110001 10-001001，即E6 B1 89，这就是其UTF8的编码。</p><p>讲到这里，我们再顺便说说一个很著名的奇怪现象：当你在 windows 的记事本里新建一个文件，输入”联通”两个字之后，保存，关闭，然后再次打开，你会发现这两<br>个字已经消失了，代之的是几个乱码！呵呵，有人说这就是联通之所以拼不过移动的原因。</p><p>其实这是因为GB2312编码与UTF8编码产生了编码冲撞的原因。</p><p>当一个软件打开一个文本时，它要做的第一件事是决定这个文本究竟是使用哪种字符集的哪种编码保存的。软件一般采用三种方式来决定文本的字符集和编码：</p><p>检测文件头标识，提示用户选择，根据一定的规则猜测</p><p>最标准的途径是检测文本最开头的几个字节，开头字节 Charset/encoding,如下表：</p><blockquote><p>EF BB BF UTF-8</p></blockquote><blockquote></blockquote><blockquote><p>FE FF UTF-16/UCS-2, little endian</p></blockquote><blockquote></blockquote><blockquote><p>FF FE UTF-16/UCS-2, big endian</p></blockquote><blockquote></blockquote><blockquote><p>FF FE 00 00 UTF-32/UCS-4, little endian.</p></blockquote><blockquote></blockquote><blockquote><p>00 00 FE FF UTF-32/UCS-4, big-endian.</p></blockquote><p>当你新建一个文本文件时，记事本的编码默认是ANSI（代表系统默认编码，在中文系统中一般是GB系列编码）,<br>如果你在ANSI的编码输入汉字，那么他实际就是GB系列的编码方式，在这种编码下，”联通”的内码是：</p><blockquote><p>c1 1100 0001</p></blockquote><blockquote></blockquote><blockquote><p>aa 1010 1010</p></blockquote><blockquote></blockquote><blockquote><p>cd 1100 1101</p></blockquote><blockquote></blockquote><blockquote><p>a8 1010 1000</p></blockquote><p>注意到了吗？第一二个字节、第三四个字节的起始部分的都是”110”和”10”，正好与UTF8规则里的两字节模板是一致的，于是当我们再次打开记事本时，记事本就误<br>认为这是一个UTF8编码的文件，让我们把第一个字节的110和第二个字节的10去掉，我们就得到了”00001<br>101010”，再把各位对齐，补上前导的0，就得到了”0000 0000 0110 1010”，不好意思，这是UNICODE的006A，也就是小写的字母”j<br>“，而之后的两字节用UTF8解码之后是0368，这个字符什么也不是。这就是只有”联通”两个字的文件没有办法在记事本里正常显示的原因。</p><p>而如果你在”联通”之后多输入几个字，其他的字的编码不见得又恰好是110和10开始的字节，这样再次打开时，记事本就不会坚持这是一个utf8编码的文件，而会用A<br>NSI的方式解读之，这时乱码又不</p>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++实现大数除法</title>
    <link href="/posts/38656.html"/>
    <url>/posts/38656.html</url>
    
    <content type="html"><![CDATA[<p>** _ 题外话 _ **</p><blockquote><p>大数除法无疑是大数操作里最麻烦的一项，写大数不实现除法无异于画龙无鳞。</p></blockquote><p>** _ 思路 _ **</p><blockquote><p>最原始的，脑子最容易冒出来的思路，是一下一下的减，看能累计减多少次，最后的总次数就是结果，但这样的效率实在太慢。但我们可以一次性减去<br>除数的1，10，100，1000倍，只要它在当前倍数下比被除数小。<br>例如 1210 3 ，121大于300，我们直接剪去300，给结果加100，这样的话，减的次数会大大减小。<br>基本的思想就是这样，具体细节见代码，这里不再赘述</p></blockquote><p>** _ 进一步优化的方案 _ **</p><blockquote><p>上文所述，时间复杂度最坏情况是 9(n-m)*m (解的最坏位数为n-m位，每一位的解最多要减9次，每剪一次需要O(m))<br>当n,m为万级时，效率仍不尽人意。看大牛代码，发现有这样一个优化的方案。<br>我们正常用数组来表式大数时，是按照10进制来保存的，我们可以用比如10000来保存，那么长度为n的大数，长度就变为n/4<br>时间复杂度为原来的1/8</p></blockquote><p>** _ 代码(未优化) _ **</p><pre><code class="hljs">#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;math.h&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;string.h&gt;#include &lt;set&gt;#include &lt;stack&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;const int N = 100009;struct Node&#123;    int d[N];    int len;    Node() &#123;memset(d, 0, sizeof(d));len=1;&#125;    Node(char *s)    &#123;        memset(d, 0, sizeof(d));        len = strlen(s);        int i = 0;        while(s[i] != &#39;\0&#39;)        &#123;            d[len-i-1] = s[i] - &#39;0&#39;;            ++i;        &#125;    &#125;    int cmp(const Node &amp;t)    &#123;        int l = this-&gt;len - t.len;        if(l &lt; 0)            return -1;        int i;        for(i=t.len-1;i&gt;=0;i--)        &#123;            if(this-&gt;d[i+l] &lt; t.d[i])                break;            else if(this-&gt;d[i+l] &gt; t.d[i])            &#123;                return l;            &#125;        &#125;        if(i &lt; 0)            return l;        return l-1;    &#125;    void change(int pos)    &#123;        this-&gt;d[pos] += 1;        int i = pos;        while(this-&gt;d[i] &gt; 9)        &#123;            this-&gt;d[i] -= 10;            this-&gt;d[i+1]++;            ++i;        &#125;        if(i+1 &gt; this-&gt;len)            this-&gt;len = i+1;    &#125;    Node operator / (const Node &amp;t)    &#123;        Node ans;        while(1)        &#123;            int p = this-&gt;cmp(t);            if(p == -1)                break;            else            &#123;                ans.change(p);                for(int i=0;i&lt;t.len;i++)                &#123;                    this-&gt;d[i+p+1]--;                    this-&gt;d[i+p] = this-&gt;d[i+p]+10-t.d[i];                    if(this-&gt;d[i+p] &gt; 9)                    &#123;                        this-&gt;d[i+p] -= 10;                        this-&gt;d[i+1+p]++;                    &#125;                &#125;                while(this-&gt;len &gt; 1 &amp;&amp; this-&gt;d[this-&gt;len - 1] == 0)                    this-&gt;len--;            &#125;        &#125;        return ans;    &#125;&#125;;char str[N];int main()&#123;    scanf(&quot;%s&quot;,str);    Node a(str);    scanf(&quot;%s&quot;,str);    Node b(str);    Node ans = a / b;    for(int i=ans.len-1;i&gt;=0;i--)//商        printf(&quot;%d&quot;,ans.d[i]);    printf(&quot;\n&quot;);    for(int i=a.len-1;i&gt;=0;i--)//模        printf(&quot;%d&quot;,a.d[i]);    printf(&quot;\n&quot;);    return 0;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高精度</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c++实现大数乘法</title>
    <link href="/posts/32341.html"/>
    <url>/posts/32341.html</url>
    
    <content type="html"><![CDATA[<p>** _ 思路 _ **</p><blockquote><p>第i位数乘第j位数，乘积是第i+j位数(从0开始)<br>如123＊456<br>乘积各位数为<br>个位 3＊6<br>十位 2＊6 ＋ 3＊5<br>百位 2＊5 ＋ 1＊6 ＋ 3＊4<br>千位 1＊5 ＋ 2＊4<br>万位 1＊4<br>然后从后往前，取余更新。</p></blockquote><p>** _ 代码 _ **</p><pre><code class="hljs">#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;math.h&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;string.h&gt;#include &lt;set&gt;#include &lt;stack&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;struct Node&#123;    int d[2009];    int len;    Node() &#123;memset(d, 0, sizeof(d));&#125;    Node(char *s)    &#123;        memset(d, 0, sizeof(d));        int i = 0;        while(s[i] != &#39;\0&#39;)        &#123;            d[i] = s[i] - &#39;0&#39;;            ++i;        &#125;        len = i;        for(int i=0,j=len-1; i&lt;j; i++,j--)            swap(d[i],d[j]);    &#125;    Node operator * (const Node &amp;t) const    &#123;        Node ans;        for(int i=0;i&lt;this-&gt;len;i++)        &#123;            for(int j=0;j&lt;t.len;j++)            &#123;                ans.d[i+j] += this-&gt;d[i] * t.d[j];            &#125;        &#125;        for(int i=0;i&lt;this-&gt;len+t.len;i++)        &#123;            ans.d[i+1] += ans.d[i] / 10;            ans.d[i] %= 10;        &#125;        int len = this-&gt;len+t.len;        while(len &gt; 1 &amp;&amp; ans.d[len-1] == 0)            len--;        ans.len = len;        return ans;    &#125;&#125;;char str[1009];int main()&#123;    scanf(&quot;%s&quot;,str);    Node a(str);    scanf(&quot;%s&quot;,str);    Node b(str);    Node ans = a * b;    for(int i=ans.len-1; i&gt;=0; i--)        printf(&quot;%d&quot;,ans.d[i]);    printf(&quot;\n&quot;);    return 0;&#125;</code></pre><blockquote><p>Case 1:<br>4038<br>5255<br>21219690</p></blockquote><blockquote></blockquote><blockquote><p>Case 2:<br>123456<br>234567<br>28958703552</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高精度</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c++实现大数加法(含负数)</title>
    <link href="/posts/32589.html"/>
    <url>/posts/32589.html</url>
    
    <content type="html"><![CDATA[<p>** _ 题外话 _ **</p><blockquote><p>一直想好好的把所有大数操作好好敲一遍，都止于惰性，碰到一个要用到大数的题，索性就由此开始吧。<br>大数加法写过太多次了，含负数的第一次写，用运算符重载的形式实现，挺有意思。</p></blockquote><p>** _ 思路 _ **</p><blockquote><p>当两数符号相同时，相加即可，重点内容结果符号不变。<br>不同时，需要对两数的绝对值进行比较，结果符号与绝对值大的数符号相同，然后用大的减去小的。</p></blockquote><p>** _ 代码 _ **</p><pre><code class="hljs">#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;math.h&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;string.h&gt;#include &lt;set&gt;#include &lt;stack&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;struct Node&#123;    int d[10009];    int len;    bool f;    Node() &#123;memset(d, 0, sizeof(d));&#125;    Node(char *s)    &#123;        memset(d, 0, sizeof(d));        if(s[0] == &#39;-&#39;)            f = 1, s++;        else            f = 0;        int i = 0;        while(s[i] != &#39;\0&#39;)        &#123;            d[i] = s[i] - &#39;0&#39;;            ++i;        &#125;        len = i;        for(int i=0,j=len-1; i&lt;j; i++,j--)            swap(d[i],d[j]);    &#125;    bool operator &lt; (const Node &amp;t) const    &#123;        if(this-&gt;len == t.len)        &#123;            for(int i=t.len-1; i&gt;=0; i--)            &#123;                if(this-&gt;d[i] &lt; t.d[i])                    return true;                else if(this-&gt;d[i] &gt; t.d[i])                    return false;            &#125;        &#125;        return this-&gt;len &lt;= t.len;    &#125;    Node operator + (const Node &amp;t) const    &#123;        Node ans;        if(t.f == this-&gt;f)//符号相同        &#123;            ans.f = this-&gt;f;            int len = max(t.len, this-&gt;len);            ans.len = len;            for(int i=0;i&lt;len;i++)            &#123;                ans.d[i] += this-&gt;d[i] + t.d[i];                ans.d[i+1] += ans.d[i] / 10;                ans.d[i] %= 10;            &#125;            if(ans.d[len] != 0)                ans.len++;            while(ans.len &gt; 1 &amp;&amp; ans.d[ans.len-1] == 0)                ans.len--;        &#125;        else        &#123;            if(t &lt; (*this))                ans = (*this) - t;            else                ans = t - (*this);        &#125;        return ans;    &#125;    Node operator - (const Node &amp;t) const    &#123;        Node ans;        ans.f = this-&gt;f;        int len = this-&gt;len;        ans.len = len;        for(int i=0;i&lt;len;i++)        &#123;            ans.d[i] += this-&gt;d[i] - t.d[i];            if(ans.d[i] &lt; 0)            &#123;                ans.d[i] += 10;                ans.d[i+1]--;            &#125;        &#125;        while(ans.len &gt; 1 &amp;&amp; ans.d[ans.len-1] == 0)            ans.len--;        return ans;    &#125;&#125;;char str[10009];int main()&#123;    cin&gt;&gt;str;    Node a(str);    cin&gt;&gt;str;    Node b(str);    Node ans = a + b;    if(ans.f)        cout&lt;&lt;&quot;-&quot;;    for(int i=ans.len-1; i&gt;=0; i--)        cout&lt;&lt;ans.d[i];    return 0;&#125;</code></pre><blockquote><p>** _ Case 1: _ **<br>68932147586<br>468711654886<br>537643802472</p></blockquote><blockquote></blockquote><blockquote><p>** _ Case 2: _ **<br>-324234<br>1212531<br>888297</p></blockquote><blockquote></blockquote><blockquote><p>** _ Case 3: _ **<br>-2395235<br>-988973434<br>-991368669</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高精度</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>51Nod 1454 升排列</title>
    <link href="/posts/30448.html"/>
    <url>/posts/30448.html</url>
    
    <content type="html"><![CDATA[<p><a href="http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1454"> 1454 升排列</a><br><img src="http://www.51nod.com/images/icon/ok.png"></p><p>题目来源： <a href="http://codeforces.com/"> CodeForces </a></p><p>基准时间限制：1 秒 空间限制：131072 KB 分值: 80 <a href="http://www.51nod.com/onlineJudge/problemList.html#!groupId=6"> 难度：5级算法题</a></p><p><img src="http://www.51nod.com/images/icon/star.png"> 收藏</p><p><img src="http://www.51nod.com/images/icon/plus.png"> 关注</p><p>定义长度为n的排列为数组  p  =  [  p  1  ,  p  2  ,  .  .  .  ,  p  n  ]<br>，这个数组包含n个整数，他们都在1到n之间，并且两两不同。我们说这个排列把1映射到  p  1  ，2映射到  p  2  ，依此类推。</p><p>下面介绍一下排列的循环表示。一个环是一串数字，这一串数字中每一个数字被映射到下一个数字，最后一个数字被映射到第一个数字。排列p的循环表示是由一系列的环构成的<br>。比如排列p = [4, 1, 6, 2, 5, 3]的循环表示是<br>(142)(36)(5)，因为1映射到4，4映射到2，2映射到1，3和6相互映射，5是自己映射自己。</p><p>排列可能会有多个循环表示，所以这儿再定义一个标准的循环表示。第一步，把每一个环中的数字按照降序排列。然后把每一个环按照环中最大的数字升序排列。对于上面的例子<br>， [4, 1, 6, 2, 5, 3]的标准循环表示是(421)(5)(63)。</p><p>把环旁边的圆括号拿掉之后我们会得到另外一个排列，比如[4, 1, 6, 2, 5, 3] 会得到 [4, 2, 1, 5, 6, 3]。</p><p>一些排列经过上述的变换之后，排列是不变的。现在我们把所有长度为n的满足这样的条件的排列按照字典序排列。请你找出排在第k位的是什么排列。</p><p>样例解释：标准循环表示为(1)(32)(4)，拿掉括号之后就是[1 3 2 4]。第一个排列是 [1, 2, 3, 4]，第二个是[1, 2, 4, 3]。</p><p>Input</p><pre><code class="hljs">单组测试数据。第一行包含两个整数 n, k (1 ≤ n ≤ 50, 1 ≤ k ≤ min&#123;10^18,L&#125;，L是符合条件的排列数目。</code></pre><p>Output</p><pre><code class="hljs">输出n个以空格分开的数字，代表第k个排列。</code></pre><p>Input示例</p><pre><code class="hljs">4 3</code></pre><p>Output示例</p><pre><code class="hljs">1 3 2 4</code></pre><p>_ ** 思路 ** _</p><p>交换之后排列不变的序列只存在两种映射关系</p><p>** (1) i的映射为i+1 &amp;&amp; i+1的映射为 i  **</p><p>** (2)  i的映射为i  **</p><p>也就是说，只能  ** 交换相邻的两个数 **</p><p>而题目要求字典序排列第k个符合上述要求的序列，想象一下，字典序由小到大也就是  先右后左  的交换，</p><p>可以理解为类似冒泡的从后往前冒，区别是会有多个泡泡</p><p>代码</p><pre><code class="hljs">#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;math.h&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;string.h&gt;#include &lt;set&gt;#include &lt;stack&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;long long f[55];int ans[55];int main()&#123;    long long n, k;    cin&gt;&gt;n&gt;&gt;k;    f[n] = 1;    f[n+1] = 0;    for(int i=n-1;i&gt;=0;i--)    &#123;        f[i] = f[i+1] + f[i+2];        ans[i] = i+1;    &#125;    for(int i=0;i&lt;n-1 &amp;&amp; k;i++)    &#123;        if(k &gt; f[i+1])        &#123;            k -= f[i+1];            swap(ans[i], ans[i+1]);            ++i;        &#125;    &#125;    for(int i=0;i&lt;n;i++)        cout&lt;&lt;ans[i]&lt;&lt;&quot; &quot;;    cout&lt;&lt;endl;    return 0;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>模拟</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>51Nod 1191 消灭兔子 (贪心+优先队列)</title>
    <link href="/posts/14780.html"/>
    <url>/posts/14780.html</url>
    
    <content type="html"><![CDATA[<p>** _ 题目链接 _ ** ： <a href="http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1191"> 消灭兔子 </a></p><p>** _ 题目大意 _ **</p><blockquote><p>n个兔子，每个兔子都有一个血量b[i]<br>m种箭(每种各一支)，每种箭都有伤害值d[i]和价格p[i]<br>每个兔子只能被射一次，伤害值大于血量则死，每种箭只能用一次<br>问杀死所有兔子需要的最小价格为多少，若不能杀死，则No Solution<br>m,n小于50000)</p></blockquote><p>** _ 思路 _ **</p><blockquote><p>典型的贪心，每个兔子只能射一次，所以只能用伤害值大于其血量的箭，在此前提下，箭越便宜越好，故对兔子血量升序排列，箭对伤害值升序排列。<br>若i小于j 则第i支箭可以杀死的兔子，第j支箭也一定能杀死，而若j的价格小于i，就应该用j，所以用优先数列维护即可。</p></blockquote><p>** _ 代码 _ **</p><pre><code class="hljs">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;functional&gt;#include&lt;vector&gt;using namespace std;const int N = 50009;pair&lt;int, int&gt; p[N];int b[N];int main()&#123;    int n,m;    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);    if(m &lt; n)    &#123;        printf(&quot;No Solution\n&quot;);        return 0;    &#125;    for(int i=0;i&lt;n;i++)        scanf(&quot;%d&quot;,&amp;b[i]);    for(int i=0;i&lt;m;i++)        scanf(&quot;%d%d&quot;,&amp;p[i].first, &amp;p[i].second);    sort(b, b+n);    sort(p, p+m);    priority_queue&lt;int&gt; q;    int i = 0, j = 0;    long long ans = 0;    while(j &lt; m)    &#123;        ans += p[j].second;        q.push(p[j].second);        if(p[j].first &gt;= b[i] &amp;&amp; i &lt; n)        &#123;            ++i;++j;        &#125;        else        &#123;            ans -= q.top();            q.pop();            ++j;        &#125;    &#125;    if(i &lt; n)        printf(&quot;No Solution\n&quot;);    else        printf(&quot;%lld\n&quot;,ans);    return 0;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>51Nod 1163 最高的奖励(贪心+优先队列 并差集)</title>
    <link href="/posts/11351.html"/>
    <url>/posts/11351.html</url>
    
    <content type="html"><![CDATA[<p>题目链接： <a href="http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1163"> 最高的奖励</a></p><p>** _ 题目大意 _ **</p><blockquote><p>有N个任务，每个任务有一个最晚结束时间以及一个对应的奖励。在结束时间之前完成该任务，就可以获得对应的奖励。完成每一个任务所需的时间都是1个单位时间。有时<br>候完成所有任务是不可能的，因为时间上可能会有冲突，这需要你来取舍。求能够获得的最高奖励。<br>Input<br>第1行：一个数N，表示任务的数量(2 &lt;= N &lt;= 50000)<br>第2 - N + 1行，每行2个数，中间用空格分隔，表示任务的最晚结束时间E[i]以及对应的奖励W[i]。(1 &lt;= E[i] &lt;= 10^9，1 &lt;=<br>W[i] &lt;= 10^9)<br>Output<br>输出能够获得的最高奖励。</p></blockquote><p>** _ 思路1 贪心 _ **</p><blockquote><p>用贪心思想，从0开始，每完成一件任务，消耗时间为1，按最晚时间递增，第n个任务如果最晚时间大于已消耗掉时间量，则可算入总和，若不大于已耗时间量，则可以替<br>换掉总和里最小奖励的一个任务(如果当前任务的奖励更多的话)。<br>这个过程可以用堆维护。nlog(n);</p></blockquote><pre><code class="hljs">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;functional&gt;#include&lt;vector&gt;using namespace std;struct Node&#123;    int l, v;&#125;;Node node[50009];bool cmp(const Node &amp;a, const Node &amp;b)&#123;    return a.l &lt; b.l;&#125;int main()&#123;    int n;    scanf(&quot;%d&quot;,&amp;n);    priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; q;    for(int i=0;i&lt;n;i++)    &#123;        scanf(&quot;%d%d&quot;,&amp;node[i].l, &amp;node[i].v);    &#125;    sort(node, node+n, cmp);    long long ans = 0;    for(int i=0;i&lt;n;i++)    &#123;        int num = node[i].v;        if(node[i].l &gt; q.size())        &#123;            ans += num;            q.push(num);        &#125;        else        &#123;            ans += num;            q.push(num);            ans -= q.top();            q.pop();        &#125;    &#125;    printf(&quot;%lld\n&quot;,ans);&#125;</code></pre><p>** _ 思路2 并差集 _ **</p><blockquote><p>因为每个任务完成需要的时间都是1，即每个点都可以完成一次任务，所以可以使用并差集维护当前未使用的时间点，f[x] =<br>a;表示最晚时间为x的任务可以在a点完成<br>先按奖励降序排列，然后遍历即可，若有可完成任务的时间节点，则完成此任务，奖励算入总和。<br>O(n*a(n)) a(n)为并差集的查找过程 接近于1</p></blockquote><pre><code class="hljs">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;functional&gt;#include&lt;vector&gt;using namespace std;struct Node&#123;    int l, v;&#125;;Node node[50009];int f[50009];bool cmp(const Node &amp;a, const Node &amp;b)&#123;    return a.v &gt; b.v;&#125;int find(int x)&#123;    if(x &lt;= 0)        return -1;    if(x == f[x])        return f[x] = x-1;    return f[x] = find(f[x]);&#125;int main()&#123;    int n;    scanf(&quot;%d&quot;,&amp;n);    for(int i=0;i&lt;n;i++)    &#123;        scanf(&quot;%d%d&quot;,&amp;node[i].l, &amp;node[i].v);        if(node[i].l &gt; n) node[i].l = n;        f[i] = i;    &#125;    f[n] = n;    sort(node, node+n, cmp);    long long ans = 0;    for(int i=0;i&lt;n;i++)    &#123;        if(find(node[i].l) &gt;= 0)            ans += node[i].v;    &#125;    printf(&quot;%lld\n&quot;,ans);&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心</tag>
      
      <tag>并差集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>51Nod 1376 最长递增子序列的数量(dp+树状数组)</title>
    <link href="/posts/63520.html"/>
    <url>/posts/63520.html</url>
    
    <content type="html"><![CDATA[<p><a href="http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1376"> 题目链接 </a></p><p>最长递增子序列的题做过不少，让求数量的还是第一次，O(n^2)的代码很好写，但数据范围50000，故无情超时，想了很久，总算有所得。</p><p>** _ 时间: O(nlog(n)) 空间: O(2*n) _ **</p><p>** _ 思路 _ **<br>O(n^2)的思路中，每次求以第i个数结尾的最大长度和记录总数都要对前i－1个数进行遍历比较，如果能把这个比较过程转化为对前i项对求和，就可以用树状数组或线<br>段数进行求和优化了。</p><pre><code class="hljs">    重载＋，按照题目需求重新定义求和意义    Node operator + (const Node &amp;t) const    &#123;        if(this-&gt;len &lt; t.len)            return t;        if(this-&gt;len &gt; t.len)            return (*this);        return Node(t.len, (this-&gt;cnt + t.cnt) % MOD);</code></pre><p>于是有 dp(i) = sum(dp(0, i-1)) + 1;<br>为什么可以这样呢。我们对序列的数从小到大进行操作，当前数的值等于原有顺序下前面所有数的求和，因为前面比它大的数都还为0尚未更新，不会造成影响，而已更新的数都<br>是比它小的，所以它的值就是前面的求和结果再加1。</p><p>** _ 代码 _ **</p><pre><code class="hljs">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int MAX = 50005;const int MOD = 1000000007;struct Node&#123;    int len, cnt;    Node()&#123;&#125;    Node(int len, int cnt): len(len), cnt(cnt)&#123;&#125;    Node operator + (const Node &amp;t) const    &#123;        if(this-&gt;len &lt; t.len)            return t;        if(this-&gt;len &gt; t.len)            return (*this);        return Node(t.len, (this-&gt;cnt + t.cnt) % MOD);    &#125;&#125;;struct Num&#123;    int num, pos;&#125;;Node c[MAX];Num d[MAX];bool cmp(Num &amp;a, Num &amp;b)&#123;    if(a.num == b.num)        return a.pos &gt; b.pos;    return a.num &lt; b.num;&#125;void update(Node a,int pos, int n)&#123;    for(int i = pos; i &lt;= n; i += i&amp;(-i))        c[i] = c[i] + a;&#125;Node query(int pos)&#123;    Node ans(0, 0);    for(int i = pos-1; i &gt; 0; i -= i&amp;(-i))        ans = ans + c[i];    return ans;&#125;int main()&#123;    int n;    scanf(&quot;%d&quot;, &amp;n);    for(int i = 0; i &lt; n; ++i)    &#123;        scanf(&quot;%d&quot;, &amp;d[i].num);        d[i].pos = i+1;    &#125;    sort(d, d+n, cmp);    Node ans(0, 0);    for(int i = 0; i &lt; n; ++i)    &#123;        Node t = query(d[i].pos);        if(++t.len == 1) t.cnt = 1;        ans = ans + t;        update(t, d[i].pos, n);    &#125;    printf(&quot;%d\n&quot;, ans.cnt);    return 0;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>初学A*算法求解静态地图的最短路径</title>
    <link href="/posts/38319.html"/>
    <url>/posts/38319.html</url>
    
    <content type="html"><![CDATA[<p>以前所接触过的最短路径算法是dijkstra或floyd之类的，都是在已知每两点之间距离的情况下求最短路的。</p><p>那么想一下这样的案例</p><blockquote><p>给你一个地图，类似于迷宫一样，中间有些障碍物，再给定起点终点，求该两点间最短路，显然，上述两种算法就不适用了，因为提到的迷宫，我们可能会很容易想到广搜b<br>fs，但一次bfs下来实际上求出了起点到所有点的最短路径，但我们只想知道它与终点间的最短路径，也就是说这个方案里有很多冗余的操作。</p></blockquote><p>说到这里，该步入正题，介绍A*算法。</p><blockquote><p>A<em>算法；A</em>（A-Star)算法是一种静态路网中求解最短路径最有效的直接搜索方法。估价值与实际值越接近，估价函数取得就越好。(取自百度百科)</p></blockquote><p>何谓直接搜索方法，即 ** _ 不进行任何预处理直接进行搜索的方法 _ ** 。<br>那么它为何可以称为最有效的直接搜索方法呢，我们看到上文说到一个估价值与估价函数。<br>所以有这么一个式子</p><blockquote><p>** f(n) = g(n) + h(n) **</p></blockquote><p>先记住这个式子，在讨论这个式子之前，先谈点题外话。<br>我们都接触过 ** _ 贪心思想 _ ** ，即 ** _ 在对问题求解时，总是做出在当前看来是最好的选择。 _ **<br>从起点开始，它可走的地方是周围的8个点(最多)，平常广搜时多个可能是平等对待，全部考虑。</p><p>那么？我们可不可以运用贪心的思想从8个点中选出一个最有可能达到最短路的点来优先进行操作呢？</p><p>当然可以，这样我们就是 ** 有针对性的搜索 ** ，而不是 ** 盲目搜索 ** 了。</p><p>有的道友可能会说了， ** 这样贪心下来求出的只能是接近于最优解的相对最优解，并不能保证一定最优 ** ，没错，事实的确是这样。<br>那么这样就行不通了，因为我们的目的是很明确的，要的是最短路径。</p><p>但是往常的贪心算法都是 ** 选取当前状态下最好的选择，至于次好选择等等全部就丢掉了 **<br>，那如果我们仍然保留这些选择，仍与后来的可能进行比较呢，这样就保证最后的解一定是最优解了。</p><p>如何将所有可能性都保留下来继续参与后来的比较呢， ** _ 优先队列 _ ** 是一个不错的法子。<br>1. 从A开始，将其周围可走且未标记的点，全部加入队列，然后标记A点<br>2. 从队列中选取优先度最高的点B<br>3. 对B重复1操作，直到到达终点为止</p><p>但优先度如果获得呢，现在我们回到这个式子</p><blockquote><p>** f(n) = g(n) + h(n) **<br>g(n)为从起点到点n所花费的代价值<br>h(n)为点n到终点所花费代价的估价值<br>两者之和 f(n)就是点n的优先值</p></blockquote><p>例如，对几何地图进行求解时，可以将从起点到点n走的步数作为g(n)，将点n到终点的几何距离作为h(n)估价值，那么此时，f(n)的值越小，优先度越高。</p><p>下面贴代码</p><pre><code class="hljs">#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#include&lt;math.h&gt;#include&lt;queue&gt;#include&lt;functional&gt;#include&lt;set&gt;using namespace std;const int N = 10009;//地图范围int v[N][N] = &#123;&#125;;//记录地图int dx[] = &#123;1,1,1,0,0,-1,-1,-1&#125;;//8个方向int dy[] = &#123;1,0,-1,1,-1,1,-1,0&#125;;int f[N*N];//对当前点进行标记，同时记录上一个位置的坐标struct Node&#123;    int x,y,f,g;//坐标与权值&#125;;struct Nodecmp//优先队列比较函数&#123;    bool operator() (const Node &amp;a, const Node &amp;b)    &#123;        return a.f &gt; b.f;    &#125;&#125;;int leng(Node a, Node b)//求点与终点的几何长度&#123;    return sqrt((a.x - b.x)*(a.x - b.x)                + (a.y - b.y)*(a.y - b.y));&#125;void print(int nid, int n)//输出最短路径&#123;    if(nid == -1)        return;    print(f[nid],n);    printf(&quot;%d %d\n&quot;,(nid-1)/n, nid-(nid-1)/n*n);&#125;bool a_start(Node s, Node e, int n)&#123;    if(!v[e.x][e.y])//终点不可达        return false;    memset(f, 0, sizeof(f));    priority_queue&lt;Node, vector&lt;Node&gt;, Nodecmp&gt; q;    int eid = e.x * n + e.y;    f[s.x * n + s.y] = -1;//二维转一维进行标记，便于操作    while(!q.empty())    &#123;        Node now = q.top();        q.pop();//出队        int nid = now.x * n + now.y;        if(nid == eid)//判断是否为终点        &#123;            print(nid, n);            return true;        &#125;        for(int i=0;i&lt;8;i++)//遍历8个方向        &#123;            Node t;            t.x = dx[i] + now.x;            t.y = dy[i] + now.y;            int tid = t.x * n + t.y;            if(v[t.x][t.y] &amp;&amp; f[tid] == 0)            &#123;//符合条件便标记并入队                f[tid] = nid;                t.g = now.g + 1;                t.f = t.g + leng(t, e);                q.push(t);            &#125;        &#125;    &#125;    return false;&#125;int main()&#123;    int n;    Node s,e;    s.g = 0;    cin&gt;&gt;n&gt;&gt;s.x&gt;&gt;s.y&gt;&gt;e.x&gt;&gt;e.y;    for(int i=1;i&lt;=n;++i)        for(int j=1;j&lt;=n;++j)            cin&gt;&gt;v[i][j];    if(!a_start(s,e,n))        cout&lt;&lt;&quot;无法到达&quot;&lt;&lt;endl;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>51Nod 1022 石子归并 V2 (划分型dp四边形不等式优化)</title>
    <link href="/posts/48436.html"/>
    <url>/posts/48436.html</url>
    
    <content type="html"><![CDATA[<p>石子归并以前做过好几次，是经典划分型dp题之一，一直用的O(n3)的正常dp方法，也从未想过该怎么去优化它。</p><p>直到昨天做这道题，n的范围由往常的100改为了1000，老方法<br>一直超时，苦不堪言，搜到有个四边形不等式的优化方法，看帖子，画式子，拉着学长帮忙推导，总算是大概弄明白了一点。</p><p>dp(i,j) = min(dp(i,k)+  dp(k+1,j)  ) + w(i,j);(i &lt; j, i&lt;=k&lt;j)</p><p>dp(i,j)  = MAX;(i&gt;j)</p><p>dp(i,j)  = 0;(i=j)</p><p>上式在  动态规划的状态转移方程中是很常见的，对于上式中的w(i,j)<br>如果符合  w(i<code>,j) &lt;= w(i,j</code>) i&lt;i<code>&lt;j&lt;j</code>  那么我们称  ** _ 函数w满足  关于区间包含的单调性  _ **<br>如果符合  w(i,j)+w(i<code>,j</code>) &lt;= w(i<code>,j)+w(i,j</code>)  那么我们称  ** _ 函数w满足  四边形不等式  _ **</p><p>那么，有两个定理：(图片取自<a href="http://blog.csdn.net/shiwei408/article/details/8791011">http://blog.csdn.net/shiwei408/article/details/8791011</a>)</p><p><img src=""></p><p><img src="http://img.my.csdn.net/uploads/201304/11/1365694881_8364.jpg"></p><p>证明可见 [ 动态规划加速原理之四边形不等式 ](<a href="http://wenku.baidu.com/link?url=fAi5jF00X4jQ-UfbH9YKA">http://wenku.baidu.com/link?url=fAi5jF00X4jQ-UfbH9YKA</a><br>btUK688rOmjIXX5cU3IQjplOj9VKyllGPpBwt_E5wlONNVPw7GhkmsmFHcQGvr02gHT21OtLp78rHH<br>zqPkBRgO)</p><p>显然，由上述定理，本来我们的第三重循环k的范围是由i&lt;=k&lt;j</p><p>现在可以缩至s[i][j-1]&lt;=k&lt;=s[i+1][j]，一下就从O(n3)优化至O(n2)了;</p><p>下面看题</p><p><a href="http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1022"> 1022 石子归并 V2</a><br><img src="http://file.51nod.com/images/icon/ok.png"></p><p>基准时间限制：1 秒 空间限制：131072 KB 分值: 160 <a href="http://www.51nod.com/onlineJudge/problemList.html#!groupId=7"> 难度：6级算法题</a></p><p>N堆石子摆成一个环。现要将石子有次序地合并成一堆。规定每次只能选相邻的2堆石子合并成新的一堆，并将新的一堆石子数记为该次合并的代价。计算将N堆石子合并成一堆<br>的最小代价。</p><p>例如： 1 2 3 4，有不少合并方法</p><p>1 2 3 4 =&gt; 3 3 4(3) =&gt; 6 4(9) =&gt; 10(19)</p><p>1 2 3 4 =&gt; 1 5 4(5) =&gt; 1 9(14) =&gt; 10(24)</p><p>1 2 3 4 =&gt; 1 2 7(7) =&gt; 3 7(10) =&gt; 10(20)</p><p>括号里面为总代价可以看出，第一种方法的代价最低，现在给出n堆石子的数量，计算最小合并代价。</p><p>Input</p><pre><code class="hljs">第1行：N（2 &lt;= N &lt;= 1000)第2 - N + 1：N堆石子的数量（1 &lt;= A[i] &lt;= 10000)</code></pre><p>Output</p><pre><code class="hljs">输出最小合并代价</code></pre><p>Input示例</p><pre><code class="hljs">41234</code></pre><p>Output示例</p><pre><code class="hljs">19</code></pre><p>跟我们之前做过的石子归并有两个区别，一个是n的范围变为了1000，3重循环已无用，需要优化，上已道明。</p><p>另一个区别就是从往常的线型变为了环形，这个通常有三种方法可以处理。</p><p>1.  循环变量自增由 i++  改为 i = (i+1)%n   利用取余操作实现由n-1至0的迭代</p><p>2.  构造next数组，模拟链表指向</p><p>3.  将环扩展为一维线性   即 环变为 a[0],a[1],…a[n-1],a[n-2],…a[1],a[0]<br>注意扩展后数组长度为2*n-1(a[n-1]只有一次)</p><p>这里本人用的第三种方法，见代码</p><pre><code class="hljs">#include&lt;iostream&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;#include&lt;stdlib.h&gt;#include&lt;stdio.h&gt;using namespace std;const int N =  2009;int n,f[N][N]=&#123;0&#125;,a[N][N]=&#123;0&#125;;int s[N][N];int main()&#123;    memset(f,1,sizeof(f));    scanf(&quot;%d&quot;,&amp;n);    for(int i=0;i&lt;n;i++)    &#123;        scanf(&quot;%d&quot;,&amp;a[i][i]);        a[n+i][n+i] = a[i][i];    &#125;    for(int i=0;i&lt;n*2;i++)    &#123;        s[i][i] = i;        f[i][i] = 0;    &#125;    for(int i=0;i&lt;n*2-1;i++)        for(int j=i+1;j&lt;n*2-1;j++)          a[i][j] = a[i][j-1] + a[j][j];    for(int l=1;l&lt;n;l++)    &#123;        for(int i=0;i+l&lt;n*2-1;i++)        &#123;            int j = i+l;            for(int k=s[i][j-1];k&lt;=s[i+1][j];k++)            &#123;                if(f[i][j] &gt; a[i][j]+f[i][k]+f[k+1][j])                &#123;                    f[i][j] = a[i][j]+f[i][k]+f[k+1][j];                    s[i][j] = k;                &#125;            &#125;        &#125;    &#125;    int ans = f[0][n-1];    for(int i=1;i&lt;n;i++)        if(ans &gt; f[i][i+n-1])            ans = f[i][i+n-1];    printf(&quot;%d\n&quot;,ans);    return 0;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>51Nod 1459 迷宫游戏</title>
    <link href="/posts/38708.html"/>
    <url>/posts/38708.html</url>
    
    <content type="html"><![CDATA[<h3 id="题目链接：-迷宫游戏"><a href="#题目链接：-迷宫游戏" class="headerlink" title="题目链接： [ 迷宫游戏"></a>题目链接： [ 迷宫游戏</h3><p>](<a href="http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1459">http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1459</a>)</p><p>** _ 题目 _ **</p><blockquote><p>你来到一个迷宫前。该迷宫由若干个房间组成，每个房间都有一个得分，第一次进入这个房间，你就可以得到这个分数。还有若干双向道路连结这些房间，你沿着这些道路从<br>一个房间走到另外一个房间需要一些时间。游戏规定了你的起点和终点房间，你首要目标是从起点尽快到达终点，在满足首要目标的前提下，使得你的得分总和尽可能大。现在问<br>题来了，给定房间、道路、分数、起点和终点等全部信息，你能计算在尽快离开迷宫的前提下，你的最大得分是多少么？</p></blockquote><p>** _ Input _ **</p><blockquote><p>第一行4个整数n (&lt;=500), m, start, end。n表示房间的个数，房间编号从0到(n -<br>1)，m表示道路数,任意两个房间之间最多只有一条道路，start和end表示起点和终点房间的编号。<br>第二行包含n个空格分隔的正整数(不超过600)，表示进入每个房间你的得分。<br>再接下来m行，每行3个空格分隔的整数x, y, z (0&lt; z&lt;=200)表示道路,表示从房间x到房间y(双向)的道路,注意，最多只有一条道路连结两个房间,<br>你需要的时间为z。<br>输入保证从start到end至少有一条路径。</p></blockquote><p>** _ Output _ **</p><blockquote><p>一行，两个空格分隔的整数，第一个表示你最少需要的时间，第二个表示你在最少时间前提下可以获得的最大得分。</p></blockquote><p>** _ Input示例 _ **</p><blockquote><p>3 2 0 2<br>1 2 3<br>0 1 10<br>1 2 11</p></blockquote><p>** _ Output示例 _ **</p><blockquote><p>21 6</p></blockquote><p>** _ 思路 _ **</p><blockquote><p>dijkstra求单源最短路，特殊的地方在于，以往求最短路的判定条件只有长度，现在加上了分数，所以在条件判断上要考虑分数，同样的，在松弛步骤上也要对每个<br>点的权值(从起点到当前点路程最短分数最大时的分数值)进行更新。</p></blockquote><p>** _ 代码 _ **</p><pre><code class="hljs">#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;math.h&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;string.h&gt;#include &lt;set&gt;#include &lt;stack&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;const int MAX = 0x1f1f1f1f;int d[509];int g[509][509];int v[509];int dd[509];bool f[509] = &#123;&#125;;void dji(int n, int s, int e)&#123;    for(int i=0;i&lt;n;i++)    &#123;        v[i] = g[s][i];        dd[i] = d[i]+d[s];    &#125;    dd[s] -= d[s];    v[s] = 0;    f[s] = 1;    for(int k=1;k&lt;n;++k)    &#123;        int mi=-1, mmin = MAX, sc = -1;        for(int j=0;j&lt;n;j++)        &#123;            if(!f[j])            &#123;                if((v[j] == mmin &amp;&amp; dd[j] &gt; sc)                   || v[j] &lt; mmin)                &#123;                    sc = dd[j];                    mmin = v[j];                    mi = j;                &#125;            &#125;        &#125;        if(mi == -1)            break;        f[mi] = 1;        for(int i=0;i&lt;n;i++)        &#123;            if(v[i] &gt; mmin + g[mi][i])            &#123;                v[i] = mmin + g[mi][i];                dd[i] = sc + d[i];            &#125;            else if(v[i] == mmin + g[mi][i])            &#123;                dd[i] = max(dd[i], sc + d[i]);            &#125;        &#125;    &#125;    printf(&quot;%d %d\n&quot;,v[e], dd[e]);&#125;int main()&#123;    int n, m, s, e;    memset(g, 0x1f, sizeof(g));    scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;m,&amp;s,&amp;e);    for(int i=0;i&lt;n;i++)        scanf(&quot;%d&quot;,&amp;d[i]);    for(int i=0;i&lt;m;i++)    &#123;        int a,b,c;        scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);        g[a][b] = g[b][a] = c;    &#125;    dji(n,s,e);&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>最短路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kuangbin带你飞专题十二 基础DP1 G</title>
    <link href="/posts/58371.html"/>
    <url>/posts/58371.html</url>
    
    <content type="html"><![CDATA[<p>G -  免费馅饼</p><p>** Time Limit: ** 1000  MS ** Memory Limit: ** 32768  KB ** 64bit IO Format: ** %I64d &amp; %I64u</p><p>Submit  <a href="http://acm.hust.edu.cn/vjudge/contest/view.action?cid=68966#status//G/0"> Status</a> <a href="http://acm.hust.edu.cn/vjudge/problem/viewProblem.action?id=22018"><br>Practice  </a><br><a href="http://acm.hust.edu.cn/vjudge/problem/visitOriginUrl.action?id=22018"> HDU 1176</a></p><p>Description</p><p>都说天上不会掉馅饼，但有一天gameboy正走在回家的小径上，忽然天上掉下大把大把的馅饼。说来gameboy的人品实在是太好了，这馅饼别处都不掉，就掉落在他<br>身旁的10米范围内。馅饼如果掉在了地上当然就不能吃了，所以gameboy马上卸下身上的背包去接。但由于小径两侧都不能站人，所以他只能在小径上接。由于game<br>boy平时老呆在房间里玩游戏，虽然在游戏中是个身手敏捷的高手，但在现实中运动神经特别迟钝，每秒种只有在移动不超过一米的范围内接住坠落的馅饼。现在给这条小径如<br>图标上坐标：<br><img src="http://7xjob4.com1.z0.glb.clouddn.com/3d6e7172eea0b64638702b3468ac5ad2"><br>为了使问题简化，假设在接下来的一段时间里，馅饼都掉落在0-10这11个位置。开始时gameboy站在5这个位置，因此在第一秒，他只能接到4,5,6这三个位置<br>中其中一个位置上的馅饼。问gameboy最多可能接到多少个馅饼？（假设他的背包可以容纳无穷多个馅饼）</p><p>Input</p><p>输入数据有多组。每组数据的第一行为以正整数n(0&lt;n&lt;100000)，表示有n个馅饼掉在这条小径上。在结下来的n行中，每行有两个整数x,T(0&lt;T&lt;1000<br>00),表示在第T秒有一个馅饼掉在x点上。同一秒钟在同一点上可能掉下多个馅饼。n=0时输入结束。</p><p>Output</p><p>每一组输入数据对应一行输出。输出一个整数m，表示gameboy最多可能接到m个馅饼。<br>提示：本题的输入数据量比较大，建议用scanf读入，用cin可能会超时。</p><p>Sample Input</p><pre><code class="hljs">65 14 16 17 27 28 30</code></pre><p>Sample Output</p><pre><code class="hljs">4</code></pre><p>** 思路 **</p><p>很基本的dp，  由于初始状态只能在位置5，所以可以倒着dp，即从时间T到0。</p><p>状态转移方程  v[i][j] = max(v[i+1][j+1],  v[i][j+1],  v[i-1][j+1])</p><p>/ i为当前位置/ j为当前时间/ v[i][j]为接到的馅饼量</p><p>v[0][5]便为最终结果</p><p>代码</p><pre><code class="hljs">#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;math.h&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;string.h&gt;#include &lt;set&gt;#include &lt;stack&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;int v[12][100009];int main()&#123;    int n;    while(cin&gt;&gt;n &amp;&amp; n)    &#123;        memset(v, 0, sizeof(v));        for(int i=0;i&lt;n;i++)        &#123;            int a,b;            scanf(&quot;%d%d&quot;,&amp;a,&amp;b);            ++v[a][b];        &#125;        for(int i=100000; i&gt;=0;i--)        &#123;            for(int j=0;j&lt;=10;j++)            &#123;                int m = v[j][i+1];                if(j-1 &gt;= 0)                    m = max(m, v[j-1][i+1]);                if(j+1 &lt;= 10)                    m = max(m, v[j+1][i+1]);                v[j][i] += m;            &#125;        &#125;        cout&lt;&lt;v[5][0]&lt;&lt;endl;    &#125;    return 0;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kuangbin带你飞专题二 搜索进阶 C</title>
    <link href="/posts/411.html"/>
    <url>/posts/411.html</url>
    
    <content type="html"><![CDATA[<p>** 题目链接 ** ： <a href="http://acm.hust.edu.cn/vjudge/contest/view.action?cid=65997#problem/C"> 哈密顿绕行世界问题(HDU 2181) </a></p><p>** _ 思路 _ **</p><blockquote><p>起点和终点相同的dfs</p></blockquote><p>** _ 代码 _ **</p><pre><code class="hljs">#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;math.h&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;string.h&gt;#include &lt;set&gt;#include &lt;stack&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;bool v[21][21];//保存结点连通情况bool f[21];//记录已经过的结点int p[21];//记录路径int num;void dfs(int m, int x, int k)&#123;    p[k] = x;    if(k == 20)    &#123;        if(x == m)        &#123;            cout&lt;&lt;num++&lt;&lt;&quot;: &quot;;            for(int i=0;i&lt;=20;++i)                cout&lt;&lt;&quot; &quot;&lt;&lt;p[i];            cout&lt;&lt;endl;        &#125;        return;    &#125;    for(int i=1;i&lt;=20;++i)    &#123;        if(!f[i] &amp;&amp; v[i][x])        &#123;            f[i] = 1;            dfs(m, i, k+1);            f[i] = 0;        &#125;    &#125;&#125;int main()&#123;    int a,b,c;    while(1)    &#123;        memset(f, 0, sizeof(f));        memset(v, 0, sizeof(v));        num = 1;        cin&gt;&gt;a;        if(a == 0)            break;        cin&gt;&gt;b&gt;&gt;c;        v[1][a] = v[1][b] = v[1][c] = 1;        for(int i=2;i&lt;=20;++i)        &#123;            cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;            v[i][a] = v[i][b] = v[i][c] = 1;        &#125;        int m;        cin&gt;&gt;m;        dfs(m, m, 0);    &#125;    return 0;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UVA</title>
    <link href="/posts/33007.html"/>
    <url>/posts/33007.html</url>
    
    <content type="html"><![CDATA[<p>** 题目链接 ** <a href="http://acm.hust.edu.cn/vjudge/problem/viewProblem.action?id=42076"> UVA - 12108 </a></p><p>** _ 题目思路： _ **</p><blockquote><p>用f[i]来纪录每个学生当前的状态(是否睡觉)<br>用now[i]来纪录每个学生处于当前状态的总时间<br>用first[i]来纪录所有学生最初时处于第几分钟，用于循环中判断是否无解(若后面重复到此状态即为无解)<br>特殊点：<br>学生a在第i分钟准备睡觉，对于是否进行睡觉的判断是由第 i - 1分钟得出的。</p></blockquote><p>** _ 代码： _ **</p><pre><code class="hljs">#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;math.h&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;string.h&gt;#include &lt;set&gt;#include &lt;stack&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;int va[11];//清醒周期长度int vb[11];//睡觉周期长度int now[11];//处于当前状态第几分钟int first[11];//最初处于第几分钟int f[11];//是否睡觉bool isall(int n)//判断是否与最初状态重合，即判断是否无解&#123;    for(int i=0;i&lt;n;i++)    &#123;        int t = 0;        if(f[i])            t = va[i];//加上清醒周期的长度，与最初值保持一致        if(now[i] + t != first[i])            return false;    &#125;    return true;&#125;int main()&#123;    int n, T=0;    while(cin&gt;&gt;n &amp;&amp; n)    &#123;        ++T;        int time = 1;//当前时间        int num = 0;//睡觉总人数        for(int i=0;i&lt;n;i++)        &#123;            cin&gt;&gt;va[i]&gt;&gt;vb[i]&gt;&gt;now[i];            first[i] = now[i];            if(now[i] &gt; va[i])            &#123;                f[i] = 1;                ++num;                now[i] -= va[i];            &#125;            else                f[i] = 0;        &#125;        while(1)        &#123;            if(num == 0)//全部清醒，退出循环                break;            int t = 0;//本分钟睡觉人数的增减量            for(int i=0;i&lt;n;i++)            &#123;                ++now[i];                if(f[i])//睡                &#123;                    if(now[i] &gt; vb[i])                    &#123;//开始清醒                        now[i] = 1;                        f[i] = 0;                        --t;                    &#125;                &#125;                else                &#123;                    if(now[i] &gt; va[i])                    &#123;                        now[i] = 1;                        if(num*2 &gt; n)//上一分钟睡觉人数是否符合睡觉条件                        &#123;                            f[i] = 1;                            ++t;                        &#125;                    &#125;                &#125;            &#125;            num += t;            if(isall(n))            &#123;                time = -1;                break;            &#125;            ++time;        &#125;        printf(&quot;Case %d: %d\n&quot;, T, time);    &#125;    return 0;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>思路题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kuangbin带你飞专题二 搜索进阶 I</title>
    <link href="/posts/1563.html"/>
    <url>/posts/1563.html</url>
    
    <content type="html"><![CDATA[<p>** 题目链接 ** <a href="http://acm.hust.edu.cn/vjudge/contest/view.action?cid=65997#problem/I"> I - A计划 </a><br>** _ 思路： _ **</p><blockquote><p>还是正常的bfs,多了一层而已。在移动时，增加判断，如果下一步为时光传输机且对应的节点为空地，则加入队列，否则continue即可。</p></blockquote><p>** _ 代码： _ **</p><pre><code class="hljs">#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;math.h&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;string.h&gt;#include &lt;set&gt;#include &lt;stack&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;int mp[2][12][12];typedef struct Node&#123;    int x, y, z;    int num;&#125;node;int dx[] = &#123;0,0,1,-1&#125;;int dy[] = &#123;1,-1,0,0&#125;;bool bfs(int x, int y, int z, int time)&#123;    node temp;    temp.x = 1;    temp.y = 1;    temp.z = 0;    temp.num = 0;    queue&lt;node&gt; q;    q.push(temp);    while(!q.empty())    &#123;        temp = q.front();        //cout&lt;&lt;temp.x&lt;&lt;&quot; &quot;&lt;&lt;temp.y&lt;&lt;&quot; &quot;&lt;&lt;temp.z&lt;&lt;&quot; &quot;&lt;&lt;temp.num&lt;&lt;endl;        if(temp.num &gt; time)            break;        if(temp.x == x &amp;&amp; temp.y == y &amp;&amp; temp.z == z)            return true;        q.pop();        for(int i=0;i&lt;4;i++)        &#123;            node t;            t.x = temp.x + dx[i];            t.y = temp.y + dy[i];            t.z = temp.z;            t.num = temp.num + 1;            if(mp[t.z][t.x][t.y] == 2)            &#123;                mp[t.z][t.x][t.y] = 0;                if(mp[!t.z][t.x][t.y] == 1)                &#123;                    mp[!t.z][t.x][t.y] = 0;                    t.z ^= 1;                    q.push(t);                &#125;                else                    continue;            &#125;            else if(mp[t.z][t.x][t.y] == 1)            &#123;                mp[t.z][t.x][t.y]--;                q.push(t);            &#125;        &#125;    &#125;    return false;&#125;int main()&#123;    int T;    cin&gt;&gt;T;    while(T--)    &#123;        int n, m, time, sx, sy, sz;        cin&gt;&gt;n&gt;&gt;m&gt;&gt;time;        char t[12];        memset(mp, 0, sizeof(mp));        for(int ti=0;ti&lt;=1;ti++)            for(int i=1;i&lt;=n;i++)            &#123;                cin&gt;&gt;t;                for(int j=0;j&lt;m;j++)                    if(t[j] == &#39;P&#39;)                    &#123;                        sx = i;                        sy = j+1;                        sz = ti;                        mp[ti][i][j+1] = 1;                    &#125;                    else if(t[j] == &#39;#&#39;)                        mp[ti][i][j+1] = 2;                    else if(t[j] == &#39;.&#39;)                        mp[ti][i][j+1] = 1;            &#125;        if(bfs(sx, sy, sz, time))            cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;        else            cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;    &#125;    return 0;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UVA 1590 IP Networks（IP 网络）</title>
    <link href="/posts/57087.html"/>
    <url>/posts/57087.html</url>
    
    <content type="html"><![CDATA[<p>题目链接： <a href="http://acm.hust.edu.cn/vjudge/problem/viewProblem.action?id=52103"> UVA - 1590 IP Networks</a></p><p>** _ 题目大意： _ **<br>一个网络地址A和一个子网掩码可以描述一个子网，子网是一个数包含32个二进制位，前n个位为1，后32－n个位为0，如：255.255.255.48(11111<br>111|11111111|11111111|11111000) 表示某个ip地址如果和A的前n位相等则说明其属于这个子网。<br>现给定n个网络地址组成一子网，求该子网的最小范围的首地址和子网掩码。</p><p>** _ 题目思路： _ **<br>这道题只要求出ip地址在哪一位最开始存在不同即可解决，通过位运算的异或操作再取反即可得出。<br>易错地方：<br>所有ip异或一轮之后，得出的结果可能有类似 111110100 的情况出现，不符合掩码的要求；<br>位运算的两个小技巧，纪录于此：<br>1. a &amp; (a - 1) 将a的二进制位上最后一个1转为0<br>2. a | (a - 1) 将a的二进制位上末尾连续的0全部转为1</p><p>** 代码 ： **</p><pre><code class="hljs">#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;math.h&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;string.h&gt;#include &lt;set&gt;#include &lt;stack&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace std;unsigned int num[1009] = &#123;&#125;;int main()&#123;    int n;    while(cin&gt;&gt;n)    &#123;        memset(num, 0, sizeof(num));        for(int i=0;i&lt;n;i++)        &#123;            char t[40];            cin&gt;&gt;t;            int c = 0;            for(int j=0;j&lt;strlen(t);j++)            &#123;                if(t[j] == &#39;.&#39;)                &#123;                    num[i] = (num[i]&lt;&lt;8) + c;                    c = 0;                &#125;                else                    c = c*10 + t[j]-&#39;0&#39;;            &#125;            num[i] = (num[i]&lt;&lt;8) + c;        &#125;        unsigned int ans = ~0, tt;        for(int i=1;i&lt;n;i++)        &#123;            unsigned int q = num[i] ^ num[0];            while(q)            &#123;                ans &amp;= ~(q | (q-1));                q = q&amp;(q-1);            &#125;        &#125;        tt = ans &amp; num[0];        int sans[4]=&#123;&#125;;        int pos = 0;        while(tt != 0)        &#123;            sans[pos++] = tt%(1&lt;&lt;8);            tt &gt;&gt;= 8;        &#125;        for(int i=3;i&gt;=0;i--)        &#123;            cout&lt;&lt;sans[i];            if(i)                cout&lt;&lt;&quot;.&quot;;        &#125;        cout&lt;&lt;endl;        pos = 0;        memset(sans, 0, sizeof(sans));        while(ans != 0)        &#123;            sans[pos++] = ans%(1&lt;&lt;8);            ans &gt;&gt;= 8;        &#125;        for(int i=3;i&gt;=0;i--)        &#123;            cout&lt;&lt;sans[i];            if(i)                cout&lt;&lt;&quot;.&quot;;        &#125;        cout&lt;&lt;endl;    &#125;    return 0;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>思路题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c++类的静态成员踩坑记录</title>
    <link href="/posts/36791.html"/>
    <url>/posts/36791.html</url>
    
    <content type="html"><![CDATA[<p>** 今天在静态成员上踩坑不少，特此记录。 **</p><p>** _ c++类的静态成员需要在类内声明，而在类外进行定义，如下 _ **</p><pre><code class="hljs">class M&#123;public:    static int m;&#125;;int M::m = 90;int main()&#123;    cout&lt;&lt;M::m;&#125;</code></pre><p>** _ 类内静态常量可以在类内直接初始化，如下，当然也可用上面的方法 _ **</p><pre><code class="hljs">class M&#123;public:    const static int m ＝ 9;&#125;;int main()&#123;    cout&lt;&lt;M::m;&#125;</code></pre><p>** _ 类内静态常量数组的定义 _ **</p><pre><code class="hljs">class M&#123;public:    const static int m[];//声明    M()    &#123;        cout&lt;&lt;m[2]&lt;&lt;endl;    &#125;&#125;;const int M::m[8]=&#123;0,9,8,8&#125;;//定义int main()&#123;    M m = M();&#125;</code></pre><p>** _ 那么问题来了，可不可以直接定义呢？静态常量数组也是常量啊，当然可以 _ **</p><pre><code class="hljs">class M&#123;public:    static const int m[] = &#123;2,3,4&#125;;    M()    &#123;        cout&lt;&lt;m[2]&lt;&lt;endl;    &#125;&#125;;int main()&#123;    M m = M();&#125;</code></pre><blockquote><p>如果你把上面代码copy或者敲下来编译会发现有个错误：<br>In-class initializer for static data member of type ‘const int [78]’ requires<br>‘constexpr’ specifier<br>大概意思是：const int [ 3 ]的静态数据成员初始化需要constexpr类<br>为什么呢？<br>因为const只表明这个变量是的值是不变的，但并没表明该变量需要在编译期确定，巧的是，数组就恰恰需要在编译期确定，而constexpr，则表明这个值不仅是值<br>不变的，而且也是编译期确定的。<br>那好，我们改</p></blockquote><pre><code class="hljs">class M&#123;public:    static constexpr int m[] = &#123;2,3,4&#125;;    M()    &#123;     //   cout&lt;&lt;m[2]&lt;&lt;endl;  注意这句注释，往下看    &#125;&#125;;int main()&#123;    M m = M();&#125;</code></pre><p>没错，编译是成功的，那么，把上面的注释去掉呢，铛，两个错误来袭。。。<br>clang: error: linker command failed with exit code 1 (use -v to see<br>invocation)<br>链接器命令失败,退出码1(使用- v查看调用)<br>“M::m”, referenced from:</p><p>查了好多问答文章，没有找到此错误原因，回过头再看书（c++primer），看到这样一段话：</p><blockquote><p>class A {<br>static constexpr int p = 30;<br>double d[p];<br>};<br>** 如果某个静态成员的应用场景仅限于编译器可以替换它的值的情况，则一个初始化的const或constexpr static不需要分别定义。相反，如果我们将它用于值不能替换掉应用场景中，则该成员必须有一条定义语句。 **</p></blockquote><p>显然，静态常量数组的元素是不能被替换掉的，所以。。。</p><pre><code class="hljs">class M&#123;public:    static constexpr int m[] = &#123;2,3,4&#125;;    M()    &#123;        cout&lt;&lt;m[2]&lt;&lt;endl;    &#125;&#125;;constexpr int M::m[];//如果在类的内部提供了一个初始值，                    //则成员的定义不能再指定一个初始值了int main()&#123;    M m = M();&#125;</code></pre><p>以上，就是今一下午踩坑的收获，刚出坑，脚下难免有泥，若有错误，欢迎批评指正！</p>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kuangbin带你飞专题一 简单搜索D</title>
    <link href="/posts/1089.html"/>
    <url>/posts/1089.html</url>
    
    <content type="html"><![CDATA[<p><a href="http://acm.hust.edu.cn/vjudge/contest/view.action?cid=65959#problem/D"> ** 题目大意 **</a></p><pre><code class="hljs"> 给一个N行M列的矩阵，值分别为0和1，每次你可以选择将一个变成相反状态，同时，它周围的四个数也会变为相反状态。</code></pre><p>问：最少翻转多少次，可以将所有值都变成0<br>多个解，输出翻转次数最少的（若有次数相同解，输出字典序小的）<br>若无解，输出”IMPOSSIBLE”</p><p>** 思路 **<br>     对于每个点，只能有两种操作，翻或不翻，若暴力所有可能性，需要2^(M＊N)次操作，显然不可行<br>所以有了这个法子。<br>先枚举第一行的所有可能性(2^M)，搜索或位运算均可<br>然后，对坐标(i, j)来说，如果(i-1, j)不为0，那么(i, j)必然需要翻转。<br>重复进行上操作由2至N<br>此时，最后一行也已翻转完毕，如果最后一行全为0，得出结果<br>第一行的所有结果中取最小值</p><p>** 代码 **<br>     下面是两种方法，思路相同，仅仅是实现细节上略有不同。</p><p>** _ 1 . dfs搜索 _ **</p><pre><code class="hljs">#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;math.h&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;string.h&gt;using namespace std;int g[17][17];         //保存初始状态　int f[17][17] = &#123;&#125;;int ans[17][17] = &#123;&#125;;int mmin = 0x1f1ffff;bool judge(int n,int m)//判断最后一行是否全为0&#123;    for(int i=1;i&lt;=m;i++)    &#123;        int t = f[n][i]+f[n][i-1]+f[n][i+1]+f[n-1][i];        if((g[n][i]+t)&amp;1)            return false;        &#125;    return true;&#125;void dfs(int n,int m,int k,int num)&#123;    if(num &gt; mmin)//剪枝        return;    if(k &gt; n)    &#123;        if(judge(n, m) &amp;&amp; mmin&gt;num)//判断是否符合条件        &#123;            memcpy(ans, f, sizeof(f));            mmin = num;        &#125;        return;    &#125;    int t = 0;    for(int i=1;i&lt;=m;i++)    &#123;        if((g[k-1][i]+f[k-2][i]+f[k-1][i-1]+f[k-1][i+1]+f[k-1][i])&amp;1)//上一行是否为1，即是否需要翻转        &#123;            f[k][i] = 1;            t++;        &#125;        else            f[k][i] = 0;    &#125;    dfs(n, m, k+1, num+t);&#125;//n,m行列数   k当前列  num第一行翻转的次数void todfs(int n, int m, int k, int num)&#123;    if(k &gt; m)    &#123;        dfs(n, m, 2, num); //对第一行每种情况进行搜索        return;    &#125;    f[1][k] = 0;      //不翻转    todfs(n, m, k+1, num);    f[1][k] = 1;      //翻转，num＋1    todfs(n, m, k+1, num+1);&#125;int main()&#123;    int n,m;    cin&gt;&gt;n&gt;&gt;m;    for(int i=1;i&lt;=n;i++)        for(int j=1;j&lt;=m;j++)//下标从1开始，便于边界处理            cin&gt;&gt;g[i][j];    todfs(n, m, 1, 0);     //递归遍历第一行所有情况    if(mmin == 0x1f1ffff)        cout&lt;&lt;&quot;IMPOSSIBLE&quot;&lt;&lt;endl;    else        for(int i=1;i&lt;=n;i++)        &#123;            for(int j=1;j&lt;=m;j++)                cout&lt;&lt;ans[i][j]&lt;&lt;&quot; &quot;;            cout&lt;&lt;endl;        &#125;    return 0;&#125;</code></pre><p>** _ 2 . 枚举递推 _ **</p><pre><code class="hljs">#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;math.h&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;string.h&gt;using namespace std;int g[17][17];         //保存初始状态　int f[17][17] = &#123;&#125;;int ans[17][17] = &#123;&#125;;int mmin = 0x1f1ffff;bool judge(int n,int m)//判断最后一行是否全为0&#123;    for(int i=1;i&lt;=m;i++)    &#123;        int t = f[n][i]+f[n][i-1]+f[n][i+1]+f[n-1][i];        if((g[n][i]+t)&amp;1)            return false;    &#125;    return true;&#125;void fun(int n, int m, int num)&#123;    for(int i=2;i&lt;=n;i++)    &#123;        for(int j=1;j&lt;=m;j++)        &#123;            if(num &gt; mmin)                return;            if((g[i-1][j]+f[i-2][j]+f[i-1][j-1]+f[i-1][j+1]+f[i-1][j])&amp;1)//上一行是否为1，即是否需要翻转            &#123;                f[i][j] = 1;                ++num;            &#125;            else                f[i][j] = 0;        &#125;    &#125;    if(judge(n, m) &amp;&amp; mmin&gt;num)//判断是否符合条件    &#123;        memcpy(ans, f, sizeof(f));        mmin = num;    &#125;&#125;int main()&#123;    int n,m;    cin&gt;&gt;n&gt;&gt;m;    for(int i=1;i&lt;=n;i++)        for(int j=1;j&lt;=m;j++)//下标从1开始，便于边界处理            cin&gt;&gt;g[i][j];    for(int i=0;i &lt; 1&lt;&lt;(m+1);i++)    &#123;        int num = 0;        for(int j=1;j&lt;=m;j++)        &#123;            f[1][j] = i&gt;&gt;(m-j+1) &amp; 1;            num += f[1][j];        &#125;        fun(n, m, num);    &#125;    if(mmin == 0x1f1ffff)        cout&lt;&lt;&quot;IMPOSSIBLE&quot;&lt;&lt;endl;    else        for(int i=1;i&lt;=n;i++)        &#123;            for(int j=1;j&lt;=m;j++)                cout&lt;&lt;ans[i][j]&lt;&lt;&quot; &quot;;            cout&lt;&lt;endl;        &#125;    return 0;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python第一次练习题</title>
    <link href="/posts/18504.html"/>
    <url>/posts/18504.html</url>
    
    <content type="html"><![CDATA[<p>** 从来没有在一天内学习这么多东西，值得纪念（Q币果然激发人斗志） **</p><p>1. print repr(u’  蓝鲸  ‘)  的运行结果是什么？</p><p>答：运行结果为  u’\u84dd\u9cb8’</p><p>u’蓝鲸‘  表示  ’  蓝鲸  ‘  代表的是一个  Unicode  编码字符串</p><p>repr(x)  函数返回  x  对象的字符串表示</p><p>2. 什么是lambda  函数？并列举一个使用  lambda  函数的例子</p><p>答：  lambda  函数就是匿名函数，用法为  lambda  参数  :  返回值</p><p>对于某些简单和只使用一次的函数来说，</p><p>使用  lambda  比定义新函数更加方便</p><p><img src="http://img.blog.csdn.net/20151018115639079"></p><p>3. Excel  操作</p><p>将</p><p>{</p><p>“1”:[“  张三  “,150,120,100],</p><p>“2”:[“  李四  “,90,99,95],</p><p>“3”:[“  王五  “,60,66,68]</p><p>}</p><p>写入  excel  如下所示：</p><p><img src="http://img.blog.csdn.net/20151018115949536"></p><p>答：代码如下：</p><p>#!/usr/bin/env python<br># coding=utf-8</p><p>from  xlwt  import  *<br>file = Workbook(  encoding  =  ‘utf-8’  )<br>table = file.add_sheet(  ‘test’  )<br>data = {<br>“1”  :[  “  张三  “  ,  150  ,  120  ,  100  ]  ,  <br>“2”  :[  “  李四  “  ,  90  ,  99  ,  95  ]  ,  <br>“3”  :[  “  王五  “  ,  60  ,  66  ,  68  ]}<br>ldata = []<br>num = [a  for  a  in  data]<br>num.sort()<br>for  x  in  num:<br>t = [  int  (x)]<br>for  a  in  data[x]:<br>t.append(a)<br>ldata.append(t)<br>for  i  ,  p  in  enumerate  (ldata):<br>for  j  ,  q  in  enumerate  (p):<br>print  i  ,  j  ,  q<br>table.write(i  ,  j  ,  q)<br>file.save(  ‘demo’  )</p><p>运行结果：</p><p><img src="http://img.blog.csdn.net/20151018115726518"></p><p>生成文件：</p><p><img src="http://img.blog.csdn.net/20151018115737459"></p><p>表格内容：</p><p><img src="http://img.blog.csdn.net/20151018115746610"></p><p>4. 简述对  Python  装饰器的理解</p><p>答：装饰器，可以看做是用于修饰函数的工具，而本质上装饰器也是函数，</p><p>而且必须是一个形参和返回值都是函数的函数。</p><p>下面是一个小例子</p><p>def  red_hat  (f):<br>print  ‘red_hat:  给你戴个红帽子  ‘<br>return  f</p><p>def  blue_hat  (f):<br>print  ‘blue_hat:  给你戴个蓝帽子  ‘<br>return  f<br>@  blue_hat  #等同于 fun = blue_hat(red_hat(fun))<br>@  red_hat   #等同于 fun = red_hat(fun)<br>def  fun  ():<br>print  ‘fun:  我要戴帽子  ‘<br>fun()</p><p>######形象点说，可以把fun比作一个人，red_hat给它戴上了一个红帽子，然后blue_hat在红帽子之上又给它戴了一个蓝帽子</p><p>通过装饰器很方便的对一些函数添加一些附加功能，而且既不改变函数的原有逻辑结构，</p><p>又可以省去很多的重复代码工作</p><p>5. 生成  100  个随机数，保存到  Redis  非关系型数据库中</p><p>答：代码如下</p><p>#!/usr/bin/env python<br># coding=utf-8</p><p>import  random<br>import  redis</p><p>num = []<br>for  i  in  range  (  100  ):<br>num.append(random.randint(  1  ,  1000  ))<br>print  num<br>r = redis.StrictRedis(  host  =  ‘localhost’  ,  port  =  6379  ,  db  =  3  )<br>r.set(  ‘dssd’  ,  ‘ss’  )<br>for  i  ,  x  in  enumerate  (num):<br>r.set(i  ,  x)<br>print  ‘  添加成功  ‘<br>newnum = [r.get(i)  for  i  in  range  (  100  )]<br>print  newnum</p><p>运行结果</p><p><img src="http://img.blog.csdn.net/20151018115835090"></p><p>6. 写结果</p><p>if 1 in [1,0] == True:</p><p>print  ‘a’</p><p>Else:</p><p>Print  ‘b’</p><p>答：结果  ‘b’</p><p>乍一看想着应该是  ‘a’,  敲完发现是  ‘b’,  百思不得解。</p><p>发现  if (1 in [1,0]) == True  输出与预想相同  ,  于是查看优先级，</p><p>一开始想着  ==  的优先级高于  in  ，而  [1,0]  与  True  是不同类型，</p><p>不同类型对象比较是通过对  typename  进行比较的，</p><p>所以  ([1,0] == True)  为  False  ，但  1 in True  又无法解释</p><p>网上查找资料发现  A x B y C  会被转化为</p><p>(A x B) and (B y C),</p><p>所以  1 in [1,0] == True –&gt; (1 in [1,0]) and ([1,0] == True)</p><p>--&gt; True and False –&gt; False</p><p>7. 用  Python  写一个程序，拉取  SVN  上的某一个文件，修改后并提交该文件。</p><p>答：代码如下</p><p>#!/usr/bin/env python<br># coding=utf-8</p><p>import  os</p><p>os.system(<br>‘svn  co  svn://localhost/test  <br>--username shiyi –password 19960604’<br>)</p><p>name =  raw_input  (  ‘  输入修改的文件名：  ‘  )<br>name =  ‘test/‘  + name<br>file =  open  (name  ,  ‘r’  )<br>txt = file.readlines()</p><p>for  i  ,  x  in  enumerate  (txt):<br>print  ‘%2d&gt;&gt;%s’  % (i+  1  ,  x)  ,</p><p>num =  raw_input  (  ‘  输入需要修改的行号：  ‘  )<br>num =  int  (num)<br>print  ‘&gt;&gt;’  +txt[num-  1  ]<br>txt[num-  1  ] =  raw_input  (  ‘  输入新内容：  ‘  )+  ‘  \n  ‘</p><p>os.rename(name  ,  ‘temp’  )<br>newfile =  open  (name  ,  ‘w’  )<br>for  x  in  txt:<br>newfile.write(x)<br>newfile.close()<br>os.remove(  ‘temp’  )</p><p>os.system(<br>‘svn commit -m “a” %s  <br>--username shiyi –password 19960604’  %name)<br>os.system(<br>‘svn ci -m “b” %s  <br>--username shiyi –password 19960604’  %name)</p><p>运行结果</p><p><img src="http://img.blog.csdn.net/20151018115910012"></p><p>8. 用  Python  画出  y=x  3的散点图</p><p>答：代码如下</p><p>#!/usr/bin/env python<br># coding=utf-8</p><p>import  numpy  as  np<br>import  pylab  as  pl</p><p>node = [(x*  0.1  ,  (x*  0.1  )**  3  ) <br>for  x  in  range  (-  100  ,  100  )]<br>x  ,  y =  zip  (*node)<br>pl.plot(x  ,  y  ,  ‘o’  )<br>pl.show()</p><p>运行结果：</p><p><img src="http://img.blog.csdn.net/20151018120009926"></p><p>9. 用  Python  爬取知乎热门帖的标题，并存储到  MySQL  中</p><p>答：代码如下</p><p>#!/usr/bin/env python<br># coding=utf-8<br>‘’’<br>网页源代码是通过手动拷贝到  zhihu.txt  内<br>‘’’</p><p>import  re<br>import  MySQLdb</p><p>file =  open  (  ‘zhihu.txt’  ,  ‘r’  )<br>htm = file.read()<br>s =  ‘&lt;a class=”question_link”(.*?)/a&gt;’<br>tlist = re.findall(s  ,  htm  ,  re.S)<br>s =  ‘&gt;(.*)&lt;’</p><p>conn=MySQLdb.connect(<br>host  =  ‘localhost’  ,<br>user  =  ‘root’  ,<br>passwd  =  ‘shiyi’  ,<br>db  =  ‘python’  ,<br>port  =  3306  )<br>cur = conn.cursor()<br>i =  1<br>for  x  in  tlist:<br>title = re.search(s  ,  x  ,  re.S).group(  1  )<br>print  ‘title%d:%s’  % (i  ,  title)<br>cmd =  “insert into zhihu(title)  <br>values(‘%s’)”  % title<br>cur.execute(cmd)<br>conn.commit()</p><p>conn.close()</p><p>运行结果</p><p><img src="http://img.blog.csdn.net/20151018120038579"></p><p>数据库结果</p><p><img src="http://img.blog.csdn.net/20151018120211240"></p><p><img src="http://img.blog.csdn.net/20151018120139667"></p>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>KMP的next数组求法详解</title>
    <link href="/posts/3445.html"/>
    <url>/posts/3445.html</url>
    
    <content type="html"><![CDATA[<p>近几天学习kmp算法，在next数组求解上受苦颇深，看了不少博客，感觉写得都不够清晰，所以想按照自己理解的过程来尝试写一下，也便于以后温习。</p><p>关于kmp算法的介绍，网上博文有很多，就不再赘述，推荐一篇 <a href="http://kb.cnblogs.com/page/176818/"> kmp算法 </a><br>，个人感觉挺好</p><p>这里主要详细讲解next数组的求解。<br>由于在下不擅作图，有的地方单纯用文字描述不够清晰，还请原谅。<br>若有什么地方写得不对欢迎批评，以便于在下修正。</p><blockquote><p>** kmp算法的精髓就在于next数组，从而达到跳跃式匹配的高效模式 ** 。<br>而 ** next数组的值 ** 是代表着 ** 字符串的前缀与后缀相同的最大长度 ** , ** _ (不能包括自身) _ ** 。</p></blockquote><p>这里举个例子：</p><pre><code class="hljs">模式串t  A B A B A A下标     0 1 2 3 4 5next    0 0 1 2 3 1next[0]代表t[0]~t[0]即&quot;A&quot;的最大前后缀，显然为0.next[1]代表t[0]~t[1]即&quot;AB&quot;的最大前后缀，为0.next[2]代表t[0]~t[2]即&quot;ABA&quot;的最大前后缀，即&quot;A&quot;,长度为1.next[3]代表t[0]~t[3]即&quot;ABAB&quot;的最大前后缀，即&quot;AB&quot;,长度为2.next[4]代表t[0]~t[4]即&quot;ABABA&quot;的最大前后缀，即&quot;ABA&quot;,长度为3.next[5]代表t[0]~t[5]即&quot;ABABAA&quot;的最大前后缀，即&quot;A&quot;,长度为1.</code></pre><p>看到这里，next值代表的意义应该可以明白了。<br>但next数组怎样用代码去求呢，我们当然不可能挨个去比较前后缀。<br>仍然是上面那个例子<br>A B A B A A<br>初始化，next[0]为0；<br>t[0] != t[1] next[1]为0；<br>t[0] == t[2] next[2]为1；<br>在求next[3]时，比较t[1]和t[3]是否相等？<br>相等：显然 next[3] = next[2]+1;<br>不相等：怎么办？ 看下面</p><pre><code class="hljs">void makeNext(char s[],int next[])&#123;    int len = strlen(s);    next[0]=0;                    //初始化    for(int i=1,k=0;i&lt;len;i++)    &#123;        while(k&gt;0 &amp;&amp; s[k]!=s[i])  //这个while是最关键的部分            k=next[k-1];            //等价于  k=next[next[i-1]-1]            //等号右边的k起的只是下标的作用        if(s[k]==s[i])            k++;                  //相等就+1        next[i]=k;                //赋值    &#125;&#125;</code></pre><p>例子说话<br>A B A B A B A C<br>0 1 2 3 4 5 6 7<br>next[6] = 5<br>即前缀为t[0]<del>t[4] 后缀为t[2]</del>t[6]<br>next[4] = 3<br>即前缀为t[0]<del>t[2] 后缀为t[2]</del>t[4]<br>我们发现<br>** next[4]的前缀一定是next[6]的前缀 **<br>** next[4]的后缀也一定是next[6]的后缀 **<br>(这是while循环的原理，可以试着举个例子验证一下)</p><blockquote><p>现在我们要求next[7]，将 ** t[7]与t[5] ( t[next[6]] )比较 ** ，发现不相等<br>那么可以将 ** t[7]与t[3] (t[ next[next[6]-1] ])比较 ** ，如果相等，则next[7] = next[4] +1 ;<br>不相等就重复此过程，直到t[7]与t[0]比较.</p></blockquote><p>上框内过程其实就是代码中，while循环里的内容，现在回过头去看上面代码应该会顺畅很多。</p><p>下面附上kmp完整代码</p><pre><code class="hljs">/*************************************************************************    &gt; File Name: kmp.cpp    &gt; Author:    &gt; Mail:  458241107@qq.com    &gt; Created Time: 2015年10月12日 星期一 18时32分00秒 ************************************************************************/#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;using namespace std;void makeNext(char s[],int next[])&#123;    int len = strlen(s);    next[0]=0;    for(int i=1,k=0;i&lt;len;i++)    &#123;        while(k&gt;0 &amp;&amp; s[k]!=s[i])            k=next[k-1];        if(s[k]==s[i])            k++;        next[i]=k;    &#125;&#125;int kmp(char t[],char s[])&#123;    int len1 = strlen(t);    int len2 = strlen(s);    int next[len2];    makeNext(s,next);    for(int i=0,j=0;i&lt;len1;i++)    &#123;        while(j&gt;0 &amp;&amp; t[i]!=s[j])        &#123;            j=next[j-1];        &#125;        if(t[i]==s[j])            j++;        if(j==len2)            return i-j+1;    &#125;&#125;int main()&#123;    char t[]=&quot;1234561123458412&quot;;    char s[]=&quot;611&quot;;    cout&lt;&lt;t&lt;&lt;endl;    cout&lt;&lt;s&lt;&lt;endl;    cout&lt;&lt;&quot;下标为&quot;&lt;&lt;kmp(t,s)&lt;&lt;endl;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>KMP&amp;amp;Manacher</tag>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数组实现循环队列(Java)</title>
    <link href="/posts/35951.html"/>
    <url>/posts/35951.html</url>
    
    <content type="html"><![CDATA[<p>** _ 前言 _ **</p><blockquote><p>库函数用的多了，一下自己动手写，还真有些手生。脑中有思路，不如笔下出代码，趁着不瞌睡，改改懒病。<br>队列这东西没什么可说的，线性表的一种，表头为出口，表尾为入口，先进先出。<br>普通队列当表头数据弹出后，空间无法再次利用，造成空间的浪费，所以就有了循环队列。</p></blockquote><blockquote></blockquote><blockquote><p>循环队列的实现一般有两种方式，链表实现和数组实现。<br>链表实现就是通过next指针将入口与出口连起来，实现循环。<br>而数组可以通过对 ** 索引进行取余 ** 的操作变相实现循环。</p></blockquote><p>** _ 代码实现 _ **</p><pre><code class="hljs">public class Queue &#123;    private int[] d = null;// 队列空间    private int head = 0;// 队列头索引    private int tail = 0;// 队列尾索引    private int len = 0;// 队列最大长度    public Queue(int len) &#123;        this.len = len;        d = new int[len];    &#125;    //入队函数    public void push(int x) &#123;        if (isFull()) &#123;            System.out.println(&quot;队列已满，入队失败&quot;);        &#125; else &#123;            d[tail] = x;            tail = (tail + 1) % len;        &#125;    &#125;    //出队函数    public void pop() &#123;        if (isEmpty()) &#123;            System.out.println(&quot;队列为空，出对失败&quot;);        &#125; else &#123;            head = (head + 1) % len;        &#125;    &#125;    //查看队首元素    public int front() &#123;        return d[head];    &#125;    //查看队尾元素    public int back() &#123;        return d[(tail + len - 1) % len];    &#125;    //查看队列元素总数    public int size() &#123;        return (tail + len - head) % len-1;    &#125;    //判断队列是否为空    public boolean isEmpty() &#123;        //头尾索引相等表示队列满        if (tail == head)            return true;        return false;    &#125;    //判断队列是否为满    public boolean isFull() &#123;        //尾索引的下一个为为索引时表示队列满，即将队列容量空出一个作为约定        if ((tail + 1) % len == head)            return true;        return false;    &#125;    public static void main(String[] argc)    &#123;        Queue q = new Queue(5);        q.push(1);        q.push(2);        q.push(3);        q.pop();        System.out.println(&quot;首-&quot;+q.front()+&quot; 尾&quot;+q.back()+&quot; 队列元素总数&quot;+q.size());        q.push(4);        q.push(5);        q.push(6);        q.pop();        q.pop();        q.push(7);        System.out.println(&quot;首-&quot;+q.front()+&quot; 尾&quot;+q.back()+&quot; 队列元素总数&quot;+q.size());    &#125;&#125;</code></pre><p>** _ 运行结果 _ **</p><blockquote><p>首-2 尾3 队列元素总数2<br>队列已满，入队失败<br>首-4 尾7 队列元素总数3</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Trie树</title>
    <link href="/posts/35078.html"/>
    <url>/posts/35078.html</url>
    
    <content type="html"><![CDATA[<p>** 1. 什么是Trie树 **</p><blockquote><p>Trie树，也叫字典树，是一种树形结构，常用于统计、排序和保存大量字符串，利用字符串的公共前缀来减少查询时间，以空间换取时间。</p></blockquote><p>** 2. 基本结构 **</p><blockquote><p>Trie树不同于我们常接触到的二叉树，而是N叉树，例如，如果我们要将许多单词（小写）用Trie树来进行保存，那么此时的Trie树为26叉树，因为总共有2<br>6个小写字母。<br>例如：<br>我们要储存inn int ate age adv ant 这五个单词 ，那么所构成的Trie树为下图所示。<br><img src="http://img.blog.csdn.net/20150911030148896" alt="这里写图片描述"><br>在Trie树中，每个字符串都被分为单个字符按照顺序逐层标记于树上。<br>需要说明三点：<br>&lt;1&gt;根节点只保存子节点地址，不保存数据<br>&lt;2&gt;每个节点中并不保存当前前缀的字符串，而是在逻辑上，以从根节点到当前节点的路径来表示。<br>&lt;3&gt;每个节点中都保存一int值，表示树中所有字符串以当前路径为前缀的字符串的数量。<br>树节点结构体定义如下：</p></blockquote><pre><code class="hljs">typedef struct Node&#123;    int num；               //保存当前路径为前缀的字符串的总数    struct Node *next[MAX]; //保存子节点的地址。&#125;</code></pre><p>** 3. 基本操作 **</p><blockquote><p>&lt;1&gt; 添加<br>从根节点开使，获取需要添加的字符串的第一个字符，根据字符值获取next[]数组中相应子树的地址，并进行跳转。如果子树地址为空则需先新建节点，初始化num=1<br>，并将新建节点的next数组全部置为空。然后跳转。若不为空，将num++；<br>从当前节点开始，对字符串的第二个字符进行上述操作。<br>…<br>字符串遍历完，此时添加成功<br>&lt;2&gt; 查找<br>对需检索的字符串进行类似上述操作，不同的是若在字符串遍历完毕之前，子树地址为空，表示该字符串并不在此树中。<br>&lt;3&gt; 删除<br>一般很少使用，过程细节类似于添加操作。不同处为对num进行减操作。</p></blockquote><p>** 4. 性能 **</p><blockquote><p>Trie主要用于查找。<br>在Trie树中查找一个关键字的时间和树中包含的结点数无关，而取决于组成关键字的字符数。而二叉查找树的查找时间和树中的结点数有关O(log2n)。<br>如果要查找的关键字可以分解成字符序列且不是很长，利用Trie树查找速度优于二叉查找树。</p></blockquote><p>** 5. 应用例题 **</p><blockquote><p><a href="http://hihocoder.com/problemset/problem/1014"> hihocoder 1014 Trie树 </a><br>题目大意：<br>给定词典，对于每个输入的关键字，输出词典中以该关键字为前缀的字符串总数。<br>输入<br>输入的第一行为一个正整数n，表示词典的大小，其后n行，每一行一个单词（不保证是英文单词，也有可能是火星文单词哦），单词由不超过10个的小写英文字母组成，可能<br>存在相同的单词，此时应将其视作不同的单词。接下来的一行为一个正整数m，表示小Hi询问的次数，其后m行，每一行一个字符串，该字符串由不超过10个的小写英文字母<br>组成，表示小Hi的一个询问。</p></blockquote><blockquote></blockquote><blockquote><p>在20%的数据中n, m&lt;=10，词典的字母表大小&lt;=2.</p></blockquote><blockquote></blockquote><blockquote><p>在60%的数据中n, m&lt;=1000，词典的字母表大小&lt;=5.</p></blockquote><blockquote></blockquote><blockquote><p>在100%的数据中n, m&lt;=100000，词典的字母表大小&lt;=26.</p></blockquote><blockquote></blockquote><blockquote><p>输出<br>对于小Hi的每一个询问，输出一个整数Ans,表示词典中以小Hi给出的字符串为前缀的单词的个数。</p></blockquote><p>** 6. 代码 **</p><pre><code class="hljs">#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;using namespace std;typedef struct Node&#123;    int num;    struct Node *next[26];&#125;tree;void init(tree *t)&#123;    for(int i=0;i&lt;26;i++)    &#123;        t-&gt;next[i] = NULL;    &#125;&#125;void add(tree *t,char s[])&#123;    int len = strlen(s);    for(int k=0; k&lt;len; k++)    &#123;        if(t-&gt;next[s[k]-&#39;a&#39;] == NULL)        &#123;            tree *z = (tree*)malloc(sizeof(tree));            init(z);            z-&gt;num = 1;            t-&gt;next[s[k]-&#39;a&#39;] = z;        &#125;        else        &#123;            t-&gt;next[s[k]-&#39;a&#39;]-&gt;num++;        &#125;        t=t-&gt;next[s[k]-&#39;a&#39;];    &#125;&#125;int find(tree *t, char str[])&#123;    int len = strlen(str);    for(int i=0;i&lt;len;i++)    &#123;        if(t-&gt;next[str[i]-&#39;a&#39;] == NULL)            return 0;        else        &#123;            t = t-&gt;next[str[i]-&#39;a&#39;];        &#125;    &#125;    return t-&gt;num;&#125;int main()&#123;    int n;    scanf(&quot;%d&quot;,&amp;n);    char str[10];    tree *root = (tree*)malloc(sizeof(tree));    init(root);    while(n--)    &#123;        scanf(&quot;%s&quot;,str);        add(root, str);    &#125;    scanf(&quot;%d&quot;,&amp;n);    while(n--)    &#123;        scanf(&quot;%s&quot;,str);        printf(&quot;%d\n&quot;,find(root, str));    &#125;    return 0;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux-C网络编程之epoll函数</title>
    <link href="/posts/34987.html"/>
    <url>/posts/34987.html</url>
    
    <content type="html"><![CDATA[<p>** 上文中说到如果从100的不同的地方取外卖，那么epoll相当于一部手机，当外卖到达后，送货员可以通知你，从而达到每去必得，少走很多路。 **<br>** 它是如何实现这些作用的呢？ **</p><p>** epoll的功能 **</p><pre><code class="hljs">epoll是select/poll的强化版，同是多路复用的函数，epoll有了很大的改进。</code></pre><ol><li>支持监听大数目的socket描述符*</li></ol><blockquote><p>一个进程内，select能打开的fd是有限制的，由宏FD_SETSIZE设置，默认值是1024.在某些时候，这个数值是远远不够用的。解决办法有两种，一是<br>修改宏然后重新编译内核，但与此同时会引起网络效率的下降；二是使用多进程来解决，但是创建多个进程是有代价的，而且进程间数据同步没有多线程间方便。<br>而epoll没有这个限制，它所支持的最大FD上限远远大于1024，在1GB内存的机器上是10万左右（具体数目可以cat/proc/sys/fs/file-<br>max查看）；</p></blockquote><ol><li>效率的提高</li></ol><blockquote><p>select函数每次都当监听的套接组有事件产生时就会返回，但却不能将有事件产生的套接字筛选出来，而是改变其在套接组的标志量，所以每次监听到事件，都需要将<br>套接组整个遍历一遍。时间复杂度是O(n)。当FD数目增加时，效率会线性下降。<br>而epoll，每次会将监听套结字中产生事件的套接字加到一列表中，然后我们可以直接对此列表进行操作，而没有产生事件的套接字会被过滤掉，极大的提高了IO效率。这<br>一点尤其在套接字监听数量巨大而活跃数量很少的时候很明显。</p></blockquote><p>** _ epoll的用法 _ **</p><pre><code class="hljs">epoll的使用主要在于三个函数。</code></pre><p>** 1. epoll_create(int size); **</p><pre><code class="hljs">创建一个epoll的句柄，size用来告诉内核这个监听的数目最大值。注意!是数量的最大值，不是fd的最大值，切勿搞混。当创建好epoll句柄后，它就是会占用一个fd值，所以在使用完epoll后，必须调用close()关闭，否则可能导致fd被耗尽。</code></pre><p>** 2. int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event); **</p><pre><code class="hljs">epoll的事件注册函数。epfd是epoll的句柄，即epoll_create的返回值；op表示动作：用三个宏表示：EPOLL_CTL_ADD：注册新的fd到epfd中；EPOLL_CTL_MOD：修改已经注册的fd的监听事件；EPOLL_CTL_DEL：从epfd中删除一个fd；fd是需要监听的套接字描述符；event是设定监听事件的结构体，数据结构如下：typedef union epoll_data&#123;    void *ptr;    int fd;    __uint32_t u32;    __uint64_t u64&#125;epoll_data_t;struct epoll_event&#123;  __uint32_t events;  /* Epoll events */  epoll_data_t data;  /* User data variable */&#125;;events可以是以下几个宏的集合：EPOLLIN ：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）；EPOLLOUT：表示对应的文件描述符可以写；EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；EPOLLERR：表示对应的文件描述符发生错误；EPOLLHUP：表示对应的文件描述符被挂断；EPOLLET： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的。EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，就会把这个fd从epoll的队列中删除。如果还需要继续监听这个socket的话，需要再次把这个fd加入到EPOLL队列里</code></pre><p>** 3. int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout); **</p><pre><code class="hljs">等待事件的产生，返回需要处理的事件的数量，并将需处理事件的套接字集合于参数events内，可以遍历events来处理事件。参数epfd为epoll句柄events为事件集合参数timeout是超时时间（毫秒，0会立即返回，-1是永久阻塞）。该函数返回需要处理的事件数目，如返回0表示已超时。</code></pre><p>** 函数使用小例子 **</p><pre><code class="hljs">#include &lt;sys/socket.h&gt;#include &lt;sys/epoll.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;errno.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#define MAXLINE 10   //最大长度#define OPEN_MAX 100#define LISTENQ 20#define SERV_PORT 8000#define INFTIM 1000#define IP_ADDR &quot;10.73.219.151&quot;int main()&#123;    struct epoll_event ev, events[20];    struct sockaddr_in clientaddr, serveraddr;    int epfd;    int listenfd;//监听fd    int maxi;    int nfds;    int i;    int sock_fd, conn_fd;    char buf[MAXLINE];    epfd = epoll_create(256);//生成epoll句柄    listenfd = socket(AF_INET, SOCK_STREAM, 0);//创建套接字    ev.data.fd = listenfd;//设置与要处理事件相关的文件描述符    ev.events = EPOLLIN;//设置要处理的事件类型    epoll_ctl(epfd, EPOLL_CTL_ADD, listenfd, &amp;ev);//注册epoll事件    memset(&amp;serveraddr, 0, sizeof(serveraddr));    serveraddr.sin_family = AF_INET;    serveraddr.sin_addr.s_addr = htonl(INADDR_ANY);    serveraddr.sin_port = htons(SERV_PORT);    bind(listenfd,(struct sockaddr*)&amp;serveraddr, sizeof(serveraddr));//绑定套接口    socklen_t clilen;    listen(listenfd, LISTENQ);//转为监听套接字    int n;    while(1)    &#123;        nfds = epoll_wait(epfd,events,20,500);//等待事件发生        //处理所发生的所有事件        for(i=0;i&lt;nfds;i++)        &#123;            if(events[i].data.fd == listenfd)//有新的连接            &#123;                clilen = sizeof(struct sockaddr_in);                conn_fd = accept(listenfd, (struct sockaddr*)&amp;clientaddr, &amp;clilen);                printf(&quot;accept a new client : %s\n&quot;,inet_ntoa(clientaddr.sin_addr));                ev.data.fd = conn_fd;                ev.events = EPOLLIN;//设置监听事件为可写                epoll_ctl(epfd, EPOLL_CTL_ADD, conn_fd, &amp;ev);//新增套接字            &#125;            else if(events[i].events &amp; EPOLLIN)//可读事件            &#123;                if((sock_fd = events[i].data.fd) &lt; 0)                    continue;                if((n = recv(sock_fd, buf, MAXLINE, 0)) &lt; 0)                &#123;                    if(errno == ECONNRESET)                    &#123;                        close(sock_fd);                        events[i].data.fd = -1;                    &#125;                    else                    &#123;                        printf(&quot;readline error\n&quot;);                    &#125;                &#125;                else if(n == 0)                &#123;                    close(sock_fd);                    printf(&quot;关闭\n&quot;);                    events[i].data.fd = -1;                &#125;                printf(&quot;%d -- &gt; %s\n&quot;,sock_fd, buf);                ev.data.fd = sock_fd;                ev.events = EPOLLOUT;                epoll_ctl(epfd,EPOLL_CTL_MOD,sock_fd,&amp;ev);//修改监听事件为可读            &#125;            else if(events[i].events &amp; EPOLLOUT)//可写事件            &#123;                sock_fd = events[i].data.fd;                printf(&quot;OUT\n&quot;);                scanf(&quot;%s&quot;,buf);                send(sock_fd, buf, MAXLINE, 0);                ev.data.fd = sock_fd;                ev.events = EPOLLIN;                epoll_ctl(epfd, EPOLL_CTL_MOD,sock_fd, &amp;ev);            &#125;        &#125;    &#125;    return 0;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>服务器开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux-C网络编程之select函数</title>
    <link href="/posts/52984.html"/>
    <url>/posts/52984.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>开门见山，如果我们要对多个客户端连接的多个事件进行操作，首先会想到建立多个线程或进程让其去各自进行，这也是最简单的模式。<br>但对每一个线程或进程而言，无论连接是否有事件发生，都必须随时待命，也就是说， ** 每一个对象都必须有一个线程或进程与之一一对应，直到对象销毁 ** 。<br>可想而知，当连接量规模变大后，系统需要在很多个线程或进程之间进行切换，时间与空间上的开销巨大，也就是说，这种模式下，程序能承载对象的最大值是很小的（一般数百<br>个）。</p></blockquote><p>那么，就要提到 ** _ select _ ** 函数了。man select得到函数参数及头文件如下</p><pre><code class="hljs">       #include &lt;sys/select.h&gt;       #include &lt;sys/time.h&gt;       #include &lt;sys/types.h&gt;       #include &lt;unistd.h&gt;       int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);       void FD_CLR(int fd, fd_set *set);//删除fd       int  FD_ISSET(int fd, fd_set *set);//检测fd是否存在于组       void FD_SET(int fd, fd_set *set);//添加fd       void FD_ZERO(fd_set *set);//对组进行清零</code></pre><blockquote><p>** nfds ** ：整型变量，是指集合中所有文件描述符的范围，假如集合中最大文件描述符为 ** max ** ，那么 ** ndfs=max+1<br>** ，千万不要理解为文件描述符的总量。<br>** readfds ** ：指针，指向一组等待可读性检查的套接字集合。<br>** writefds ** ：指针，指向一组等待可写性检查的套接集合。<br>** exceptfds ** ：指针，指向一组等待错误检查的套接集合。<br>** timeout ** ： ** select() ** 最多等待时间，如果为 ** NULL ** ，则相当于阻塞（等待直到事件发生），若为 ** 0 ** 则为非阻塞（没有事件便立即返回），其他值代表若有事件或是超时则返回。</p></blockquote><p>** 函数流程解释及样例 **</p><pre><code class="hljs">    int ret,i，fd[MAX],MAX;    struct timeval timeout;    fd_set readfds;    while(1)    &#123;        timeout.tv_sec = 1;        timeout.tv_usec = 0;        FD_ZERO(&amp;readfds);//组清零初始化        for(i=0;i&lt;MAX;i++)        &#123;            FD_SET(fd[i], &amp;readfds);        &#125;        ret select(MAX,&amp;readfds, NULL,NULL,&amp;timeout);//仅演示读监听，其他同理    &#125;</code></pre><p>_ 将select放在循环体内时，有两点是要特别注意的 _</p><blockquote><p>&lt;1&gt;timeout的初始化，因为select在执行时，对timeout进行的实际是类似于i–的操作，所以循环体内每次都要重新初始化，否则timeout<br>的值将永久是0；<br>&lt;2&gt;文件描述符集合的初始化，因为集合的机理类似于二进制，FD_ZERO()后集合内全部归零（0000000），若FD_SET(5)，则为（0100000）<br>，当selete在执行过程中，发现每个某个连接有事件产生时，便会将该套接字标志为1，没有事件的标志为0，执行完成后，若有事件产生，则可以FD_ISSET(f<br>d，&amp;readfds)来判断fd是否有事件产生。<br>因此，每执行一次select函数，都要重新对集合进行初始化。</p></blockquote><p>select()可以确定一个或多个套接口的状态，常用来实现单进程或单线程的多路复用。<br>也就是说，select可以在一个线程或进程内对多个连接的事件事件进行响应。</p><p>那么它是如何完成这个功能的呢，举个例子来说：<br>假如你在100家不同的店各订了一份外卖（不同的店收货点当然是不同的）。</p><blockquote><ol><li>如果用上述多进程或线程的模式来取外卖的话，你就要再找99个朋友帮你去各个收货点去等待。（多进程模式，哪来的手机！）</li></ol></blockquote><blockquote><ol start="2"><li>你有一盏名叫select的信号灯，你只需要守候在select前，每当一家或多家外卖要送到的时候，都会将信号灯点亮，那么问题来了，你只知道外卖送<br>到了，但却并不知道到底是哪家，所以你需要亲自把100家外卖的送货点全部遍历一遍，取下已到的外卖，然后继续回到信号灯前等待。有什么优点呢，很显然，100个人才<br>能完成的事你一个人就完成了，而且多个外卖可能会同时到，顺风路走了不少嘛。<br>至于缺点嘛，当然是每次都要把100家收货点全部走一遍（减肥也没有这么拼的）</li></ol></blockquote><blockquote><ol start="3"><li>找 ** _ epoll _ **<br>函数，它会给你一部手机，送货师傅外卖送到时可以给你打电话啦。有了手机，这一切该是多么完美，那么会是怎么个完美法呢，下章再谈吧。</li></ol></blockquote><p>ps：好困啊，年纪大了，熬不了夜了！</p>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>服务器开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c++学习笔记（部分语法及c++11新特性）</title>
    <link href="/posts/12135.html"/>
    <url>/posts/12135.html</url>
    
    <content type="html"><![CDATA[<p>** _ 前言 _ **</p><blockquote><p>c++的语法细节实在过杂，再加上c++11的新特性，看了又忘，忘了再看，故讲学习过程所得以笔记形式记录于此。</p></blockquote><p>** 1. c++对变量初始化的形式 **</p><blockquote><p>int a = 0; int a = {0}; int a(0); int a{0};//叫做列表初始化 c++11时，才得以全面应用<br>long double b = 1.02; int a(b); int a=b; //正确：转换执行，但丢失了部分值<br>int a{b}; int a={b};//错误：转换未执行，因为存在丢失信息的危险</p></blockquote><p>** 2. 变量声明和定义的关系 **</p><blockquote><p>extern int x; //为声明 int x; //为定义</p></blockquote><blockquote></blockquote><blockquote><p>任何包含了显示初始化的声明即为定义 如：extern int a=8; //给a赋初始值抵消了extern的作用<br>在函数体内部初始化extern标记的变量 将引发错误</p></blockquote><p>** 3.常量 **</p><blockquote><p>** const限定符 **<br>const a=2; //在预处理时，编译器会讲所有的a全部用2来替换 （和宏定义类似）<br>默认状态下，const对象仅在文件内有效。当多个文件中出现了同名的const变量时，其实等同于在多个文件同时定义变量<br>若想一次定义多次声明式的在多个文件使用，必须在定义和声明时都使用 extern来限定</p></blockquote><blockquote></blockquote><blockquote><p>** const的引用 **<br>const int i=2;<br>const int &amp;r=i;//正确<br>&amp;r=i+1; // 错误<br>既然常量值不允许改变，当然也不能通过引用改变 所以引用也必须为const 类型</p></blockquote><blockquote></blockquote><blockquote><p>** 顶层const和底层const ** const int a= 10；//顶层const</p></blockquote><blockquote></blockquote><blockquote><p>int b=10；<br>int *const p=b；//底层const</p></blockquote><blockquote></blockquote><blockquote><p>简单的说 用const ** 直接 ** 修饰的变量对象等都是顶层const 而 ** 指向const变量或对象的指针和引用 ** 都是底层const</p></blockquote><blockquote></blockquote><blockquote><blockquote><p>特殊：const int a=10; const int *const p=a; 此时p既是顶层const又是底层const</p></blockquote></blockquote><p>** 4.常量表达式 **</p><blockquote><p>** 指值不会改变且在编译过程中就能得到计算结果的表达式 **<br>int a=1；//不是 const int b=2；//是<br>const int c=b+2;//是 const int d=a+b;//不是</p></blockquote><p>** 5.auto类型说明符 **</p><blockquote><p>如果在声明时不知道变量初始化的值和类型 可以用<br>auto int a=5，b=4；<br>auto c = a+b；<br>编译器会通过a+b的值来推算变量的类型 所以auto定义的变量必须有初始值</p></blockquote><p>** 6.decltype类型指示符 **</p><blockquote><p>如果希望从表达式来得到变量类型，但是并不像用变量的值来进行初始化，可以用decltype类型提示符<br>用法 decltype(x) sum = 11;<br>x 可以是函数 f() 可以是变量 可以是表达式 特别的 x可以是引用 引用从来都是做为其所指对象的别名出现<br>只有在此处是个意外 若 int a; decltype((a)) b; 则b是引用类型<br>因为变量a是 ** 可以作为赋值语句左值的特殊表达式 ** 所以(a)的类型便是引用</p></blockquote><p>** 7.类型别名 **</p><blockquote><p>typedef typedef a b 将b作为a的别名<br>using x=y；将x作为y的别名</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux线程初学之实现打字母功能</title>
    <link href="/posts/42950.html"/>
    <url>/posts/42950.html</url>
    
    <content type="html"><![CDATA[<p>** _ 前言 _ **</p><blockquote><p>近日开始了吾之线程学习，略有所得，与进程相比，其可多线程同时执行代码段的特性，实是魅力巨大。<br>窃以为编程学习如武艺修炼，学了招式不过两招实在不应该，故做一打字母，实践练习。</p></blockquote><p>** _ 主要思路 _ **</p><blockquote><p>打字母功能最主要的地方是 “字母不停下落，若按下对应键，字母消失，且在上方出现新的字母，重复此过程”。<br>简而言之，就是在 ** 向屏幕输出信息时还需要实时接受用户按键 ** ，而这与我们之前学习的程序设计顺序执行是相冲突的，但线程可以解决这个问题。</p></blockquote><p>** _ 流程简述 _ **</p><blockquote><ol><li>关闭输入缓冲区以及输入回显。</li></ol></blockquote><blockquote><ol start="2"><li>创建全局变量，保存要显示的字符，以及其坐标位置。<br>初始化字符串，采用随机数的方式为其赋值，并为其坐标赋值。</li></ol></blockquote><blockquote><ol start="3"><li>创建新线程，线程对应函数功能为 清屏后输出输出字符于各自对应坐标 并每次循环后，给每个子符的x坐标值加一</li></ol></blockquote><blockquote><ol start="4"><li>在原线程中也设置一循环，实时接收用户输入，根据用户输入 判断按键是否正确，若正确则重新对该字符随机赋值，否则重新输入。</li></ol></blockquote><blockquote><ol start="5"><li>实时判断，是否有字母超过下边界，若有，则程序结束</li></ol></blockquote><blockquote><ol start="6"><li>输入缓存区与输入回显</li></ol></blockquote><p>** _ 代码 _ **</p><pre><code class="hljs">#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;#include&lt;pthread.h&gt;#include&lt;unistd.h&gt;#include&lt;time.h&gt;char str[10];char x[10];char y[10];int* thread()&#123;    int i;    while(1)    &#123;        system(&quot;clear&quot;);        for(i=0;i&lt;10;i++)        &#123;//输出字符于对应坐标            printf(&quot;\033[%d;%dH%c\n&quot;,x[i],y[i],str[i]);            x[i]++;        &#125;        sleep(1);    &#125;    return NULL;&#125;int main()&#123;    pthread_t thid;    int i;    char c=&#39;\0&#39;;    system(&quot;stty -icanon&quot;);    system(&quot;stty -echo&quot;);    srand((unsigned)time(NULL));    for(i=0;i&lt;10;i++)    &#123;//字符串初始化        str[i] = &#39;a&#39; + rand()%26;        x[i] = 2;        y[i] = i*3+3;    &#125;    //创建线程    if( pthread_create(&amp;thid,NULL,(void*)thread,(void*)&amp;i)       != 0 )    &#123;        printf(&quot;Error!\n&quot;);        exit(1);    &#125;    while(1)    &#123;        c = getchar();        if(c!=&#39;\0&#39;)        &#123;            for(i=0;i&lt;10;i++)            &#123;                if(c == str[i])                &#123;                    str[i] = &#39;a&#39;+rand()%26;                    x[i] = 2;                    c=&#39;\0&#39;;                    break;                &#125;            &#125;        &#125;        for(i=0;i&lt;10;i++)        &#123;            if(x[i]&gt;=20)            &#123;                break;            &#125;        &#125;    &#125;    system(&quot;stty icanonon&quot;);    system(&quot;stty echo&quot;);    return 0;&#125;</code></pre><p>** _ 结语 _ **</p><blockquote><p>因为主要目的是对线程的学习，所以在打字母的基本功能实现后并未实现其他功能。<br>毕竟是初学，有什么地方有误，欢迎批评指正。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>服务器开发</tag>
      
      <tag>Linux网络编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux文件管理小结之自定义more</title>
    <link href="/posts/4166.html"/>
    <url>/posts/4166.html</url>
    
    <content type="html"><![CDATA[<p>** _ 1.more命令功能 _ **</p><blockquote><p>more命令用于查看内容超过一屏的文本(类似于cat)<br>** 基本功能 ** ：<br>1.输入backspace ：内容翻一屏<br>2.输入enter ： 内容翻一行<br>3.输入q：退出<br>4.实时显示已读文件比例</p></blockquote><p>** _ 2.实现思路 _ **</p><blockquote><ol><li>从命令中获取需要操作的文件</li></ol></blockquote><blockquote><ol start="2"><li>打开文件：open(filename,O_RDONLY);</li></ol></blockquote><blockquote><ol start="3"><li>获取文件总行数：<br>lseek(fd,0,SEEK_END);//移动文件指针至文件末<br>page_sum = lseek(fd,0,SEEK_CUR);//计算与文件头偏移量，即可得到文件总行数</li></ol></blockquote><blockquote><ol start="4"><li>命令初始读取内容(定义整屏为10行)<br>设置一标志量 存储 每次需要显示的行数，假设n，则执行n次下操作<br>用read(fd,str,1); 每次读取一个字节，读到’\n’停止<br>并且在每次读完之后需要用lseek(fd,0,SEEK_CUR)来获取当前已显示行数，用于得到文件已阅比例</li></ol></blockquote><blockquote><ol start="5"><li>每次操作完成后接受用户指令<br>see_more();<br>函数接受用户输入，根据输入值返回要翻的页数</li></ol></blockquote><blockquote><ol start="6"><li>close(fd);</li></ol></blockquote><p>** _ 过程收获 _ **</p><blockquote><ol><li>反显文字：<br>做这个时才了解到linux 上 printf的功能好丰富，清屏，移动光标，一应俱全；</li></ol></blockquote><blockquote><ol start="2"><li>保证more的提示信息总显示在终端的最下端，并不重复显示<br>刚开始准备使用，printf(“\033[s”)记录光标位置，输出后，再用printf(“\033[u\033[K”);光标归位并清行；<br>然而在输出提示信息中，还需要接受用户的输入，会产生换行符，而换行之后，光标归位会失效，记录于此。<br>最终是用printf(“\033[1A\033[K”)将光标上移一行，并清空该行内容，用以覆盖提示信息</li></ol></blockquote><blockquote><ol start="3"><li>文件比例的实现<br>这个的实现细节上文已经提到，之所以再做赘述，是因为笔者在实现过程中因为此功能卡顿很久<br>因为需要按行读的缘故，想要使用fgets()来读取文本，但是打开文件又用的是系统函数open(),而非fopen(),于是就产生了混用的情况。<br>而结果是每次用lseek()读取当前文件指针偏移量时，得到的值都是文件首与文件尾的偏移量，改为fseek()后，值变为0，探究无果，不知其因，记录于此，日后<br>再谈</li></ol></blockquote><p>** _ 代码 _ **</p><pre><code class="hljs">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#define PAGENUM 10 //定义一屏为10行void do_more(int fd);int see_more(  int sum, int now);int main( int argc, char **argv )&#123;    int fd;    if( argc == 1 )//参数不合法则返回    &#123;        return 0;    &#125;    else    &#123;        while( argc--&gt;1 )        &#123;            if( (fd = open(*++argv,O_RDONLY)) != -1 )            &#123;                do_more(fd);                close(fd);            &#125;            else            &#123;                printf(&quot;Error: can&#39;t open file\n&quot;);                exit(1);            &#125;        &#125;    &#125;    return 0;&#125;void do_more(int fd)&#123;    char str[3];    int page_num = 0;//保存每次需要跳转的行数    int rel;    int page_now = 0;//保存当前行数（初始为0）    int page_sum;//保存总行数    lseek(fd,0,SEEK_END);//移动文件指针至文件末    page_sum = lseek(fd,0,SEEK_CUR);//计算与文件头偏移量，即文件总行数    lseek(fd,0,SEEK_SET);//移动文件指针至文件头    while( page_now&lt;page_sum )    &#123;        while(read(fd,str,1))//每次读一行        &#123;            if(str[0] ==&#39;\n&#39;)            &#123;                printf(&quot;\n&quot;);                break;            &#125;            printf(&quot;%c&quot;,str[0]);        &#125;        page_now = lseek(fd, 0, SEEK_CUR);//实时更新已读行数        if( page_num == PAGENUM )        &#123;            rel = see_more( page_sum, page_now);//获取用户输入            printf(&quot;\033[1A\033[K&quot;);//将光标上移一行，并清空该行内容，用以覆盖提示信息            if( rel == 0 )            &#123;                break;            &#125;            else            &#123;                page_num -= rel;            &#125;        &#125;        page_num++;    &#125;&#125;int see_more(int sum,int now)&#123;    int rel;    printf(&quot;\033[7m --更多-- enter翻行 backspace翻页 q退出  %.2f%% \033[0m&quot;,now*100.0/sum);//反显输出提示信息以及文件已读比例    while(rel = getchar())    &#123;        if(rel == &#39;q&#39;)        &#123;            return 0;        &#125;        if(rel == &#39; &#39;)        &#123;            return PAGENUM;        &#125;        if(rel == &#39;\n&#39;)        &#123;            return 1;        &#125;    &#125;    return 0;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>服务器开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树状数组学习（一维）</title>
    <link href="/posts/60465.html"/>
    <url>/posts/60465.html</url>
    
    <content type="html"><![CDATA[<p>** 算法描述 **</p><blockquote><p>可以对给定序列进行查询和修改<br>查询：主要用来查询任意两位之间数据和<br>修改：修改单项数据值<br>时间复杂度：log(n)</p></blockquote><p>** 算法思想 **</p><p>_ 1.数组的构建 _</p><blockquote><p>定义 数组C A<br>C1 = A1<br>C2 = A1 + A2<br>C3 = A3<br>C4 = A1 + A2 + A3 + A4<br>C5 = A5<br>C6 = A5 + A6<br>C7 = A7<br>C8 = A1 + A2 + A3 + A4 + A5 + A6 + A7 + A8<br>…<br>不难看出，其实是实现了对A的数据的分别管辖，Cn的管辖数量为 将n化为二进制数后，末尾连续零的数量； 也可这样理解，n的二进制位末尾有连续的k个0 ; 则<br>2^k 即为Cn的管辖数量<br>这里介绍一种求2^k的方法，后面会用到</p></blockquote><pre><code class="hljs">int lowbit(int x)&#123;    return x&amp;(-x); //运用位运算及机器补码&#125;</code></pre><blockquote><p>调用 lowbit(n) , 即可得出Cn的管辖数量<br>而Cn的管辖范围为 ： n-lowbit(n)+1 到 n</p></blockquote><pre><code class="hljs">void make_tree(int n)&#123;    for(int i=1;i&lt;=n;i++)    &#123;        for(int j=i-lowbit(i)+1;j&lt;=i;j++)        &#123;            c[i]+=a[j];        &#125;    &#125;&#125;</code></pre><p>_ 2.求和 _</p><blockquote><p>令sum=0；<br>遍历，每次将n的二进制数最后一位1 化为 0 ，依次 sum += C[n]，n=n-lowbit(n)，直到n&lt;=0；<br>sum值即为序列 1 ～ n 的总和</p></blockquote><pre><code class="hljs">int make_sum(int n)&#123;    int sum=0;    while(n&gt;0)    &#123;        sum+=c[n];        n-=lowbit(n);    &#125;    return sum;&#125;</code></pre><p>_ 3.修改单项数据 _</p><blockquote><p>对每个包含Ai 的 Cn进行修改</p></blockquote><pre><code class="hljs">void modify(int n,int i,int num)&#123;    while(i&lt;=n)    &#123;        c[i]+=num-a[i];        i+=lowbit(i);    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 11 -- Container With Most Water</title>
    <link href="/posts/22269.html"/>
    <url>/posts/22269.html</url>
    
    <content type="html"><![CDATA[<p>** 题目 **</p><blockquote><p>Given n non-negative integers a1, a2, …, an, where each represents a point<br>at coordinate (i, ai). n vertical lines are drawn such that the two endpoints<br>of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis<br>forms a container, such that the container contains the most water.</p></blockquote><blockquote></blockquote><blockquote><p>Note: You may not slant the container.</p></blockquote><p>** 题意 **</p><blockquote><p>从给定数组a[i]中找出 i，j使得 abs(j-i)*min(a[i],a[j])值最大</p></blockquote><p>** 思路 **</p><blockquote><p>刚开始使用两重循环，o(n^2)，超时；改为贪心思想，每次只尝试有可能更优的解，最终遍历完后，时间复杂度o(n);<br>具体步骤 设i位于序列首，j位于序列尾，则若a[i]</p></blockquote><pre><code class="hljs">int maxArea(int* height, int heightSize)&#123;    int max=0,f,a,i=0,j=heightSize-1;    while(i&lt;j)    &#123;        f=height[i]&lt;height[j]?1:0;        if(f)        &#123;            a=(j-i)*height[i];            i++;        &#125;        else        &#123;            a=(j-i)*height[j];            j--;        &#125;        if(a&gt;max)        &#123;            max=a;        &#125;    &#125;    return max;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 10 -- Regular Expression Matching</title>
    <link href="/posts/65286.html"/>
    <url>/posts/65286.html</url>
    
    <content type="html"><![CDATA[<p>** 前言 **</p><blockquote><p>初看到这道题，毫无思路，逃避好几天，看学长博客，才找到思路，即使这样，仍调试好大一会儿，刷题好痛苦。。。</p></blockquote><p>** 题目 **</p><blockquote><p>Implement regular expression matching with support for ‘.’ and ‘<em>’.<br>‘.’ Matches any single character.<br>‘</em>’ Matches zero or more of the preceding element.</p></blockquote><blockquote></blockquote><blockquote><p>The matching should cover the entire input string (not partial).</p></blockquote><blockquote></blockquote><blockquote><p>The function prototype should be:<br>bool isMatch(const char *s, const char *p)</p></blockquote><blockquote></blockquote><blockquote><p>Some examples:<br>isMatch(“aa”,”a”) → false<br>isMatch(“aa”,”aa”) → true<br>isMatch(“aaa”,”aa”) → false<br>isMatch(“aa”, “a<em>”) → true<br>isMatch(“aa”, “.*”) → true<br>isMatch(“ab”, “.*”) → true<br>isMatch(“aab”, “c</em>a*b”) → true</p></blockquote><p>** 题意 **</p><blockquote><p>完成类似正则表达式的匹配功能</p></blockquote><p>** 思路 **</p><blockquote><p>针对p[1]是否等于*来进行递归滑动</p></blockquote><p>** 代码 **</p><pre><code class="hljs">bool isMatch(char *s,char *p)&#123;    if(p[0]==&#39;\0&#39;)    &#123;        return s[0]==&#39;\0&#39;;    &#125;    if(s[0]==&#39;\0&#39;)    &#123;        if(p[1]==&#39;*&#39;)        &#123;            return isMatch(s,p+2);        &#125;        return false;    &#125;    if(p[1]==&#39;*&#39;)    &#123;        if(s[0]==p[0]||p[0]==&#39;.&#39;)        &#123;            if(strlen(p)&gt;=4 &amp;&amp; p[0]==p[2] &amp;&amp; p[3]==&#39;*&#39;)                return isMatch(s,p+2);//此处总觉得是有些取巧，针对超时            return isMatch(s+1,p)||isMatch(s+1,p+2)||isMatch(s,p+2);        &#125;        else        &#123;            return isMatch(s,p+2);        &#125;    &#125;    else    &#123;        if(s[0]==p[0]||p[0]==&#39;.&#39;)        &#123;            return isMatch(s+1,p+1);        &#125;    &#125;    return false;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 9 -- Palindrome Number</title>
    <link href="/posts/11530.html"/>
    <url>/posts/11530.html</url>
    
    <content type="html"><![CDATA[<p>** 题目 **</p><blockquote><p>Determine whether an integer is a palindrome. Do this without extra space.<br>Some hints:<br>Could negative integers be palindromes? (ie, -1)</p></blockquote><blockquote></blockquote><blockquote><p>If you are thinking of converting the integer to string, note the<br>restriction of using extra space.</p></blockquote><blockquote></blockquote><blockquote><p>You could also try reversing an integer. However, if you have solved the<br>problem “Reverse Integer”, you know that the reversed integer might overflow.<br>How would you handle such case?</p></blockquote><blockquote></blockquote><blockquote><p>There is a more generic way of solving this problem.</p></blockquote><p>** 题意 **</p><blockquote><p>判断给定数字是不是回文数，要求不能使用多余的空间，即不能开辟字符串来判断，而且要小心越界的情况，即不能直接逆向跟原数来比较</p></blockquote><p>** 思路 **</p><blockquote><p>将数字二分(若位数为奇，则不要中间位) 逆转后一部分，比较大小（可以避免越界问题）</p></blockquote><p>** 代码 **</p><pre><code class="hljs">bool isPalindrome(int x) &#123;    int t=x;    int i,z=0,num,sum=0;    if(x&lt;0)    &#123;        return false;    &#125;    if(x&lt;10)    &#123;        return true;    &#125;    while(t)    &#123;        sum++;        t/=10;    &#125;    num=sum/2;    while(num--)    &#123;        z=z*10+x%10;        x/=10;    &#125;    if(sum%2)    &#123;        x/=10;    &#125;    if(x==z)    &#123;        return true;    &#125;    else    &#123;        return false;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 8 -- String to Integer (atoi)</title>
    <link href="/posts/54003.html"/>
    <url>/posts/54003.html</url>
    
    <content type="html"><![CDATA[<p>** 题目 **</p><blockquote><p>Implement atoi to convert a string to an integer.</p></blockquote><blockquote></blockquote><blockquote><p>Hint: Carefully consider all possible input cases. If you want a challenge,<br>please do not see below and ask yourself what are the possible input cases.</p></blockquote><blockquote></blockquote><blockquote><p>Notes: It is intended for this problem to be specified vaguely (ie, no given<br>input specs). You are responsible to gather all the input requirements up<br>front.</p></blockquote><blockquote></blockquote><blockquote><p>Requirements for atoi:<br>The function first discards as many whitespace characters as necessary until<br>the first non-whitespace character is found. Then, starting from this<br>character, takes an optional initial plus or minus sign followed by as many<br>numerical digits as possible, and interprets them as a numerical value.</p></blockquote><blockquote></blockquote><blockquote><p>The string can contain additional characters after those that form the<br>integral number, which are ignored and have no effect on the behavior of this<br>function.</p></blockquote><blockquote></blockquote><blockquote><p>If the first sequence of non-whitespace characters in str is not a valid<br>integral number, or if no such sequence exists because either str is empty or<br>it contains only whitespace characters, no conversion is performed.</p></blockquote><blockquote></blockquote><blockquote><p>If no valid conversion could be performed, a zero value is returned. If the<br>correct value is out of the range of representable values, INT_MAX<br>(2147483647) or INT_MIN (-2147483648) is returned.</p></blockquote><p>** 题意 **</p><blockquote><p>将字符串转化为整形数字输出<br>注意三个问题 ：<br>一是字符串开头空格的问题<br>二是正负号<br>数值越界问题 （题意已提到 若越界则输出INT-MAX 或 INT-MIN）</p></blockquote><p>** 思路 **</p><blockquote><p>此题较简单，不做赘述，见代码注释</p></blockquote><p>** 代码 **</p><pre><code class="hljs">int myAtoi(char* str) &#123;    int i=0;    long long rel;//考虑到越界问题用longlong保存    while(str[i]==&#39; &#39;)&#123;i++;&#125;    //消除空格    rel=atol(str);//此处取巧了 用了atol    if(rel&gt;INT_MAX)//处理越界    &#123;        return INT_MAX;    &#125;    else if(rel&lt;INT_MIN)    &#123;        return INT_MIN;    &#125;    return rel;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 7 -- Reverse Integer</title>
    <link href="/posts/47408.html"/>
    <url>/posts/47408.html</url>
    
    <content type="html"><![CDATA[<p>** 题目 **</p><blockquote><p>Reverse digits of an integer.</p></blockquote><blockquote></blockquote><blockquote><p>Example1: x = 123, return 321<br>Example2: x = -123, return -321</p></blockquote><p>** 题意 **</p><blockquote><p>将整型数逆置，返回int<br>要考虑数据溢出 若溢出 返回 0<br>还有尾部有零的问题 如 x=1200 return 0021 吗?</p></blockquote><p>** 思路 **</p><blockquote><p>若为负，先标记并转为正，按位将正整数保存于数组，反向计算新结果保存与longlong里，并求出int32最大值2^31-1 通过比较大小确定是否溢出</p></blockquote><p>** 代码 **</p><pre><code class="hljs">int reverse(int x) &#123;    int i,j,f=0,a[20];    long long rel=0,num=1;    for(i=0;i&lt;31;i++)    &#123;        num*=2;    &#125;    num--;    if(x&lt;0)    &#123;        f=1;        x*=-1;    &#125;    i=0;    while(x&gt;0)    &#123;        a[i++]=x%10;        x/=10;    &#125;    for(j=0;j&lt;i;j++)    &#123;        rel=rel*10+a[j];    &#125;    if(rel&gt;num)    &#123;        return 0;    &#125;    if(f==1)    &#123;        rel*=-1;    &#125;    return rel;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 6 -- ZigZag Conversion</title>
    <link href="/posts/21657.html"/>
    <url>/posts/21657.html</url>
    
    <content type="html"><![CDATA[<p>** 题目 **</p><blockquote><p>The string “PAYPALISHIRING” is written in a zigzag pattern on a given number<br>of rows like this: (you may want to display this pattern in a fixed font for<br>better legibility)</p></blockquote><p>** 题意 **</p><blockquote><p>将字符串按照锯齿形(N字形)排列，然后把从上到下把所有行按从做到右的顺序组成新的字符串<br>ps:其实我刚开始也把题意理解错了，wr了好几次，于是乎去学长博客取经后才理解。</p></blockquote><pre><code class="hljs">    关于锯齿形解释如下：            1---------------7            2---------6----8------------12            3----5---------9------11            4--------------10</code></pre><blockquote><p>大概就是这个重组模式，不要嫌弃描述太抽象，图片上传不上来，空格显示不出来，我也无奈</p></blockquote><p>** 思路 **</p><blockquote><p>分两个部分，一是最顶行和最底行，二是中间，分别对两个部分找规律了</p></blockquote><p>** 代码 **</p><pre><code class="hljs">char* convert(char* s, int numRows) &#123;    char *a=(char*)malloc(sizeof(char)*(strlen(s)+1));    int i,j,l,k=0,num=numRows*2-2;    if(strlen(s)&lt;=numRows || numRows==1)    &#123;        return s;    &#125;    for(i=0;i&lt;numRows;i++)    &#123;        if(i==0 || i==numRows-1)        &#123;            j=i;            while(j&lt;strlen(s))            &#123;                a[k++]=s[j];                j+=num;            &#125;        &#125;        else        &#123;            j=i;            l=num-i;            while(j&lt;strlen(s) || l&lt;strlen(s))            &#123;                if(j&lt;strlen(s))                &#123;                    a[k++]=s[j];                    j+=num;                &#125;                if(l&lt;strlen(s))                &#123;                    a[k++]=s[l];                    l+=num;                &#125;            &#125;        &#125;    &#125;    a[k]=&#39;\0&#39;;    return a;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 5 -- Longest Palindromic Substring</title>
    <link href="/posts/35808.html"/>
    <url>/posts/35808.html</url>
    
    <content type="html"><![CDATA[<p>** 题目 **</p><blockquote><p>Given a string S, find the longest palindromic substring in S. You may<br>assume that the maximum length of S is 1000, and there exists one unique<br>longest palindromic substring.</p></blockquote><p>** 题意 **</p><blockquote><p>从字符串中找出最长回文子串，将其另存新串，返回指针</p></blockquote><p>** 思路 **</p><blockquote><p>回文串只有两种类型，长度为偶数和长度为奇数型<br>遍历字符串s：<br>–奇数型：以s[i]为中心，向两边延伸判断<br>–偶数型：以s[i]和s[i+1]为起点分别延伸<br>每次判断完后，记录子串</p></blockquote><p>** 代码 **</p><pre><code class="hljs">char* longestPalindrome(char* s) &#123;    char *a=(char *)malloc(sizeof(char)*1001);//开辟空间    int i,j,k,max = 0;    for(i=0;i&lt;strlen(s);i++)    &#123;        j=0;        while(s[i-j] == s[i+j] &amp;&amp; i-j&gt;=0 &amp;&amp; i+j &lt; strlen(s))//奇数型        &#123;            j++;        &#125;        if(j*2-1 &gt; max)        &#123;            max = j*2 - 1;            for(k=0;k&lt;j*2-1;k++)            &#123;                a[k]=s[k+i-j+1];            &#125;            a[k]=&#39;\0&#39;;        &#125;        j=0;        while(s[i-j] == s[i+j+1] &amp;&amp; i-j&gt;=0 &amp;&amp; i+j+1&lt;strlen(s))//偶数型        &#123;            j++;        &#125;        if(j*2 &gt; max)        &#123;            max = j*2;            for(k=0;k&lt;j*2;k++)            &#123;                a[k]=s[k+i-j+1];            &#125;            a[k]=&#39;\0&#39;;        &#125;    &#125;    return a;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 4 -- Median of Two Sorted Arrays</title>
    <link href="/posts/18812.html"/>
    <url>/posts/18812.html</url>
    
    <content type="html"><![CDATA[<p>** 题目 **</p><blockquote><p>There are two sorted arrays nums1 and nums2 of size m and n respectively.<br>Find the median of the two sorted arrays. The overall run time complexity<br>should be O(log (m+n)).</p></blockquote><p>** 题意 **</p><blockquote><p>给定两有序数组，是否为空未知，升序降续未知。合并两数组并排序，返回新数组的中位数 要求时间复杂度为O(log (m+n))</p></blockquote><p>** 思路 **</p><blockquote><p>其实就是合并数组找k大数，只是题目给定数组的可能性比较多，所以细节上会有些麻烦，具体见代码注释</p></blockquote><blockquote></blockquote><blockquote><p>我的复杂度是O(m+n)，与题目要求差不止一档，但还是ac了。</p></blockquote><blockquote></blockquote><blockquote><p>想了想要是按题目要求的复杂度，应该是类似求逆序对数的跳跃式计数，具体细节想想就头大，等个黄道吉日再好好尝试下</p></blockquote><p>** 代码 **</p><pre><code class="hljs">double findMedianSortedArrays(int* nums1, int nums1Size, int* nums2, int nums2Size)&#123;    int rel1=0,rel2=0,f1,f2,i=0,num,start1,end1,start2,end2;    num=(nums1Size+nums2Size)/2;//因为数组总长度可能偶数位，所以创两个rel来保存结果    if(nums1[0]&lt;=nums1[nums1Size-1])    &#123;        start1=0;//起点        end1=nums1Size-1;//终点        f1=1;//标记升序或逆序    &#125;    else    &#123;        end1=0;        start1=nums1Size-1;        f1=0;    &#125;    if(nums2[0]&lt;=nums2[nums2Size-1])    &#123;        start2=0;        end2=nums2Size-1;        f2=1;    &#125;    else    &#123;        end2=0;        start2=nums2Size-1;        f2=0;    &#125;    while(i&lt;=num)//找num次    &#123;        if(start1&gt;end1&amp;&amp;f1==1 || start1&lt;end1&amp;&amp;f1==0)//判断nums1是否已遍历完，同时，数组为空的情况也会在次处理        &#123;            rel1=rel2;            rel2=nums2[start2];            if(f2)            &#123;                start2++;//升序+            &#125;            else            &#123;                start2--;//逆序-            &#125;        &#125;        else if(start2&gt;end2&amp;&amp;f2==1 || start2&lt;end2&amp;&amp;f2==0)        &#123;            rel1=rel2;            rel2=nums1[start1];            if(f1)            &#123;                start1++;            &#125;            else            &#123;                start1--;            &#125;        &#125;        else if(nums1[start1]&lt;=nums2[start2])//若两数组都未遍历完则比较大小        &#123;            rel1=rel2;            rel2=nums1[start1];            if(f1)            &#123;                start1++;            &#125;            else            &#123;                start1--;            &#125;        &#125;        else        &#123;            rel1=rel2;            rel2=nums2[start2];            if(f2)            &#123;                start2++;            &#125;            else            &#123;                start2--;            &#125;        &#125;        i++;    &#125;    return (nums1Size+nums2Size)%2==0 ? (double)((rel1+rel2)*1.0/2.0) : rel2;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 3 -- Longest Substring Without Repeating Characters</title>
    <link href="/posts/13788.html"/>
    <url>/posts/13788.html</url>
    
    <content type="html"><![CDATA[<p>** 题目 **</p><blockquote><p>Given a string, find the length of the longest substring without repeating<br>characters. For example, the longest substring without repeating letters for<br>“abcabcbb” is “abc”, which the length is 3. For “bbbbb” the longest substring<br>is “b”, with the length of 1.</p></blockquote><p>** 题意 **</p><blockquote><p>从字符串中找出最长不重复子串的长度</p></blockquote><p>** 思路 **</p><blockquote><p>首先想到二重循环，提交果断超时。改为一旦重复，则仅对子串的首尾进行操作，然后开始下次判断</p></blockquote><p>** 代码 **</p><pre><code class="hljs">int lengthOfLongestSubstring(char* s) &#123;    int i,j,max=0,num=0,flag[300]=&#123;0&#125;;    for(i=0;i&lt;strlen(s);i++)    &#123;        j=i+num;        if(!flag[(int)(s[j])])        &#123;            while(!flag[(int)(s[j])] &amp;&amp; j&lt;strlen(s))            &#123;                num++;                flag[(int)(s[j])]=1;                j++;            &#125;            flag[(int)(s[i])]=0;            if(num&gt;max)            &#123;                max=num;            &#125;            num--;        &#125;        else        &#123;            flag[(int)(s[i])]=0;            num--;        &#125;    &#125;    return max;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>影院管理系统（GTK）</title>
    <link href="/posts/9485.html"/>
    <url>/posts/9485.html</url>
    
    <content type="html"><![CDATA[<p>** 前言 **</p><blockquote><p>补高数作业到现在也是醉了，索性不睡了，把前段时间做的课设整理一下，毕竟是小白，有什么地方有错误，还望大神不吝指出</p></blockquote><p>** 感触与收获 **</p><blockquote><p>在写之前，本以为最大的难关是图形界面的构建，后来又认为是程序与文件的交互，最终完成后才明白，怎样不再庞大的代码堆中逻辑错乱才是最大的难关，而这就关系到下<br>面几个问题了</p></blockquote><p>** 1.代码架构问题 **</p><blockquote><p>刚开始写时，按以前习惯把全部代码全部写在了一个源文件里，随着代码越写越多，苦不堪言，于是乎，参考书上样例的架构，总算是有点逻辑分明的感觉</p></blockquote><p>如下</p><blockquote><p>main.c 主函数<br>interface.c 窗口实现函数<br>interface.h 窗口实现函数声明<br>callback.c 回调函数<br>callback.h 回调函数声明 以及 全局变量和结构体的定义</p></blockquote><p>** 2.代码编写的习惯问题 **</p><blockquote><p>&lt;1&gt;变量的命名<br>这个是令我感触最深，因为英语不好哦，所以常随心所欲的设置变量&gt;名，后来变量越来越多，痛苦不期而至，后不得不<br>用有道辅助对所有变量重新命名，重新观看代码，才觉变量命名的重要性<br>&lt;2&gt;添加必要的注释<br>代码量大了后，方知注释的重要，可惜还是懒，注释的太少，要养成这个好习惯<br>&lt;3&gt;代码缩进<br>也就在这个上面做的还行，归功于我的强迫症</p></blockquote><p>** 代码 **</p><p>** main.c **</p><pre><code class="hljs">#include&lt;gtk/gtk.h&gt;#include&quot;interface.h&quot;#include&quot;callback.h&quot;int main(int argc,char *argv[])&#123;    gtk_init(&amp;argc , &amp;argv);    theater_num = 0;    window_main = make_window_main();    window_main_buy = make_window_main_buy();    window_main_login = make_window_main_login();    window_change_yesorno = make_window_yesorno();    window_main_change = make_window_main_change();    gtk_widget_show_all(window_main);    gtk_main();    return 0;&#125;</code></pre><p>** interface.c **</p><pre><code class="hljs">#include&lt;gtk/gtk.h&gt;#include&quot;callback.h&quot;#include&lt;stdlib.h&gt;//extern struct findrc *q;GtkWidget* make_window_main()//创建主页面&#123;    GtkWidget *window;    GtkWidget *button_buy;    GtkWidget *button_change;    GtkWidget *button_quit;    GtkWidget *image;    GtkWidget *box_b;    GtkWidget *box_s;    window = gtk_window_new(GTK_WINDOW_TOPLEVEL);    gtk_container_set_border_width(GTK_CONTAINER(window),10);    gtk_window_set_title(GTK_WINDOW(window),&quot;影院系统&quot;);    gtk_window_set_position(GTK_WINDOW(window),GTK_WIN_POS_CENTER);    //gtk_window_set_default_size(GTK_WINDOW(window),10,10);    g_signal_connect(G_OBJECT(window),&quot;delete_event&quot;,G_CALLBACK(want_to_quit),NULL);    box_b = gtk_vbox_new(FALSE,10);    gtk_container_add(GTK_CONTAINER(window),box_b);    image = gtk_image_new_from_file(&quot;3.png&quot;);    box_s = gtk_hbox_new(TRUE,10);    gtk_box_pack_start(GTK_BOX(box_b),image,TRUE,FALSE,0);    gtk_box_pack_start(GTK_BOX(box_b),box_s,TRUE,FALSE,0);    button_buy = gtk_button_new_with_label(&quot;开始购票&quot;);    button_change = gtk_button_new_with_label(&quot;管理登录&quot;);    button_quit = gtk_button_new_with_label(&quot;退出系统&quot;);    g_signal_connect(G_OBJECT(button_buy),&quot;clicked&quot;,G_CALLBACK(on_main_to_buy),NULL);    g_signal_connect(G_OBJECT(button_change),&quot;clicked&quot;,G_CALLBACK(on_main_to_login),NULL);    g_signal_connect(G_OBJECT(button_quit),&quot;clicked&quot;,G_CALLBACK(want_to_quit),NULL);    gtk_box_pack_start(GTK_BOX(box_s),button_buy,TRUE,FALSE,0);    gtk_box_pack_start(GTK_BOX(box_s),button_change,TRUE,FALSE,0);    gtk_box_pack_start(GTK_BOX(box_s),button_quit,TRUE,FALSE,0);    return window;&#125;void on_dian_jie(struct theater* p,GtkWidget *boxs)//创建单项影片信息&#123;    GtkWidget *button;    GtkWidget *image;    GtkWidget *label;    GtkWidget *frame;    GtkWidget *frame1;    GtkWidget *vbox;    GtkWidget *hbox;    GtkWidget *tbox;    GtkWidget *box;    box = gtk_hbox_new(FALSE,10);    gtk_container_add(GTK_CONTAINER(boxs),box);    image = gtk_image_new_from_file(p-&gt;photo);    gtk_box_pack_start_defaults(GTK_BOX(box),image);    frame1 = gtk_frame_new(NULL);    gtk_container_add(GTK_CONTAINER(box),frame1);    gtk_widget_set_size_request(GTK_WIDGET(frame1),800,300);    hbox = gtk_hbox_new(TRUE,0);    gtk_container_add(GTK_CONTAINER(frame1),hbox);    vbox = gtk_vbox_new(FALSE,0);    gtk_container_add(GTK_CONTAINER(hbox),vbox);    frame = gtk_frame_new(&quot;影片名&quot;);    label = gtk_label_new(p-&gt;name);    gtk_label_set_line_wrap (GTK_LABEL(label),TRUE);    gtk_container_add(GTK_CONTAINER(frame),label);    gtk_label_set_justify(GTK_LABEL(label),GTK_JUSTIFY_LEFT);    gtk_box_pack_start_defaults(GTK_BOX(vbox),frame);    frame = gtk_frame_new(&quot;影片类型&quot;);    label = gtk_label_new(p-&gt;type);    gtk_label_set_line_wrap (GTK_LABEL(label),TRUE);    gtk_container_add(GTK_CONTAINER(frame),label);    gtk_label_set_justify(GTK_LABEL(label),GTK_JUSTIFY_LEFT);    gtk_box_pack_start_defaults(GTK_BOX(vbox),frame);    frame = gtk_frame_new(&quot;影片简介&quot;);    label = gtk_label_new(p-&gt;message);    gtk_label_set_line_wrap (GTK_LABEL(label),TRUE);    gtk_container_add(GTK_CONTAINER(frame),label);    gtk_label_set_justify(GTK_LABEL(label),GTK_JUSTIFY_LEFT);    gtk_box_pack_start_defaults(GTK_BOX(vbox),frame);    vbox = gtk_vbox_new(FALSE,0);    gtk_container_add(GTK_CONTAINER(hbox),vbox);    frame = gtk_frame_new(&quot;主演&quot;);    label = gtk_label_new(p-&gt;people);    gtk_label_set_line_wrap (GTK_LABEL(label),TRUE);    gtk_container_add(GTK_CONTAINER(frame),label);    gtk_label_set_justify(GTK_LABEL(label),GTK_JUSTIFY_LEFT);    gtk_box_pack_start_defaults(GTK_BOX(vbox),frame);    tbox = gtk_hbox_new(TRUE,0);    gtk_container_add(GTK_CONTAINER(vbox),tbox);    frame = gtk_frame_new(&quot;放映时间&quot;);    label = gtk_label_new(p-&gt;time);    gtk_label_set_line_wrap (GTK_LABEL(label),TRUE);    gtk_container_add(GTK_CONTAINER(frame),label);    gtk_label_set_justify(GTK_LABEL(label),GTK_JUSTIFY_LEFT);    gtk_box_pack_start_defaults(GTK_BOX(tbox),frame);    frame = gtk_frame_new(&quot;放映地点&quot;);    label = gtk_label_new(p-&gt;place);    gtk_label_set_line_wrap (GTK_LABEL(label),TRUE);    gtk_container_add(GTK_CONTAINER(frame),label);    gtk_label_set_justify(GTK_LABEL(label),GTK_JUSTIFY_LEFT);    gtk_box_pack_start_defaults(GTK_BOX(tbox),frame);    tbox = gtk_hbox_new(TRUE,0);    gtk_container_add(GTK_CONTAINER(vbox),tbox);    frame = gtk_frame_new(&quot;票价&quot;);    label = gtk_label_new(p-&gt;price);    gtk_container_add(GTK_CONTAINER(frame),label);    gtk_label_set_justify(GTK_LABEL(label),GTK_JUSTIFY_LEFT);    gtk_box_pack_start_defaults(GTK_BOX(tbox),frame);    frame = gtk_frame_new(&quot;评分&quot;);    label = gtk_label_new(p-&gt;score);    gtk_container_add(GTK_CONTAINER(frame),label);    gtk_label_set_justify(GTK_LABEL(label),GTK_JUSTIFY_LEFT);    gtk_box_pack_start_defaults(GTK_BOX(tbox),frame);    button = gtk_button_new_with_label(&quot;购买&quot;);    g_signal_connect(G_OBJECT(button),&quot;clicked&quot;,G_CALLBACK(on_choose_seat),p);    gtk_box_pack_start(GTK_BOX(vbox),button,FALSE,FALSE,5);&#125;GtkWidget* make_window_main_buy ()//创建影片选择页面&#123;    GtkWidget *boxs;    GtkWidget *window;    GtkWidget *swindow;    gchar *title = &quot;影票购买&quot; ;    fp=fopen(&quot;data.txt&quot;,&quot;rt&quot;);    window = gtk_window_new(GTK_WINDOW_TOPLEVEL);    g_signal_connect(G_OBJECT(window),&quot;delete_event&quot;,G_CALLBACK(gtk_main_quit),NULL);    gtk_window_set_default_size(GTK_WINDOW(window),1100,500);    gtk_window_set_title(GTK_WINDOW(window),title);    gtk_window_set_position(GTK_WINDOW(window),GTK_WIN_POS_CENTER);    gtk_container_set_border_width(GTK_CONTAINER(window),20);    swindow = gtk_scrolled_window_new(NULL,NULL);    gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(swindow),GTK_POLICY_AUTOMATIC,GTK_POLICY_AUTOMATIC);    gtk_container_add(GTK_CONTAINER(window),swindow);    boxs = gtk_vbox_new(TRUE,20);    gtk_scrolled_window_add_with_viewport(GTK_SCROLLED_WINDOW(swindow),boxs);    p = (struct theater*)malloc(sizeof(struct theater));    while (fscanf(fp,&quot;%s%s%s%s%s%s%s%s%s\n&quot;,p-&gt;name,p-&gt;type,p-&gt;people,p-&gt;time,p-&gt;place,p-&gt;message,p-&gt;photo,p-&gt;price,p-&gt;score)!=EOF)    &#123;        on_dian_jie(p,boxs);        p = (struct theater*)malloc(sizeof(struct theater));    &#125;    fclose(fp);    return window;&#125;GtkWidget* make_window_choose_seat(struct theater *p)//创建选坐窗口&#123;    GtkWidget *button;    GtkWidget *button1;    GtkWidget *label;    GtkWidget *frame;    GtkWidget *fbox;    GtkWidget *dbox;    GtkWidget *boxs;    GtkWidget *box;    GtkWidget *image;    GtkWidget *window;    gint i,j;    window = gtk_window_new(GTK_WINDOW_TOPLEVEL);    g_signal_connect(G_OBJECT(window),&quot;delete_event&quot;,G_CALLBACK(gtk_main_quit),NULL);    gtk_window_set_position(GTK_WINDOW(window),GTK_WIN_POS_CENTER);    gtk_container_set_border_width(GTK_CONTAINER(window),10);    gtk_window_set_title(GTK_WINDOW(window),&quot;guanli&quot;);    box = gtk_vbox_new(FALSE,30);    gtk_container_add(GTK_CONTAINER(window),box);    button = gtk_image_new_from_file(&quot;1.jpg&quot;);    gtk_widget_set_size_request(GTK_WIDGET(button),100,80);    gtk_box_pack_start(GTK_BOX(box),button,FALSE,FALSE,0);    dbox = gtk_vbox_new(FALSE,10);    gtk_container_add(GTK_CONTAINER(box),dbox);    frame = gtk_frame_new(&quot;&quot;);    gtk_box_pack_start(GTK_BOX(dbox),frame,FALSE,FALSE,0);    strcpy(choose_name,p-&gt;name);    strcat(choose_name,&quot;.txt&quot;);    fp=fopen(choose_name,&quot;r+&quot;);    for (i=0;i&lt;8;i++)    &#123;        boxs = gtk_hbox_new(FALSE,10);        gtk_container_add(GTK_CONTAINER(dbox),boxs);        for (j=0;j&lt;8;j++)        &#123;            fscanf(fp,&quot;%d&quot;,&amp;weizhi[i][j]);            q =(struct findrc*)malloc(sizeof(struct findrc));            q-&gt;r=i;            q-&gt;c=j;            if (weizhi[i][j]==0)            &#123;                button =gtk_toggle_button_new();                gtk_widget_set_size_request(GTK_WIDGET(button),30,30);                gtk_box_pack_start(GTK_BOX(boxs),button,FALSE,FALSE,10);                g_signal_connect(G_OBJECT(button),&quot;clicked&quot;,G_CALLBACK(toggle_clicked_callback),q);            &#125;            else            &#123;                image = gtk_image_new_from_stock(GTK_STOCK_CANCEL,GTK_ICON_SIZE_MENU);                button = gtk_button_new();                gtk_widget_set_size_request(GTK_WIDGET(button),30,30);                gtk_container_add(GTK_CONTAINER(button),image);                gtk_box_pack_start(GTK_BOX(boxs),button,FALSE,FALSE,10);            &#125;        &#125;    &#125;    frame = gtk_frame_new(&quot;&quot;);    gtk_box_pack_start(GTK_BOX(dbox),frame,FALSE,FALSE,0);    fclose(fp);    boxs = gtk_hbox_new(FALSE,20);    button1 = gtk_button_new_with_label(&quot;购买&quot;);    gtk_widget_set_size_request(GTK_WIDGET(button1),50,40);    g_signal_connect(G_OBJECT(button1),&quot;clicked&quot;,G_CALLBACK(on_choose_seat_ok),p);    gtk_box_pack_start(GTK_BOX(boxs),button1,FALSE,FALSE,90);    button1 = gtk_button_new_with_label(&quot;返回&quot;);    gtk_widget_set_size_request(GTK_WIDGET(button1),50,40);    g_signal_connect(G_OBJECT(button1),&quot;clicked&quot;,G_CALLBACK(on_seat_to_buy),NULL);    gtk_box_pack_start(GTK_BOX(boxs),button1,FALSE,FALSE,80);    gtk_container_add(GTK_CONTAINER(box),boxs);    return window;&#125;GtkWidget* make_window_main_login()//创建管理登录界面&#123;    GtkWidget *window;    GtkWidget *box;    GtkWidget *button_a;    GtkWidget *button_b;    GtkWidget *label_user;    GtkWidget *label_pass;    GtkWidget *text_user;    GtkWidget *text_pass;    GtkWidget *table;    window = gtk_window_new(GTK_WINDOW_TOPLEVEL);    g_signal_connect(G_OBJECT(window),&quot;delete_event&quot;,G_CALLBACK(on_login_to_main),NULL);    gtk_container_set_border_width(GTK_CONTAINER(window),10);    gtk_window_set_title(GTK_WINDOW(window),&quot;log in&quot;);    gtk_window_set_position(GTK_WINDOW(window),GTK_WIN_POS_CENTER);    table = gtk_table_new(5,5,FALSE);    gtk_container_add(GTK_CONTAINER(window),table);    label_user = gtk_label_new(&quot;用户名&quot;);    label_pass = gtk_label_new(&quot;密码&quot;);    text_user = gtk_entry_new();    text_pass = gtk_entry_new();    box = gtk_hbox_new(TRUE,10);    button_a = gtk_button_new_with_label(&quot;登录&quot;);    button_b = gtk_button_new_with_label(&quot;返回&quot;);    gtk_box_pack_start(GTK_BOX(box),button_a,FALSE,TRUE,0);    gtk_box_pack_start(GTK_BOX(box),button_b,FALSE,TRUE,0);    gtk_entry_set_visibility(GTK_ENTRY(text_pass),FALSE);    gtk_table_attach_defaults(GTK_TABLE(table),label_user,0,1,0,2);    gtk_table_attach_defaults(GTK_TABLE(table),label_pass,0,1,3,4);    gtk_table_attach_defaults(GTK_TABLE(table),text_user,2,5,0,2);    gtk_table_attach_defaults(GTK_TABLE(table),text_pass,2,5,3,4);    gtk_table_attach_defaults(GTK_TABLE(table),box,1,4,4,5);    g_signal_connect(G_OBJECT(button_a),&quot;clicked&quot;,G_CALLBACK(on_login_to_change),NULL);    g_signal_connect(G_OBJECT(button_b),&quot;clicked&quot;,G_CALLBACK(on_login_to_main),NULL);    return window;&#125;GtkWidget* make_window_main_change()//创建影片管理页面&#123;    GtkWidget *swindow;    GtkWidget *window;    GtkWidget *vbox;    GtkWidget *hbox;    GtkWidget *button;    gint i;    gint temp_row;    gchar *title[9]=&#123;&quot;影片名&quot;,&quot;影片类型&quot;,&quot;主演&quot;,&quot;播放时间&quot;,&quot;播放地点&quot;,&quot;影片简介&quot;,&quot;影片插图&quot;,&quot;价格&quot;,&quot;评分&quot;&#125;;    window = gtk_window_new(GTK_WINDOW_TOPLEVEL);    g_signal_connect(G_OBJECT(window),&quot;delete_event&quot;,G_CALLBACK(made_file),NULL);    gtk_window_set_title(GTK_WINDOW(window),&quot;影片管理&quot;);    gtk_window_set_position(GTK_WINDOW(window),GTK_WIN_POS_CENTER);    gtk_container_set_border_width(GTK_CONTAINER(window),10);    gtk_window_set_default_size(GTK_WINDOW(window),1200,500);    vbox = gtk_vbox_new(FALSE,0);    gtk_container_add(GTK_CONTAINER(window),vbox);    swindow = gtk_scrolled_window_new(NULL,NULL);    gtk_box_pack_start_defaults(GTK_BOX(vbox),swindow);    gtk_container_set_border_width (GTK_CONTAINER (swindow), 10);    gtk_scrolled_window_set_policy (GTK_SCROLLED_WINDOW (swindow),GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC);    list = gtk_clist_new_with_titles(9,title);    gtk_clist_set_shadow_type (GTK_CLIST(list), GTK_SHADOW_OUT);    gtk_signal_connect(GTK_OBJECT(list), &quot;select_row&quot;,GTK_SIGNAL_FUNC(selection_made),NULL);    gtk_scrolled_window_add_with_viewport (GTK_SCROLLED_WINDOW(swindow),list);    for(i=0;i&lt;9;i++)    &#123;         gtk_clist_set_column_justification(GTK_CLIST(list),i,GTK_JUSTIFY_CENTER);    &#125;    gtk_clist_set_column_width(GTK_CLIST(list),0,100);    gtk_clist_set_column_width(GTK_CLIST(list),1,100);    gtk_clist_set_column_width(GTK_CLIST(list),2,100);    gtk_clist_set_column_width(GTK_CLIST(list),3,100);    gtk_clist_set_column_width(GTK_CLIST(list),4,100);    gtk_clist_set_column_width(GTK_CLIST(list),5,300);    gtk_clist_set_column_width(GTK_CLIST(list),6,100);    gtk_clist_set_column_width(GTK_CLIST(list),7,50);    gtk_clist_set_column_width(GTK_CLIST(list),8,50);    hbox = gtk_hbox_new(TRUE,0);    gtk_box_pack_start(GTK_BOX(vbox),hbox,FALSE,FALSE,5);    button = gtk_button_new_with_label(&quot;添加&quot;);    g_signal_connect(G_OBJECT(button),&quot;clicked&quot;,G_CALLBACK(list_add),(gpointer)list);    gtk_box_pack_start(GTK_BOX(hbox),button,FALSE,FALSE,5);    button = gtk_button_new_with_label(&quot;修改&quot;);    g_signal_connect(G_OBJECT(button),&quot;clicked&quot;,G_CALLBACK(list_change),(gpointer)list);    gtk_box_pack_start(GTK_BOX(hbox),button,FALSE,FALSE,5);    button = gtk_button_new_with_label(&quot;删除&quot;);    g_signal_connect(G_OBJECT(button),&quot;clicked&quot;,G_CALLBACK(list_delete),(gpointer)list);    gtk_box_pack_start(GTK_BOX(hbox),button,FALSE,FALSE,5);    button = gtk_button_new_with_label(&quot;清空&quot;);    g_signal_connect(G_OBJECT(button),&quot;clicked&quot;,G_CALLBACK(list_clear),(gpointer)list);    gtk_box_pack_start(GTK_BOX(hbox),button,FALSE,FALSE,5);    list_made(list,&amp;th);    return window;&#125;GtkWidget* make_window_yesorno(GtkWidget *userdate) //创建退出确认框？&#123;    GtkWidget *window;    GtkWidget *button_yes;    GtkWidget *button_no;    GtkWidget *label;    GtkWidget *box_b;    GtkWidget *box_s;    window = gtk_window_new(GTK_WINDOW_POPUP);    gtk_window_set_default_size(GTK_WINDOW(window),150,70);    gtk_window_set_position(GTK_WINDOW(window),GTK_WIN_POS_CENTER);    g_signal_connect(G_OBJECT(window),&quot;delete_event&quot;,G_CALLBACK(on_change_no),NULL);    gtk_container_set_border_width(GTK_CONTAINER(window),10);    box_b = gtk_vbox_new(TRUE,10);    gtk_container_add(GTK_CONTAINER(window),box_b);    label = gtk_label_new(&quot;是否确定？&quot;);    gtk_box_pack_start_defaults(GTK_BOX(box_b),label);    box_s = gtk_hbox_new(TRUE,10);    gtk_box_pack_start_defaults(GTK_BOX(box_b),box_s);    button_yes = gtk_button_new_with_label(&quot;是&quot;);    button_no = gtk_button_new_with_label(&quot;否&quot;);    gtk_box_pack_start_defaults(GTK_BOX(box_s),button_yes);    gtk_box_pack_start_defaults(GTK_BOX(box_s),button_no);    g_signal_connect(G_OBJECT(button_yes),&quot;clicked&quot;,G_CALLBACK(on_change_yes),NULL);    g_signal_connect(G_OBJECT(button_no),&quot;clicked&quot;,G_CALLBACK(on_change_no),NULL);    return window;&#125;GtkWidget* make_window_insert()//创建信息输入窗口&#123;    GtkWidget *window;    GtkWidget *button;    GtkWidget *label;    GtkWidget *box;    GtkWidget *hbox;    GtkWidget *vbox1;    GtkWidget *vbox2;    window = gtk_window_new(GTK_WINDOW_TOPLEVEL);    gtk_window_set_title(GTK_WINDOW(window),&quot;添加影片&quot;);    gtk_window_set_position(GTK_WINDOW(window),GTK_WIN_POS_CENTER);    g_signal_connect(G_OBJECT(window),&quot;delete_event&quot;,G_CALLBACK(gtk_widget_destroy),NULL);    gtk_container_set_border_width(GTK_CONTAINER(window),10);    box = gtk_vbox_new(FALSE,10);    gtk_container_add(GTK_CONTAINER(window),box);    hbox = gtk_hbox_new(FALSE,10);    gtk_box_pack_start_defaults(GTK_BOX(box),hbox);    vbox1 = gtk_vbox_new(TRUE,10);    vbox2 = gtk_vbox_new(TRUE,10);    gtk_box_pack_start_defaults(GTK_BOX(hbox),vbox1);    gtk_box_pack_start_defaults(GTK_BOX(hbox),vbox2);    label = gtk_label_new(&quot;影片名&quot;);    text_name = gtk_entry_new();    gtk_box_pack_start_defaults(GTK_BOX(vbox1),label);    gtk_box_pack_start_defaults(GTK_BOX(vbox2),text_name);    label = gtk_label_new(&quot;影片类型&quot;);    text_type = gtk_entry_new();    gtk_box_pack_start_defaults(GTK_BOX(vbox1),label);    gtk_box_pack_start_defaults(GTK_BOX(vbox2),text_type);    label = gtk_label_new(&quot;主演&quot;);    text_people = gtk_entry_new();    gtk_box_pack_start_defaults(GTK_BOX(vbox1),label);    gtk_box_pack_start_defaults(GTK_BOX(vbox2),text_people);    label = gtk_label_new(&quot;放映时间&quot;);    text_time = gtk_entry_new();    gtk_box_pack_start_defaults(GTK_BOX(vbox1),label);    gtk_box_pack_start_defaults(GTK_BOX(vbox2),text_time);    label = gtk_label_new(&quot;放映地点&quot;);    text_place = gtk_entry_new();    gtk_box_pack_start_defaults(GTK_BOX(vbox1),label);    gtk_box_pack_start_defaults(GTK_BOX(vbox2),text_place);    label = gtk_label_new(&quot;影片简介&quot;);    text_message = gtk_entry_new();    gtk_box_pack_start_defaults(GTK_BOX(vbox1),label);    gtk_box_pack_start_defaults(GTK_BOX(vbox2),text_message);    label = gtk_label_new(&quot;影片封面&quot;);    text_photo = gtk_entry_new();    gtk_box_pack_start_defaults(GTK_BOX(vbox1),label);    gtk_box_pack_start_defaults(GTK_BOX(vbox2),text_photo);    label = gtk_label_new(&quot;票价&quot;);    text_price = gtk_entry_new();    gtk_box_pack_start_defaults(GTK_BOX(vbox1),label);    gtk_box_pack_start_defaults(GTK_BOX(vbox2),text_price);    label = gtk_label_new(&quot;评分&quot;);    text_score = gtk_entry_new();    gtk_box_pack_start_defaults(GTK_BOX(vbox1),label);    gtk_box_pack_start_defaults(GTK_BOX(vbox2),text_score);    hbox = gtk_hbox_new(TRUE,10);    button = gtk_button_new_with_label(&quot;确定&quot;);    gtk_box_pack_start_defaults(GTK_BOX(hbox),button);    g_signal_connect(G_OBJECT(button),&quot;clicked&quot;,G_CALLBACK(to_add_list_item),(gpointer)window);    button = gtk_button_new_with_label(&quot;取消&quot;);    gtk_box_pack_start_defaults(GTK_BOX(hbox),button);    g_signal_connect(G_OBJECT(button),&quot;clicked&quot;,G_CALLBACK(destroy),window);    gtk_box_pack_start_defaults(GTK_BOX(box),hbox);    return  window;&#125;GtkWidget* make_window2_insert()//修改信息输入窗口&#123;    GtkWidget *window;    GtkWidget *button;    GtkWidget *label;    GtkWidget *box;    GtkWidget *hbox;    GtkWidget *vbox1;    GtkWidget *vbox2;    gchar *temp[9];    gint i;    for(i=0;i&lt;9;i++)    &#123;        gtk_clist_get_text(GTK_CLIST(list),temp_row,i,(gchar **)(&amp;temp[i]));    &#125;    window = gtk_window_new(GTK_WINDOW_TOPLEVEL);    gtk_window_set_title(GTK_WINDOW(window),&quot;修改影片&quot;);    gtk_window_set_position(GTK_WINDOW(window),GTK_WIN_POS_CENTER);    g_signal_connect(G_OBJECT(window),&quot;delete_event&quot;,G_CALLBACK(gtk_widget_destroy),NULL);    gtk_container_set_border_width(GTK_CONTAINER(window),10);    box = gtk_vbox_new(FALSE,10);    gtk_container_add(GTK_CONTAINER(window),box);    hbox = gtk_hbox_new(FALSE,10);    gtk_box_pack_start_defaults(GTK_BOX(box),hbox);    vbox1 = gtk_vbox_new(TRUE,10);    vbox2 = gtk_vbox_new(TRUE,10);    gtk_box_pack_start_defaults(GTK_BOX(hbox),vbox1);    gtk_box_pack_start_defaults(GTK_BOX(hbox),vbox2);    label = gtk_label_new(&quot;影片名&quot;);    text_name = gtk_entry_new();    gtk_entry_set_text(GTK_ENTRY(text_name),temp[0]);    gtk_box_pack_start_defaults(GTK_BOX(vbox1),label);    gtk_box_pack_start_defaults(GTK_BOX(vbox2),text_name);    label = gtk_label_new(&quot;影片类型&quot;);    text_type = gtk_entry_new();    gtk_entry_set_text(GTK_ENTRY(text_type),temp[1]);    gtk_box_pack_start_defaults(GTK_BOX(vbox1),label);    gtk_box_pack_start_defaults(GTK_BOX(vbox2),text_type);    label = gtk_label_new(&quot;主演&quot;);    text_people = gtk_entry_new();    gtk_entry_set_text(GTK_ENTRY(text_people),temp[2]);    gtk_box_pack_start_defaults(GTK_BOX(vbox1),label);    gtk_box_pack_start_defaults(GTK_BOX(vbox2),text_people);    label = gtk_label_new(&quot;放映时间&quot;);    text_time = gtk_entry_new();    gtk_entry_set_text(GTK_ENTRY(text_time),temp[3]);    gtk_box_pack_start_defaults(GTK_BOX(vbox1),label);    gtk_box_pack_start_defaults(GTK_BOX(vbox2),text_time);    label = gtk_label_new(&quot;放映地点&quot;);    text_place = gtk_entry_new();    gtk_entry_set_text(GTK_ENTRY(text_place),temp[4]);    gtk_box_pack_start_defaults(GTK_BOX(vbox1),label);    gtk_box_pack_start_defaults(GTK_BOX(vbox2),text_place);    label = gtk_label_new(&quot;影片简介&quot;);    text_message = gtk_entry_new();    gtk_entry_set_text(GTK_ENTRY(text_message),temp[5]);    gtk_box_pack_start_defaults(GTK_BOX(vbox1),label);    gtk_box_pack_start_defaults(GTK_BOX(vbox2),text_message);    label = gtk_label_new(&quot;影片封面&quot;);    text_photo = gtk_entry_new();    gtk_entry_set_text(GTK_ENTRY(text_photo),temp[6]);    gtk_box_pack_start_defaults(GTK_BOX(vbox1),label);    gtk_box_pack_start_defaults(GTK_BOX(vbox2),text_photo);    label = gtk_label_new(&quot;票价&quot;);    text_price = gtk_entry_new();    gtk_entry_set_text(GTK_ENTRY(text_price),temp[7]);    gtk_box_pack_start_defaults(GTK_BOX(vbox1),label);    gtk_box_pack_start_defaults(GTK_BOX(vbox2),text_price);    label = gtk_label_new(&quot;评分&quot;);    text_score = gtk_entry_new();    gtk_entry_set_text(GTK_ENTRY(text_score),temp[8]);    gtk_box_pack_start_defaults(GTK_BOX(vbox1),label);    gtk_box_pack_start_defaults(GTK_BOX(vbox2),text_score);    hbox = gtk_hbox_new(TRUE,10);    button = gtk_button_new_with_label(&quot;确定&quot;);    gtk_box_pack_start_defaults(GTK_BOX(hbox),button);    g_signal_connect(G_OBJECT(button),&quot;clicked&quot;,G_CALLBACK(to_change_list_item),(gpointer)window);    button = gtk_button_new_with_label(&quot;取消&quot;);    gtk_box_pack_start_defaults(GTK_BOX(hbox),button);    g_signal_connect(G_OBJECT(button),&quot;clicked&quot;,G_CALLBACK(destroy),window);    gtk_box_pack_start_defaults(GTK_BOX(box),hbox);    return  window;&#125;GtkWidget* make_window_ok_seat(struct theater *p)//创建确定付款窗口&#123;    GtkWidget *box;    GtkWidget *frame;    GtkWidget *label;    GtkWidget *hbox;    GtkWidget *boxx;    GtkWidget *boxs;    GtkWidget *button_buy;    GtkWidget *button_log;    GtkWidget *window1;    char f[20];    gint i,j;    window1 = gtk_window_new(GTK_WINDOW_TOPLEVEL);    g_signal_connect(G_OBJECT(window1),&quot;delete_event&quot;,G_CALLBACK(gtk_main_quit),NULL);    gtk_window_set_position(GTK_WINDOW(window1),GTK_WIN_POS_CENTER);    gtk_container_set_border_width(GTK_CONTAINER(window1),10);    gtk_window_set_title(GTK_WINDOW(window1),&quot;确认购买&quot;);    box = gtk_vbox_new(FALSE,10);    gtk_container_add(GTK_CONTAINER(window1),box);    frame = gtk_frame_new(&quot;电影名&quot;);    label = gtk_label_new(p-&gt;name);    gtk_container_add(GTK_CONTAINER(frame),label);    gtk_label_set_justify(GTK_LABEL(label),GTK_JUSTIFY_LEFT);    gtk_box_pack_start(GTK_BOX(box),frame,FALSE,FALSE,0);    frame = gtk_frame_new(&quot;上映时间&quot;);    label = gtk_label_new(p-&gt;time);    gtk_container_add(GTK_CONTAINER(frame),label);    gtk_label_set_justify(GTK_LABEL(label),GTK_JUSTIFY_LEFT);    gtk_box_pack_start(GTK_BOX(box),frame,FALSE,FALSE,0);    frame = gtk_frame_new(&quot;上映地点&quot;);    label = gtk_label_new(p-&gt;place);    gtk_container_add(GTK_CONTAINER(frame),label);    gtk_label_set_justify(GTK_LABEL(label),GTK_JUSTIFY_LEFT);    gtk_box_pack_start(GTK_BOX(box),frame,FALSE,FALSE,0);    frame = gtk_frame_new(&quot;购票价格&quot;);    label = gtk_label_new(p-&gt;price);    gtk_container_add(GTK_CONTAINER(frame),label);    gtk_label_set_justify(GTK_LABEL(label),GTK_JUSTIFY_LEFT);    gtk_box_pack_start(GTK_BOX(box),frame,FALSE,FALSE,0);    boxx = gtk_vbox_new(FALSE,0);    for (i=0;i&lt;8;i++)    &#123;        for(j=0;j&lt;8;j++)        &#123;            if(weizhi[i][j]==2)            &#123;                sprintf(f,&quot;  第%d排 第%d列  &quot;,i+1,j+1);                frame = gtk_frame_new(&quot;&quot;);                label = gtk_label_new(f);                gtk_container_add(GTK_CONTAINER(frame),label);                gtk_label_set_justify(GTK_LABEL(label),GTK_JUSTIFY_LEFT);                gtk_box_pack_start(GTK_BOX(boxx),frame,FALSE,FALSE,0);            &#125;        &#125;    &#125;    gtk_container_add(GTK_CONTAINER(box),boxx);    hbox = gtk_hbox_new(FALSE,20);    gtk_container_add(GTK_CONTAINER(box),hbox);    button_buy = gtk_button_new_with_label(&quot;确认&quot;);    button_log = gtk_button_new_with_label(&quot;返回&quot;);    gtk_box_pack_start(GTK_BOX(hbox),button_buy,FALSE,FALSE,20);    gtk_box_pack_start(GTK_BOX(hbox),button_log,FALSE,FALSE,20);    g_signal_connect(G_OBJECT(button_buy),&quot;clicked&quot;,G_CALLBACK(on_put_money),p);    g_signal_connect(G_OBJECT(button_log),&quot;clicked&quot;,G_CALLBACK(on_ok_to_seat),NULL);    return window1;&#125;GtkWidget* make_window_buy_passwd(struct theater *p)//支付登录界面&#123;    GtkWidget *window;    GtkWidget *box;    GtkWidget *button_a;    GtkWidget *button_b;    GtkWidget *label_user;    GtkWidget *label_pass;    GtkWidget *text_user;    GtkWidget *text_pass;    GtkWidget *table;    window = gtk_window_new(GTK_WINDOW_TOPLEVEL);    g_signal_connect(G_OBJECT(window),&quot;delete_event&quot;,G_CALLBACK(on_login_to_main),NULL);    gtk_container_set_border_width(GTK_CONTAINER(window),10);    gtk_window_set_title(GTK_WINDOW(window),&quot;log in&quot;);    gtk_window_set_position(GTK_WINDOW(window),GTK_WIN_POS_CENTER);    table = gtk_table_new(5,5,FALSE);    gtk_container_add(GTK_CONTAINER(window),table);    label_user = gtk_label_new(&quot;账户&quot;);    label_pass = gtk_label_new(&quot;密码&quot;);    text_user = gtk_entry_new();    text_pass = gtk_entry_new();    box = gtk_hbox_new(TRUE,10);    button_a = gtk_button_new_with_label(&quot;登录&quot;);    button_b = gtk_button_new_with_label(&quot;返回&quot;);    gtk_box_pack_start(GTK_BOX(box),button_a,FALSE,TRUE,0);    gtk_box_pack_start(GTK_BOX(box),button_b,FALSE,TRUE,0);    gtk_entry_set_visibility(GTK_ENTRY(text_pass),FALSE);    gtk_table_attach_defaults(GTK_TABLE(table),label_user,0,1,0,2);    gtk_table_attach_defaults(GTK_TABLE(table),label_pass,0,1,3,4);    gtk_table_attach_defaults(GTK_TABLE(table),text_user,2,5,0,2);    gtk_table_attach_defaults(GTK_TABLE(table),text_pass,2,5,3,4);    gtk_table_attach_defaults(GTK_TABLE(table),box,1,4,4,5);    g_signal_connect(G_OBJECT(button_a),&quot;clicked&quot;,G_CALLBACK(on_succeed_login),p);    g_signal_connect(G_OBJECT(button_b),&quot;clicked&quot;,G_CALLBACK(destroy),(gpointer)window);    return window;&#125;GtkWidget* make_tobuy_yesorno(struct theater *p) //创建支付后确认框？&#123;    GtkWidget *window;    GtkWidget *button_yes;    GtkWidget *button_no;    GtkWidget *label;    GtkWidget *box_b;    GtkWidget *box_s;    window = gtk_window_new(GTK_WINDOW_POPUP);    gtk_window_set_default_size(GTK_WINDOW(window),150,70);    gtk_window_set_position(GTK_WINDOW(window),GTK_WIN_POS_CENTER);    g_signal_connect(G_OBJECT(window),&quot;delete_event&quot;,G_CALLBACK(on_change_no),NULL);    gtk_container_set_border_width(GTK_CONTAINER(window),10);    box_b = gtk_vbox_new(TRUE,10);    gtk_container_add(GTK_CONTAINER(window),box_b);    label = gtk_label_new(&quot;确定支付？&quot;);    gtk_box_pack_start_defaults(GTK_BOX(box_b),label);    box_s = gtk_hbox_new(TRUE,10);    gtk_box_pack_start_defaults(GTK_BOX(box_b),box_s);    button_yes = gtk_button_new_with_label(&quot;是&quot;);    button_no = gtk_button_new_with_label(&quot;否&quot;);    gtk_box_pack_start_defaults(GTK_BOX(box_s),button_yes);    gtk_box_pack_start_defaults(GTK_BOX(box_s),button_no);    g_signal_connect(G_OBJECT(button_yes),&quot;clicked&quot;,G_CALLBACK(on_succeed_buy),p);    g_signal_connect(G_OBJECT(button_no),&quot;clicked&quot;,G_CALLBACK(destroy),(gpointer)window);    return window;&#125;</code></pre><p>** interface.h **</p><pre><code class="hljs">GtkWidget* make_window_main();GtkWidget* make_window_main_login();GtkWidget* make_window_yesorno();GtkWidget* make_window_main_change();GtkWidget* make_window_main_buy();GtkWidget* make_window_insert();GtkWidget* make_window2_insert();GtkWidget* make_window_ok_seat(struct theater *p);GtkWidget* make_window_choose_seat(struct theater *p);GtkWidget* make_window_buy_passwd(struct theater *p);GtkWidget* make_tobuy_yesorno(struct theater *p);</code></pre><p>** callback.c **</p><pre><code class="hljs">#include&lt;gtk/gtk.h&gt;#include&quot;callback.h&quot;#include&quot;interface.h&quot;extern struct findrc *q;void on_main_to_buy(GtkWidget *widget ,gpointer userdate)//从主界面转至购票页面&#123;    gtk_widget_hide(window_main);    gtk_widget_show_all(window_main_buy);&#125;void on_main_to_login(GtkWidget *widget , gpointer userdate)//从主界面转至登录界面&#123;    gtk_widget_hide(window_main);    gtk_widget_show_all(window_main_login);&#125;void on_login_to_main(GtkWidget *widget , gpointer userdate)//从登录界面转至主界面&#123;    gtk_widget_hide(window_main_login);    gtk_widget_show_all(window_main);&#125;void on_login_to_change(GtkWidget *widget , gpointer userdate)//从登录界面转至管理页面&#123;    gtk_widget_hide(window_main_login);    gtk_widget_show_all(window_main_change);&#125;void on_seat_to_buy(GtkWidget *button,gpointer userdate)//从选座界面转至选电影界面&#123;    gtk_widget_hide(window_choose_seat);    gtk_widget_show_all(window_main_buy);&#125;void on_ok_to_seat(GtkWidget *button,gpointer userdate)//从付款界面返回选做界面&#123;    gtk_widget_destroy(window_choose_to_buy);    gtk_widget_show_all(window_choose_seat);&#125;void on_change_yes(GtkWidget *widget ,gpointer userdate)//确认是&#123;    gtk_main_quit();&#125;void on_change_no(GtkWidget *widget ,gpointer userdate)//确认否&#123;    gtk_widget_hide(window_change_yesorno);&#125;void want_to_quit(GtkWidget *widget ,gpointer userdate)//打开确认界面&#123;    gtk_widget_show_all(window_change_yesorno);&#125;void list_made(GtkWidget *list,struct theater *p)&#123;    gchar *s[9];    fp = fopen(&quot;data.txt&quot;,&quot;rt&quot;);    while(fscanf(fp,&quot;%s%s%s%s%s%s%s%s%s\n&quot;,p-&gt;name,p-&gt;type,p-&gt;people,p-&gt;time,p-&gt;place,p-&gt;message,p-&gt;photo,p-&gt;price,p-&gt;score)!=EOF)    &#123;        theater_num++;        s[0]=p-&gt;name;        s[1]=p-&gt;type;        s[2]=p-&gt;people;        s[3]=p-&gt;time;        s[4]=p-&gt;place;        s[5]=p-&gt;message;        s[6]=p-&gt;photo;        s[7]=p-&gt;price;        s[8]=p-&gt;score;        gtk_clist_append((GtkCList *)list,s);    &#125;    fclose(fp);&#125;void list_add(GtkButton *button , gpointer userdate)//添加影片&#123;    GtkWidget *window;    window = make_window_insert();    gtk_widget_show_all(window);&#125;void to_add_list_item(GtkWidget *button ,gpointer userdate)//将新增数据显示并存入文件&#123;    theater_num++;    const gchar *list_item[9];//列表项信息    list_item[0]=gtk_entry_get_text(GTK_ENTRY(text_name));    list_item[1]=gtk_entry_get_text(GTK_ENTRY(text_type));    list_item[2]=gtk_entry_get_text(GTK_ENTRY(text_people));    list_item[3]=gtk_entry_get_text(GTK_ENTRY(text_time));    list_item[4]=gtk_entry_get_text(GTK_ENTRY(text_place));    list_item[5]=gtk_entry_get_text(GTK_ENTRY(text_message));    list_item[6]=gtk_entry_get_text(GTK_ENTRY(text_photo));    list_item[7]=gtk_entry_get_text(GTK_ENTRY(text_price));    list_item[8]=gtk_entry_get_text(GTK_ENTRY(text_score));    gtk_clist_append((GtkCList *)list,(gchar **)list_item);    fp = fopen(&quot;data.txt&quot;,&quot;at+&quot;);    fprintf(fp,&quot;%s %s %s %s %s %s %s %s %s\n&quot;,list_item[0],list_item[1],list_item[2],list_item[3],list_item[4],list_item[5],list_item[6],list_item[7],list_item[8]);    fclose(fp);    gtk_widget_destroy((GtkWidget *)userdate);&#125;void to_change_list_item(GtkWidget *button ,gpointer userdate)//将修改后的数据显示并存入文件&#123;    gint i;    const gchar *list_item[9];//列表项信息    list_item[0]=gtk_entry_get_text(GTK_ENTRY(text_name));    list_item[1]=gtk_entry_get_text(GTK_ENTRY(text_type));    list_item[2]=gtk_entry_get_text(GTK_ENTRY(text_people));    list_item[3]=gtk_entry_get_text(GTK_ENTRY(text_time));    list_item[4]=gtk_entry_get_text(GTK_ENTRY(text_place));    list_item[5]=gtk_entry_get_text(GTK_ENTRY(text_message));    list_item[6]=gtk_entry_get_text(GTK_ENTRY(text_photo));    list_item[7]=gtk_entry_get_text(GTK_ENTRY(text_price));    list_item[8]=gtk_entry_get_text(GTK_ENTRY(text_score));    for(i=0;i&lt;9;i++)    &#123;        gtk_clist_set_text (GTK_CLIST(list),temp_row,i ,list_item[i]);    &#125;    gtk_widget_destroy((GtkWidget *)userdate);&#125;void list_change(GtkButton *button , gpointer userdate)//修改影片&#123;    GtkWidget *window;    window = make_window2_insert();    gtk_widget_show_all(window);&#125;void list_delete(GtkButton *button, gpointer userdate)//删除影片&#123;    theater_num--;    gtk_clist_remove( (GtkCList*)userdate,temp_row);&#125;void list_clear(GtkButton *button, gpointer userdate)//清空影片&#123;    theater_num = 0;    gtk_clist_clear((GtkCList*)userdate);&#125;void selection_made( GtkWidget *list,gint row,gint column,GdkEventButton *event,gpointer userdate)//定位管理界面选中行&#123;    gchar *text;    gtk_clist_get_text(GTK_CLIST(list), row, column, &amp;text);    temp_row=row;&#125;void destroy(GtkWidget *button,GtkWidget *window)//销毁窗体&#123;    gtk_widget_destroy(window);&#125;void made_file()//更新文件&#123;    gint i,j;    gchar *temp[9];    fp=fopen(&quot;data.txt&quot;,&quot;wt+&quot;);    for(i=0;i&lt;theater_num;i++)    &#123;        for(j=0;j&lt;9;j++)        &#123;            gtk_clist_get_text(GTK_CLIST(list),i,j,(gchar **)(&amp;temp[j]));        &#125;        fprintf(fp,&quot;%s %s %s %s %s %s %s %s %s\n&quot;,temp[0],temp[1],temp[2],temp[3],temp[4],temp[5],temp[6],temp[7],temp[8]);        //printf(&quot;%s %s %s %s %s %s %s %s %s\n&quot;,temp[0],temp[1],temp[2],temp[3],temp[4],temp[5],temp[6],temp[7],temp[8]);    &#125;    fclose(fp);    gtk_main_quit();&#125;void on_choose_seat_ok (GtkWidget *button,struct theater* p)//显示购票的选择信息&#123;    window_choose_to_buy = make_window_ok_seat(p);    gtk_widget_show_all(window_choose_to_buy);&#125;void on_choose_seat(GtkWidget *button,struct theater* p)//选择影片完毕&#123;    window_choose_seat = make_window_choose_seat(p);    gtk_widget_show_all(window_choose_seat);&#125;void toggle_clicked_callback (GtkWidget *widget, struct findrc *q)//点击座位按钮&#123;    if (gtk_toggle_button_get_active (GTK_TOGGLE_BUTTON (widget)))    &#123;        weizhi[q-&gt;r][q-&gt;c]=2;    &#125;    else    &#123;        weizhi[q-&gt;r][q-&gt;c]=0;    &#125;&#125;void update_seat_file(struct theater *p)//更新座位数据&#123;    gint i,j;    strcpy(choose_name,p-&gt;name);    strcat(choose_name,&quot;.txt&quot;);    fp=fopen(choose_name,&quot;wt+&quot;);    for (i=0;i&lt;8;i++)    &#123;        for (j=0;j&lt;8;j++)        &#123;            if(weizhi[i][j]==0)            &#123;                fprintf(fp,&quot;0 &quot;);            &#125;            else            &#123;                fprintf(fp,&quot;1 &quot;);            &#125;        &#125;    &#125;    fclose(fp);&#125;void on_put_money(GtkWidget *button,struct theater *p)//付款，即将输入账户密码&#123;    GtkWidget *window;    window = make_window_buy_passwd(p);    gtk_widget_show_all(window);&#125;void on_succeed_login(GtkWidget *button,struct theater *p)//支付登录成功&#123;    GtkWidget *window;    window = make_tobuy_yesorno(p);    gtk_widget_show_all(window);&#125;void on_succeed_buy(GtkWidget *button,struct theater *p)//成功支付&#123;    update_seat_file(p);    gtk_main_quit();&#125;</code></pre><p>** callback.h **</p><pre><code class="hljs">#include&lt;stdlib.h&gt;#include&lt;string.h&gt;gint theater_num;gint temp_row;gchar *temp[9];gchar choose_name[50];gint weizhi[8][8];GtkWidget *window_main;GtkWidget *window_main_login;GtkWidget *window_main_change;GtkWidget *window_main_buy;GtkWidget *window_change_yesorno;GtkWidget *window_choose_seat;GtkWidget *window_choose_to_buy;GtkWidget *list;GtkWidget *text_name;GtkWidget *text_type;GtkWidget *text_people;GtkWidget *text_time;GtkWidget *text_place;GtkWidget *text_message;GtkWidget *text_photo;GtkWidget *text_price;GtkWidget *text_score;struct findrc&#123;    int r;    int c;&#125;;struct findrc *q;struct theater&#123;    gchar name[500];    gchar type[500];    gchar people[500];    gchar time[30];    gchar place[30];    gchar message[500];    gchar photo[20];    gchar price[10];    gchar score[10];&#125;th;struct theater* p;FILE *fp;void on_main_to_login(GtkWidget *widget , gpointer userdate);void on_login_to_main(GtkWidget *widget , gpointer userdate);void want_to_quit(GtkWidget *widget ,gpointer userdate);void on_change_yes(GtkWidget *widget ,gpointer userdate);void on_change_no(GtkWidget *widget ,gpointer userdate);void on_login_to_change(GtkWidget *widget , gpointer userdate);void list_delete (GtkButton *button,gpointer userdate);void list_clear(GtkButton *button,gpointer userdate);void list_add(GtkButton *button , gpointer userdate);void list_change(GtkButton *button , gpointer userdate);void on_main_to_buy(GtkWidget *widget ,gpointer userdate);void selection_made( GtkWidget *list,gint row,gint column,GdkEventButton *event,gpointer userdate);void list_made(GtkWidget *list,struct theater *p);void destroy(GtkWidget *button,GtkWidget *window);void to_add_list_item(GtkWidget *button ,gpointer userdate);void to_change_list_item(GtkWidget *button ,gpointer userdate);void made_file();void on_seat_to_buy(GtkWidget *button,gpointer userdate);void on_choose_seat(GtkWidget *button,struct theater* p);void on_choose_seat_ok (GtkWidget *button,struct theater* p);void toggle_clicked_callback (GtkWidget *widget, struct findrc *p);void on_put_money(GtkWidget *button,struct theater *p);void update_seat_file(struct theater *p);void on_ok_to_seat(GtkWidget *button,gpointer userdate);void on_succeed_login(GtkWidget *button,struct theater *p);void on_succeed_buy(GtkWidget *button,struct theater *p);</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Gtk</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 2 -- Add Two Numbers</title>
    <link href="/posts/37129.html"/>
    <url>/posts/37129.html</url>
    
    <content type="html"><![CDATA[<p>** 题目 **</p><blockquote><p>You are given two linked lists representing two non-negative numbers. The<br>digits are stored in reverse order and each of their nodes contain a single<br>digit. Add the two numbers and return it as a linked list.</p></blockquote><blockquote></blockquote><blockquote><p>Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>Output: 7 -&gt; 0 -&gt; 8</p></blockquote><p>** 题意 **</p><blockquote><p>两链表内各逆序保存一整数，将两整数相加之和逆序存于链表，返回该链表头指针</p></blockquote><p>** 代码 **</p><pre><code class="hljs">struct ListNode* addTwoNumbers(struct ListNode* l1, struct ListNode* l2) &#123;   struct ListNode *p,*q,*head;    int num=0,c=0,i;    p=l1;    q=l2;    while(1)    &#123;        num++;//保存较短链表的长度        p = p-&gt;next;        q = q-&gt;next;        if(q==NULL)//q指向长链表 p指向短链表        &#123;            p=l2;            q=l1;            break;        &#125;        if(p==NULL)        &#123;            p=l1;            q=l2;            break;        &#125;    &#125;    head=q;    while(num--)//按位相加并进位    &#123;        q-&gt;val += c + p-&gt;val;        c = q-&gt;val /10;        q-&gt;val %= 10;        p=p-&gt;next;        q=q-&gt;next;    &#125;    while(c)//若还有位未进    &#123;        if(q==NULL)//q为NULL说明是最后一位 直接添加节点 赋值为1并break        &#123;            p=(struct ListNode*)malloc(sizeof(struct ListNode));            p-&gt;val=1;            p-&gt;next=NULL;            q=head;            while(q-&gt;next!=NULL)            &#123;                q=q-&gt;next;            &#125;            q-&gt;next=p;            break;        &#125;        else        &#123;            q-&gt;val += c;            c = q-&gt;val /10;            q-&gt;val %= 10;            if(q-&gt;next == NULL &amp;&amp; c)//为链表添加节点            &#123;                p=(struct ListNode*)malloc(sizeof(struct ListNode));                p-&gt;val=0;                p-&gt;next=NULL;                q-&gt;next=p;                q=p;            &#125;            else            &#123;                q=q-&gt;next;            &#125;        &#125;    &#125;    return head;&#125;</code></pre><p>** 收获 **</p><blockquote><p>添加节点时容易犯的逻辑错误<br>例：q为链表指针 此时 q-&gt;next = NULL;<br>错 ： q=q-&gt;next; q=()malloc();<br>对 ：p=()malloc(); q-&gt;next = p;</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 1 -- Two Sum</title>
    <link href="/posts/55473.html"/>
    <url>/posts/55473.html</url>
    
    <content type="html"><![CDATA[<p>** 前言 **</p><blockquote><p>这道题做的真是一波三折…</p></blockquote><p>** 题目 **</p><blockquote><p>Given an array of integers, find two numbers such that they add up to a<br>specific target number.</p></blockquote><blockquote></blockquote><blockquote><p>The function twoSum should return indices of the two numbers such that they<br>add up to the target, where index1 must be less than index2. Please note that<br>your returned answers (both index1 and index2) are not zero-based.</p></blockquote><blockquote></blockquote><blockquote><p>You may assume that each input would have exactly one solution.</p></blockquote><blockquote></blockquote><blockquote><p>Input: numbers={2, 7, 11, 15}, target=9<br>Output: index1=1, index2=2</p></blockquote><p>** 题意 **</p><blockquote><p>给定一序列和一数值target，返回序列中和为target的两数的下标，用数组保存，返回数组指针</p></blockquote><p>** 思路 **</p><blockquote><p>刚开始想取巧，想用f[nums[i]]=i 保存数值与下表 来搞定，显然是低估了 出题人员的智商，测试数据又是负数，又是含两个0的，搞得wrong不断<br>之后用暴力尝试了下，不出所料，超时<br>细细思考发现关键就在于如何快速对序列项进行查找，自然就想到二叉搜索树</p></blockquote><p>** 代码 **</p><pre><code class="hljs">int* twoSum(int* nums, int numsSize, int target) &#123;    int i,j,flag;    int *a=(int*)malloc(sizeof(int)*3);    struct Node    &#123;        int val;        int num;        struct Node *l,*r;    &#125;*p,*q,*root;    root=(struct Node*)malloc(sizeof(struct Node));    root-&gt;val=nums[0];    root-&gt;num=0;    root-&gt;l=NULL;    root-&gt;r=NULL;    for(i=1;i&lt;numsSize;i++)    &#123;        p=root;        flag=target-nums[i];        while(p!=NULL)//在树中查找是否存在值等于flag        &#123;            if(flag==p-&gt;val)//存在则直接对a赋值并返回            &#123;                a[0]=p-&gt;num+1;                a[1]=i+1;                return a;            &#125;            if(flag&lt;p-&gt;val)            &#123;                p=p-&gt;l;            &#125;            else if(flag&gt;p-&gt;val)//此处一定要加else 因为 p=p-&gt;l后 若p=NULL 接下来 flag&lt;p-&gt;val 会引起段错误...            &#123;                p=p-&gt;r;            &#125;        &#125;        p=(struct Node*)malloc(sizeof(struct Node));        p-&gt;val=nums[i];        p-&gt;num=i;        p-&gt;r=p-&gt;l=NULL;        q=root;        while(1)//nums[i]加入搜索树        &#123;            if(nums[i]&gt;=q-&gt;val)            &#123;                if(q-&gt;r==NULL)                &#123;                    q-&gt;r=p;                    break;                &#125;                else                &#123;                    q=q-&gt;r;                &#125;            &#125;            else if(nums[i]&lt;q-&gt;val)            &#123;                if(q-&gt;l==NULL)                &#123;                    q-&gt;l=p;                    break;                &#125;                else                &#123;                    q=q-&gt;l;                &#125;            &#125;        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 203 -- Remove Linked List Elements</title>
    <link href="/posts/4246.html"/>
    <url>/posts/4246.html</url>
    
    <content type="html"><![CDATA[<p>** 前言 **</p><blockquote><p>leetcode的第一道题，值得纪念一下</p></blockquote><p>** 题目 **</p><blockquote><p>Remove all elements from a linked list of integers that have value val.</p></blockquote><blockquote></blockquote><blockquote><p>Example<br>Given: 1 –&gt; 2 –&gt; 6 –&gt; 3 –&gt; 4 –&gt; 5 –&gt; 6, val = 6<br>Return: 1 –&gt; 2 –&gt; 3 –&gt; 4 –&gt; 5</p></blockquote><blockquote></blockquote><blockquote><p>Credits:<br>Special thanks to @mithmatt for adding this problem and creating all test<br>cases.</p></blockquote><p>** 题意 **</p><blockquote><p>将链表中数值为val的节点全部删除</p></blockquote><p>思路</p><blockquote><p>链表操作基本功，没什么好说的</p></blockquote><p>** 代码 **</p><pre><code class="hljs">struct ListNode* removeElements (struct ListNode *head,int val)&#123;    struct ListNode *p=(struct ListNode*)malloc(sizeof(struct ListNode));    p-&gt;next=head;    head = p;    while(p-&gt;next != NULL)    &#123;        if(p-&gt;next-&gt;val==val)        &#123;            p-&gt;next = p-&gt;next-&gt;next;        &#125;        else        &#123;            p = p-&gt;next;        &#125;    &#125;    return head-&gt;next;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>大学时期CSDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
