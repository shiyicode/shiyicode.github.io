<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yi Shi&#39;s Blog</title>
  <icon>https://shiyi.threebody.xyz/favicon/favicon-32x32.png</icon>
  <subtitle>字斟句酌处，亦是与心推敲时</subtitle>
  <link href="https://shiyi.threebody.xyz/atom.xml" rel="self"/>
  
  <link href="https://shiyi.threebody.xyz/"/>
  <updated>2022-12-08T15:35:14.153Z</updated>
  <id>https://shiyi.threebody.xyz/</id>
  
  <author>
    <name>Yi Shi</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>初识云函数</title>
    <link href="https://shiyi.threebody.xyz/posts/36144.html"/>
    <id>https://shiyi.threebody.xyz/posts/36144.html</id>
    <published>2019-09-08T03:38:00.000Z</published>
    <updated>2022-12-08T15:35:14.153Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是云函数"><a href="#什么是云函数" class="headerlink" title="什么是云函数"></a>什么是云函数</h2><p>云函数提供了一种<strong>直接在云上运行，无状态的、短暂的、由事件触发的代码</strong>的能力。</p><h3 id="云函数与轻服务的关系"><a href="#云函数与轻服务的关系" class="headerlink" title="云函数与轻服务的关系"></a>云函数与轻服务的关系</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/559a24346c6a176d6955e79eb96fa629.png"></p><p>ServerLess，即无服务器架构，也叫轻服务，它包含两个部分，如下：</p><ol><li><p>函数即服务（FaaS: Function as a Service）</p><p>函数即服务提供的是计算能力。原有的计算能力，无论是容器也好，虚拟机也好都承载在一定的操作系统之上，函数即服务把计算能力进行了进一步抽象。</p></li><li><p>后端及服务（BaaS: Backend as a Service）</p><p>后端即服务，比如对象存储，数据库应用，缓存服务，我们也可以称之为Serverless，因为这些服务也能够在云上提供开通即服务，开通即使用的能力。在使用这些产品时同样不需要关注它的服务器是什么样的，它的服务器部署在哪里，而是服务开通就可以使用了，后面的运维工作都交给了云，所以不用感知它的最底层服务器。</p></li></ol><p>云函数，就是FaaS模式的具体实现。同样，对象存储、数据库应用、缓存服务等，是BaaS模式的具体实现。<strong>对于轻服务，BaaS和FaaS缺一不可。</strong></p><h3 id="云函数对比传统服务"><a href="#云函数对比传统服务" class="headerlink" title="云函数对比传统服务"></a>云函数对比传统服务</h3><h4 id="服务粒度"><a href="#服务粒度" class="headerlink" title="服务粒度"></a>服务粒度</h4><p><img src="https://img-blog.csdnimg.cn/img_convert/b4f9d6a7fc2f93155193a933ba0c8d53.png"></p><ul><li>Monolith：单体应用</li><li>MicroService：微服务</li><li>Function：云函数</li></ul><p>一个单体应用可以按业务模块拆分成多个微服务，一个微服务也可以按使用场景拆分成多个云函数。比如一个广告微服务，至少可以拆分出实时竞价、展示计数、报表查询等云函数。也就是说，云函数和微服务中的API是同一粒度的。但不同于API，每个云函数都是独立部署，按需执行。</p><h4 id="服务架构"><a href="#服务架构" class="headerlink" title="服务架构"></a>服务架构</h4><p><img src="https://img-blog.csdnimg.cn/img_convert/68029b5d68321884b5e37692dd2f729a.png"></p><h3 id="云函数的特点"><a href="#云函数的特点" class="headerlink" title="云函数的特点"></a>云函数的特点</h3><ul><li><strong>零运维</strong>：不再需要管理底层资源的服务器</li><li><strong>秒级部署</strong>：运行无状态，轻易实现快速迭代</li><li><strong>自动触发</strong>：完全由事件触发，空闲时没有资源在运行</li><li><strong>聚焦代码逻辑</strong>：开发者只关心最核心的代码片段，跳过复杂的、无聊的其他工作</li><li><strong>无穷弹性计算能力</strong>：根据请求自动平行调整服务资源，拥有近乎无限的扩容能力</li></ul><h2 id="如何使用云函数"><a href="#如何使用云函数" class="headerlink" title="如何使用云函数"></a>如何使用云函数</h2><h3 id="微信云函数功能的构成"><a href="#微信云函数功能的构成" class="headerlink" title="微信云函数功能的构成"></a>微信云函数功能的构成</h3><ol><li>逻辑代码（目前只支持js）</li><li>触发器：包含定时触发、事件触发（目前仅支持定时触发）</li><li>设置项<ul><li>运行环境（目前只有NodeJs 8.9）</li><li>资源配置（根据指定的内存分配计算资源，CPU按比例自动分配）</li><li>超时时间（函数超过该时间仍未结束时，将会被强制中断，不能大于20s）</li><li>环境变量（可以使用键/值对的形式定义可从函数代码访问的环境变量。增强云函数的可定制性）</li></ul></li><li>相关支持<ul><li>测试（即时在线测试，构造Json参数，获取测试结果）</li><li>日志（包含请求ID，返回结果，运行时间，占用内存）</li><li>监控（可以查看云函数的调用次数、运行时间、错误次数）</li></ul></li></ol><h3 id="常见使用架构"><a href="#常见使用架构" class="headerlink" title="常见使用架构"></a>常见使用架构</h3><ul><li>一个云函数处理一个任务，高度解耦</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/b627f755fb66aea11d19ab60731a8bcc.png"></p><ul><li>尝试将请求归类，一个云函数处理某一类的请求，比如有专门负责处理用户的，或者专门处理支付的云函数。</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/a11704b6acf12567bfd1f30429aa51af.png"></p><ul><li>只有一个云函数，云函数里有一个分派任务的路由管理，将不同的任务分配给不同的本地函数处理。也可以是分配给其它的云函数或是其它执行单元。</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/c8fc7ff2790ea3390cc0ee4ae71430f3.png"></p><h3 id="什么场景可以用"><a href="#什么场景可以用" class="headerlink" title="什么场景可以用"></a>什么场景可以用</h3><p>理论上，只要符合下列条件，任何现有业务模块都可以改造成云函数的方式：</p><ul><li>触发响应：双向通信的场景，本质都可以用一方轮询来解决。</li><li>无状态：所有的状态，都可以下沉至BaaS。</li></ul><p><strong>可以用 ≠ 适合用，需要衡量 -&gt; 改造的代价 vs 云函数带来的收益。</strong></p><h3 id="什么场景适合用"><a href="#什么场景适合用" class="headerlink" title="什么场景适合用"></a>什么场景适合用</h3><ul><li>事件驱动及响应式架构</li><li>流量突发场景</li><li>请求对延时要求不高</li><li>低频请求</li><li>单项任务资源要求低</li></ul><h3 id="微信云函数使用的痛点"><a href="#微信云函数使用的痛点" class="headerlink" title="微信云函数使用的痛点"></a>微信云函数使用的痛点</h3><ol><li>报错信息不够友好；</li><li>开发者不能设置阈值从而自动伸缩；</li><li>触发器不够丰富。</li></ol><h2 id="为什么要用云函数"><a href="#为什么要用云函数" class="headerlink" title="为什么要用云函数"></a>为什么要用云函数</h2><h3 id="使用云函数的好处"><a href="#使用云函数的好处" class="headerlink" title="使用云函数的好处"></a>使用云函数的好处</h3><ol><li>简单易用：自动并快速扩缩容；</li><li>稳定可靠：高可用部署、与其他计算服务结合使服务更健壮；</li><li>高效开发：加速开发，简化运维；</li><li>节省成本：不需为空闲资源付费；</li><li>简化管理：可视化管理、简化安全配置。</li></ol><h3 id="使用云函数的缺陷"><a href="#使用云函数的缺陷" class="headerlink" title="使用云函数的缺陷"></a>使用云函数的缺陷</h3><ol><li>需要对业务进行很细粒度的拆分，难以进行或成本太高；</li><li>不适合长时间运行应用；</li><li>对第三方服务依赖过高。</li></ol><p>由于这些局限性，Serverless架构不会成为复杂应用的架构首选，相反，它应该是后端小程序的未来。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://developers.weixin.qq.com/miniprogram/dev/wxcloud/basis/getting-started.html">微信公众平台-小程序-云开发</a></li><li><a href="https://segmentfault.com/a/1190000016206163">Serverless架构详解：开发者如何专注于业务代码本身？</a></li><li><a href="https://juejin.im/post/5a4a5800f265da43294e6631">所谓Serverless，你理解对了吗？</a></li><li><a href="http://www.alloyteam.com/2018/09/13430/">云开发初探 —— 更简便的小程序开发模式丨掘金</a></li><li><a href="https://main.qcloudimg.com/raw/document/product/pdf/583_9197_cn.pdf">腾讯云-无服务器云函数-产品简介-产品文档</a></li><li><a href="https://segmentfault.com/a/1190000014160652">当我们聊Serverless时你应该知道这些</a></li></ul><hr>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    <category term="技术" scheme="https://shiyi.threebody.xyz/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>go包管理工具-glide使用方法及踩坑记录</title>
    <link href="https://shiyi.threebody.xyz/posts/54720.html"/>
    <id>https://shiyi.threebody.xyz/posts/54720.html</id>
    <published>2017-10-01T21:00:00.000Z</published>
    <updated>2022-12-08T15:35:14.153Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>大学以来一直想做一个OJ，终于可以开始，而且是用新学的Go来写，心里还是挺兴奋的。<br>项目启动，要搭架子，第一件事，当然是选择一个包管理工具。Go的包管理还是挺混乱的，没有一个能像Java的Maven一样足够强大&amp;一统天下，尽管优秀的第三方工具已有十来种，且官方也开始着手开发(快统一江湖吧)。<br>(ps:虽然包管理很让人糟心，但这并不能影响我对这门语言的热爱)</p><h1 id="glide"><a href="#glide" class="headerlink" title="glide"></a>glide</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go get github.com/Masterminds/glide<br></code></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>进入项目文件夹。！记住，项目必须放在src下，否则会出现很多问题，包括其他包管理工具！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> <span class="hljs-variable">$GOPATH</span>/src/your_project<br></code></pre></td></tr></table></figure><p>创建glide.yaml文件，并进行相应配置选项</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">glide init<br></code></pre></td></tr></table></figure><p>修改glide.yaml，如果是刚创建的空项目，可以略过这一步。</p><blockquote><p>默认，glide.yaml生成会加入所有import语句的包路径，那么也就包含我们项目内部的包路径，因此我们需要将它们删掉，并对这类import增加过滤规则。</p></blockquote><p>安装glide.yaml配置的包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">glide install<br></code></pre></td></tr></table></figure><p>到这一步，我们的项目初始化就完成了，后续的操作就不再赘述了。</p><h3 id="glide-yml文件"><a href="#glide-yml文件" class="headerlink" title="glide.yml文件"></a>glide.yml文件</h3><blockquote><p>此处摘自<a href="http://blog.csdn.net/chenqijing2/article/details/55050843">Golang包管理工具Glide，你值得拥有</a></p></blockquote><p><code>glide.yml</code>是 <code>glide</code> 包管理的配置文件。下面我们对<code>glide.yml</code>的相关元素进行说明。</p><p>这里是一个完整的<code>glide.yml</code>文件：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-attribute">package</span>: github.com/Masterminds/glide<br><span class="hljs-attribute">homepage</span>: <span class="hljs-attribute">https</span>:<span class="hljs-comment">//masterminds.github.io/glide</span><br><span class="hljs-attribute">license</span>: MIT<br><span class="hljs-attribute">owners</span>:<br>- <span class="hljs-attribute">name</span>: Matt Butcher<br>  <span class="hljs-attribute">email</span>: technosophos<span class="hljs-variable">@gmail</span>.com<br>  <span class="hljs-attribute">homepage</span>: <span class="hljs-attribute">http</span>:<span class="hljs-comment">//technosophos.com</span><br>- <span class="hljs-attribute">name</span>: Matt Farina<br>  <span class="hljs-attribute">email</span>: matt<span class="hljs-variable">@mattfarina</span>.com<br>  <span class="hljs-attribute">homepage</span>: <span class="hljs-attribute">https</span>:<span class="hljs-comment">//www.mattfarina.com</span><br><span class="hljs-attribute">ignore</span>:<br>- appengine<br><span class="hljs-attribute">excludeDirs</span>:<br>- node_modules<br><span class="hljs-attribute">import</span>:<br>- <span class="hljs-attribute">package</span>: gopkg.in/yaml.v2<br>- <span class="hljs-attribute">package</span>: github.com/Masterminds/vcs<br>  <span class="hljs-attribute">version</span>: ^<span class="hljs-number">1.2</span>.<span class="hljs-number">0</span><br>  <span class="hljs-attribute">repo</span>:    git<span class="hljs-variable">@github</span>.<span class="hljs-attribute">com</span>:Masterminds/vcs<br>  <span class="hljs-attribute">vcs</span>:     git<br>- <span class="hljs-attribute">package</span>: github.com/codegangsta/cli<br>  <span class="hljs-attribute">version</span>: f89effe81c1ece9c5b0fda359ebd9cf65f169a51<br>- <span class="hljs-attribute">package</span>: github.com/Masterminds/semver<br>  <span class="hljs-attribute">version</span>: ^<span class="hljs-number">1.0</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">testImport</span>:<br>- <span class="hljs-attribute">package</span>: github.com/arschles/assert<br></code></pre></td></tr></table></figure><p>这些元素是：</p><ul><li><code>package</code>：顶部的 package 是它所在GOPATH的位置，glide 将从该位置下开始导包。</li><li><code>homepage</code>：该项目的详情页面。</li><li><code>license</code>：许可证标识，可以是<a href="http://spdx.org/licenses/">SPDX license</a>字符串或文件路径。</li><li><code>owners</code>：项目的所有者信息，便于接受漏洞信息。</li><li><code>ignore</code>：忽略导入的包，注意是包而不是目录。</li><li><code>excludeDirs</code>：排除扫描依赖的目录。</li><li><code>import</code>：import 的包列表： <ul><li><code>package</code>：导入包的名称，必填。软件包名称遵循go工具所用的相同模式。这意味着：<br>1、映射到VCS远程位置的软件包名称以<code>.git</code>，<code>.bzr</code>，<code>.hg</code>或<code>.svn</code>结尾。 例如，example.com/foo/pkg.git/subpkg。<br>2、GitHub, BitBucket, Launchpad, IBM Bluemix Services, and Go on Google Source是特殊情况，不需要 VCS 扩展。</li><li><code>version</code>：可以为semantic version, semantic version range, branch, tag 或者 commit id。</li><li><code>repo</code>：如果包名称不是repo位置或这是一个私人存储库，它可以去这里。 该软件包将从repo签出并放在软件包名称指定的位置。 这允许使用fork。</li><li><code>vcs</code>：要使用的VCS，如<code>git</code>，<code>hg</code>，<code>bzr</code>或<code>svn</code>。仅当无法从名称中检测到类型时才需要。例如，以<code>.git</code>或GitHub结尾的仓库可以被检测为Git。 对于Bitbucket的repo，我们可以联系API来发现类型。</li><li><code>subpackages</code>：在存储库中使用的包的记录。这不包括存储库中的所有包，而是包括正在使用的包。</li><li><code>os</code>：用于过滤的操作系统的列表。如果设置它将比较当前运行时操作系统与指定的操作系统，并且只有获取匹配的依赖。如果未设置过滤，则跳过。这些名称与构建标志和GOOS环境变量中使用的名称相同。</li><li><code>arch</code>：用于过滤的体系结构列表。如果设置它将比较当前运行时架构与指定的架构，并且只有在匹配时获取依赖关系。如果未设置过滤，则跳过。名称与构建标志和GOARCH环境变量中使用的名称相同。</li></ul></li><li><code>testImport</code>：在导入中未列出的测试中使用的软件包列表。每个包具有与导入下列出的相同的详细信息。</li></ul><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ol><li>项目必须在GOPATH/src内部，强调一下<code>src</code>。</li></ol><h1 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h1><p>我使用的时候是用gin框架当例子来测试，每次install都失败，原因都是一样，有的包出错，无法下载：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">golang.org/x/sys/unix<br></code></pre></td></tr></table></figure><p>后来在网上看到其他道友大多也都遇到过类似的问题。<br>其实是因为Google的原因，go get不能直接访问到golang.org/x这的模块。</p><p>解决方案如下<br>通过github其他路径下获取golang,org/x的镜像文件，并通过软链接的方式，加入到本地golang.org/x中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/golang/net.git <span class="hljs-variable">$GOPATH</span>/src/github.com/golang/net<br><br>git <span class="hljs-built_in">clone</span> https://github.com/golang/sys.git <span class="hljs-variable">$GOPATH</span>/src/github.com/golang/sys<br><br>git <span class="hljs-built_in">clone</span> https://github.com/golang/tools.git <span class="hljs-variable">$GOPATH</span>/src/github.com/golang/tools<br><br>ln -s <span class="hljs-variable">$GOPATH</span>/src/github.com/golang <span class="hljs-variable">$GOPATH</span>/src/golang.org/x<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    <category term="大学时期CSDN" scheme="https://shiyi.threebody.xyz/categories/%E5%A4%A7%E5%AD%A6%E6%97%B6%E6%9C%9FCSDN/"/>
    
    
    <category term="golang" scheme="https://shiyi.threebody.xyz/tags/golang/"/>
    
    <category term="glide" scheme="https://shiyi.threebody.xyz/tags/glide/"/>
    
  </entry>
  
  <entry>
    <title>CSDNtoHexo迁移脚本</title>
    <link href="https://shiyi.threebody.xyz/posts/14430.html"/>
    <id>https://shiyi.threebody.xyz/posts/14430.html</id>
    <published>2017-06-18T13:55:20.000Z</published>
    <updated>2022-12-08T15:35:14.145Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这一阵子，刚换了落脚地儿，没想好该去折腾什么，恰好看到可以用<code>git page</code>搭建一个博客，就搞了搞。关于主题啊，配置啊什么的，网上都有好多，偏偏迁移这个事儿挺麻烦，幸好有找到一<a href="https://github.com/gaocegege/csdn-blog-export">前辈的脚本</a>，可以将CSDN的博客导出为markdown格式，但是其导出来的md文件并不能直接用hexo，想要显示的好一些还需要再用脚本将它二次润色。<br>本人重写了润色的脚本，并增加了对CSDN的分类的爬取，将其作为hexo md文件里面的标签。<br>记录于此，方便大家。</p><p>还有，欢迎访问我的新博客 <a href="http://shiyi.fightcoder.com/">shiyi.fightcoder.com</a></p><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>###python 2.7<br>这个就不说了，os-x，linux都是自带的，window的话自己下个就完了。</p><h3 id="BeautifulSouphttps"><a href="#BeautifulSouphttps" class="headerlink" title="BeautifulSouphttps"></a>BeautifulSouphttps</h3><p>去<a href="https://www.crummy.com/software/BeautifulSoup/">BeautifulSoup官网</a>下载源码包，解压后进入BeautifulSoup文件夹下执行下面命令即可。</p><blockquote><p>python setup.py install</p></blockquote><h3 id="html2text"><a href="#html2text" class="headerlink" title="html2text"></a>html2text</h3><p>下载源码包：<a href="https://pypi.python.org/packages/22/c0/2d02a1fb9027f54796af2c2d38cf3a5b89319125b03734a9964e6db8dfa0/html2text-2016.9.19.tar.gz#md5=d6b07e32ed21f186496f012691e02dd5">html2text-2016.9.19.tar.gz</a>。解压后进入html2text-2016.9.19文件夹下执行下面命令即可。(和上面是一样的)</p><blockquote><p>python setup.py install</p></blockquote><h2 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h2><h3 id="CSDN转MarkDown"><a href="#CSDN转MarkDown" class="headerlink" title="CSDN转MarkDown"></a>CSDN转MarkDown</h3><p>因为代码篇幅问题，请点击<a href="https://coding.net/u/to_be_better/p/blog/git/blob/master/csdn2mark/main.py">CSDN转MD脚本</a>自行拷贝到本地，运行下面命令</p><blockquote><p>python main.py -u 你的CSDN用户名<br>它会将你的CSDN所有的文章全部爬取并在本地以md格式保存。</p></blockquote><h3 id="MarkDown润色使其符合Hexo"><a href="#MarkDown润色使其符合Hexo" class="headerlink" title="MarkDown润色使其符合Hexo"></a>MarkDown润色使其符合Hexo</h3><p>跟上一步一样，请点击<a href="https://coding.net/u/to_be_better/p/blog/git/blob/master/csdn2mark/change.py">MarkDown润色脚本</a>自行拷贝。没问题的话代码开头是下面这样的，按着下面的提示进行更改，然后执行就好了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python</span><br><span class="hljs-comment"># -*- coding: UTF-8 -*-</span><br><br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> re<br><span class="hljs-keyword">import</span> urllib2<br><span class="hljs-comment">#解析博文HTML，获取博文时间、标题标签</span><br><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup<br><span class="hljs-comment">#解决中文编码问题</span><br><span class="hljs-keyword">import</span> codecs<br><br><span class="hljs-comment">#########</span><br><span class="hljs-comment">#htmlpre根据各自的csdn填写对应的。</span><br><span class="hljs-comment">#########</span><br><span class="hljs-comment">#mdPath填写上一步生成的md的所在路径，小白的话就请写绝对路径吧。</span><br><span class="hljs-comment">#########</span><br>htmlpre = <span class="hljs-string">&quot;http://blog.csdn.net/to_be_better/article/details/&quot;</span><br>mdPath = <span class="hljs-string">&#x27;csdn_md/&#x27;</span><br>mdPosts = os.listdir(mdPath)<br><br><span class="hljs-keyword">for</span> postName <span class="hljs-keyword">in</span> mdPosts:<br>    <span class="hljs-keyword">if</span> postName.endswith(<span class="hljs-string">&#x27;.md&#x27;</span>):<br><br></code></pre></td></tr></table></figure><p>这个脚本的功能就是去爬取对应文章的时间和分类，将这些信息对应填写到md的头部，使其符合hexo的标准，最终的结果是如下的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python">---<br>title: <span class="hljs-number">51</span>Nod <span class="hljs-number">1022</span> 石子归并 V2 (划分型dp四边形不等式优化)<br>date: <span class="hljs-number">2015</span><span class="hljs-number">-12</span><span class="hljs-number">-03</span> <span class="hljs-number">03</span>:<span class="hljs-number">34</span><br>tags: [动态规划]<br>category: 大学时期CSDN<br>comment: true---<br>石子归并以前做过好几次，是经典划分型dp题之一，一直用的O(n3)的正常dp方法，也从未想过该怎么去优化它。<br><br>直到昨天做这道题，n的范围由往常的<span class="hljs-number">100</span>改为了<span class="hljs-number">1000</span>，老方法<br>一直超时，苦不堪言，搜到有个四边形不等式的优化方法，看帖子，画式子，拉着学长帮忙推导，总算是大概弄明白了一点。<br><br>dp(i,j) = min(dp(i,k)+  dp(k+<span class="hljs-number">1</span>,j)  ) + w(i,j);(i &lt; j, i&lt;=k&lt;j)<br><br>dp(i,j)  = MAX;(i&gt;j)<br><br>dp(i,j)  = <span class="hljs-number">0</span>;(i=j)<br><br>此处省略后面内容。。。。。。。。。<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    <category term="大学时期CSDN" scheme="https://shiyi.threebody.xyz/categories/%E5%A4%A7%E5%AD%A6%E6%97%B6%E6%9C%9FCSDN/"/>
    
    
    <category term="Hexo" scheme="https://shiyi.threebody.xyz/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Linux上定时器的实现</title>
    <link href="https://shiyi.threebody.xyz/posts/20429.html"/>
    <id>https://shiyi.threebody.xyz/posts/20429.html</id>
    <published>2017-03-02T15:06:00.000Z</published>
    <updated>2022-12-08T15:35:14.149Z</updated>
    
    <content type="html"><![CDATA[<h2 id="方法1-使用sleep或者usleep"><a href="#方法1-使用sleep或者usleep" class="headerlink" title="方法1. 使用sleep或者usleep"></a>方法1. 使用sleep或者usleep</h2><p>这种方法很简单，这里就不具体描述，它的缺点也很明确：精度不够，特别是在系统负载比较大时，会发生超时现象。</p><h2 id="方法2-使用信号量SIGALRM-alarm"><a href="#方法2-使用信号量SIGALRM-alarm" class="headerlink" title="方法2. 使用信号量SIGALRM + alarm()"></a>方法2. 使用信号量SIGALRM + alarm()</h2><p>alarm也称为闹钟函数，alarm()用来设置在经过参数seconds指定的秒数后传送信号SIGALRM给目前的进程。如果参数seconds为0，则之前设<br>置的闹钟会被取消，并将剩下的时间返回。要注意的是，一个进程只能有一个闹钟时间，如果在调用alarm之前已设置过闹钟时间，则任何以前的闹钟时间都被新值所代替。<br>那么我们可以使用signal函数设定SIGALRM的处理函数，然后使用alarm定时发送SIGALRM来达到我们的目的。</p><pre><code class="hljs">#include &lt;stdio.h&gt;#include &lt;signal.h&gt;#include &lt;unistd.h&gt;void timer(int sig)&#123;    if(SIGALRM == sig)    &#123;        printf(&quot;timer\n&quot;);        alarm(1);    &#125;    return;&#125;int main()&#123;    signal(SIGALRM, timer);    alarm(1);    getchar();    return 0;&#125;</code></pre><p>这里只是简单的实现了一下，所以是无线循环定时，完善很容易。<br>这个方法很方便，实现也很简单，但是也有缺点，就是精度不能小于1秒。</p><h2 id="方法3-select-多线程"><a href="#方法3-select-多线程" class="headerlink" title="方法3. select+多线程"></a>方法3. select+多线程</h2><p>原理很简单，利用select()方法的第5个参数，第一个参数设置为0，三个文件描述符集都设置为NULL，第5个参数为时间结构体，设置为我们想要定时的事件频率<br>即可。</p><pre><code class="hljs">#include &lt;iostream&gt;#include &lt;pthread.h&gt;#include &lt;functional&gt;#include &lt;time.h&gt;#include &lt;sys/select.h&gt;#include &lt;unistd.h&gt;class Timer&#123;public:    Timer() = default;    Timer(int sec, int usec, int count, const std::function&lt;void()&gt; &amp;callback)    : sec_(sec), usec_(usec), count_(count), callback_(callback)&#123;    &#125;    void startTimer()&#123;        pthread_create(&amp;thread_, NULL, work, this);    &#125;    void endTimer()&#123;        //终止线程        pthread_cancel(thread_);        //回收线程资源        pthread_join(thread_, NULL);    &#125;private:    //解决类成员函数不能作为pthread_create函数参数的问题    static void* work(void* timer)&#123;        static_cast&lt;Timer*&gt;(timer)-&gt;workTimer();    &#125;    void workTimer()&#123;        for(int i=0; i&lt;count_; i++)&#123;            struct timeval tempval;            tempval.tv_sec = sec_;            tempval.tv_usec = usec_;            select(0, NULL, NULL, NULL, &amp;tempval);            callback_();        &#125;    &#125;    int sec_;    int usec_;    int count_;    std::function&lt;void()&gt; callback_;    pthread_t thread_;&#125;;int main()&#123;    Timer a(1,0,10,[]()&#123;std::cout&lt;&lt;&quot;timer a&quot;&lt;&lt;std::endl;&#125;);    a.startTimer();    Timer b(2,0,5,[]()&#123;std::cout&lt;&lt;&quot;timer b&quot;&lt;&lt;std::endl;&#125;);    b.startTimer();    getchar();    return 0;&#125;</code></pre><p>运行结果：<br>![这里写图片描述](<a href="http://img.blog.csdn.net/20170302230249299?watermark/2/text/aHR0cDo">http://img.blog.csdn.net/20170302230249299?watermark/2/text/aHR0cDo</a><br>vL2Jsb2cuY3Nkbi5uZXQvdG9fYmVfYmV0dGVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFC<br>MA==/dissolve/70/gravity/SouthEast)</p>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    <category term="大学时期CSDN" scheme="https://shiyi.threebody.xyz/categories/%E5%A4%A7%E5%AD%A6%E6%97%B6%E6%9C%9FCSDN/"/>
    
    
    <category term="Linux系统编程" scheme="https://shiyi.threebody.xyz/tags/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>对比高性能I/O设计模式-Reactor/Proactor</title>
    <link href="https://shiyi.threebody.xyz/posts/609.html"/>
    <id>https://shiyi.threebody.xyz/posts/609.html</id>
    <published>2017-03-01T10:40:00.000Z</published>
    <updated>2022-12-08T15:35:14.153Z</updated>
    
    <content type="html"><![CDATA[<p>通常，I/O复用机制都需要事件分享器。分享器对象可将来自事件源的I/O事件分离出来，并分发到对应的Read/Write事件处理器。开发人员预先注册需要处理的<br>事件及该事件对应的事件处理器。<br>Reactor和Proactor都涉及到了事件分享器，不同的是，Reactor是基于同步I/O的，而Proactor是与异步I/O相关。</p><p>在Reactor模式中，事件分离器等待某个事件或者某个操作的状态发生，比如文件描述符可读写或是socket可读写，事件分离器就将这个时间传给事先注册的事件处<br>理器(事件处理函数或者回调函数)，由后者来做实际的读写操作。</p><p>而在Proactor模式中，事件处理器直接发起一个异步读写操作，发起时，需要提供用于存放读到数据的缓存区、读的数据大小。以及这个请求完成后的回调函数等信息。<br>事件分离器收到请求后，默默等待这个请求的完成，然后转发完成事件给对应的事件处理器。这种异步模式的典型实现是基于操作系统底层异步API的，所以我们可以称之为“<br>系统级别”的或者“真正意义上”的异步，因为具体的读写操作是由操作系统来代劳的。</p><p>我们用读操作来举例，更好的理解Reactor和Proactor两种模式的区别。<br>Reactor：</p><ul><li>某个事件处理器宣称它对某个socket上的读事件很感兴趣(发起读请求)</li><li>事件分离器等待这个事件的发生</li><li>事件发生时，事件分离器被唤醒，然后通知先前那个事件处理者</li><li>事件处理者接到通知，于是去那个socket上读数据，如果需要，它再次宣称对这个socket上的读事件感兴趣，一直重复上面的步骤</li></ul><p>Proactor(系统级别异步)：</p><ul><li>事件处理者直接发起一个写请求，这个时候，事件处理者不关心读事件，它只是发请求而已，发完之后就不管具体的事了，，只等着系统帮他搞定之后给他的回话。</li><li>事件分离者等待着这个读事件的完成，与此同时，系统已经在一边开始干活了，它从目标socket读取数据，放入用户提供的缓存区中，完成后，通知事件分离者</li><li>事件分离者通知事件处理者，读事件已经完成</li><li>事件处理者会从它所提供的缓存区中获得它想要读的数据，按照自己我需要进行处理。如果需要，它可以像之前一样继续发起一个操作请求，无论是写操作还是读操作，和上面的几个步骤一样</li></ul><p>然而，并不是所有的操作系统都为底层异步提供健壮的支持，比如许多Unix系统。</p><p>正如上面所提到过的，真正的异步模式需要操作系统级别的支持。由于事件处理者及操作系统交互的差异，为Reactor何Proactor设计一种通用统一的外部接口是<br>非常困难的。因此，大多网络库或是开发框架都是在两种模式之一，唯一一个包含两者的ACE，也是为Window准备了ACE<br>Proactor、为Unix系列提供了ACE Reactor，并且两者的代码分别独立维护。</p><p>为了解决这个情况，我们可以将Reactor稍做调整，模拟成异步的Proactor模型(主要是在事件分离器里完成本该事件处理者做的实际读写工作，我们称这种方法<br>为“模拟异步”)。</p><p>Proactor(模拟异步)：</p><ul><li>事件处理者宣告对读事件感兴趣，并提供用于存储读出的结果的缓存区、读的数据长度等参数</li><li>事件分离器等待，当事件到来时，分离器被唤醒，并去执行非阻塞的读操作，读取完毕后，通知事件处理者。</li><li>事件处理者这时会被通知读操作完成，并且已经获得了想要获取的数据。</li></ul><p>我们看到，通过为分离者添加一些功能，就可以让Reactor模式转换为Proactor模式。所有这些被执行的操作，其实是和Reactor模式应用时完全一致的。<br>我们只是把工作打散分配给不同的角色去完成而已。这样并不会有额外的开销，也不会有性能的损失。<br>我们再来对比一下Reactor和模拟的Proactor两个过程。</p><p>Reactor：</p><ul><li>等待事件</li><li>发“已经可读”事件给实现注册的事件处理者或者回调</li><li>读数据</li><li>处理数据</li></ul><p>Proactor：</p><ul><li>等待事件</li><li>读数据</li><li>发“数据已经读取完毕”事件给实现注册的事件处理器或者回调</li><li>处理数据</li></ul><p>在没有底层异步I/O<br>API支持的操作系统，这种方法可以帮我们隐藏掉socket接口的差异，提供一个完全可用并且统一的“异步接口”。这样我们就可以开发真正平台独立的通用接口了。</p><p>参考博客：<br><a href="http://blog.jobbole.com/59676/"> http://blog.jobbole.com/59676/ </a><br><a href="https://www.zhihu.com/question/26943938/answer/35034068"> https://www.zhihu.com/question/26943938/answer/35034068</a></p>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    <category term="大学时期CSDN" scheme="https://shiyi.threebody.xyz/categories/%E5%A4%A7%E5%AD%A6%E6%97%B6%E6%9C%9FCSDN/"/>
    
    
    <category term="服务器开发" scheme="https://shiyi.threebody.xyz/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/"/>
    
    <category term="Linux网络编程" scheme="https://shiyi.threebody.xyz/tags/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>游戏服务器和一般服务器对比，有何特别？</title>
    <link href="https://shiyi.threebody.xyz/posts/3361.html"/>
    <id>https://shiyi.threebody.xyz/posts/3361.html</id>
    <published>2017-02-26T18:57:00.000Z</published>
    <updated>2022-12-08T15:35:14.153Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在中国的互联网诸多业务领域中，游戏一直是充当“现金牛”而存在的。但是，在游戏服务器端开发领域中的很多重要问题，并没有被明确的分辨出其特异性，从而得到专门的对<br>待。我们不管是在业界开源领域，还是内部分享中，很少会有专门针对游戏业务特征进行专门设计的组件、类库或者框架。我们从游戏的客户端方面来看，一款专业的游戏客户端<br>引擎，已经是游戏开发的标配，比如最早的Flash<br>Builder，到后期的Cocos2d-X，Unity，Unreal；但是服务器端，我们几乎找不到同样重量级的产品。</p><h2 id="游戏服务器和一般服务器的区别"><a href="#游戏服务器和一般服务器的区别" class="headerlink" title="游戏服务器和一般服务器的区别"></a>游戏服务器和一般服务器的区别</h2><p>在游戏服务器端开发所有要面对的问题中，有两个是最核心和最普遍的：一是和客户端的通讯；二是游戏登录用户的数据处理。对于和客户端通讯的这个问题，大量的游戏开发者<br>会使用“通用”的开源组件，比如Protocol<br>Buffer，Thrift，Jetty，Node.js等等通信或RPC框架。虽然针对游戏，还是要做大量的改造，但一般都有很多现成的代码可供修改。</p><p>在一般的互联网应用中，我们一般认为服务都是通过请求-响应的方式来完成的。而在游戏业务领域中，请求-响应可以看成是一种类型的通讯方式，但还有另外一种重要的通讯<br>模型，就是“数据同步”方式：游戏中某个角色的HP、位置坐标改变了，需要在客户端和服务器之间、客户端和客户端之间同步。这造成了一般情况下通信协议的大量增加。</p><p>对于第二个问题，不管是memcache还是MySQL，或者是Redis，都不能完全满足游戏开发者的需求。很多团队尝试过各种组合和修改，试图创造出利用现有开源<br>软件，建设既能迎合灵活的需求变化，又具备低延迟和高可用的数据处理系统，但最后这些努力基本上都很难圆满成功。因此我们在游戏服务器端代码中，还是充斥着大量的内存<br>、缓存管理，数据同步、落地等等代码。而且每个游戏都要重新去写一遍这些类似的功能，不能不说一种浪费。</p><p>如果我们要想出一种能满足“游戏”这个业务领域的数据系统设计，那么就一定要搞清楚为什么在如此之多的开源项目和游戏团队中，没能实现完美契合的原因。</p><h3 id="电子商务-一般互联网业务的C-S通讯流程"><a href="#电子商务-一般互联网业务的C-S通讯流程" class="headerlink" title="电子商务/一般互联网业务的C-S通讯流程"></a>电子商务/一般互联网业务的C-S通讯流程</h3><p>基于WebService类型的通讯模型，现在基本已经成为互联网开源组件的标准。由此而诞生的RESTful<br>API，或者各种RPC模型，其实都是基于这样的客观事实：<br>![这里写图片描述](<a href="http://bbs.gameres.com/data/attachment/forum/201609/28/11164011ymvy">http://bbs.gameres.com/data/attachment/forum/201609/28/11164011ymvy</a><br>03v1a91zy3.jpg)</p><ul><li><p>用户主动请求，服务器产生回应。典型的就是网页的点击、表单的提交。</p></li><li><p>主动通知的消息，仅仅是提示用户发起查询请求。比如在APP按钮上的小红点，消息页的数字提示等等，这些主动通知都是为了通知用户去刷新页面。</p></li></ul><p>![游戏服务器和一般服务器对比，有何特别？ …](<a href="http://bbs.gameres.com/data/attachment/forum/201609">http://bbs.gameres.com/data/attachment/forum/201609</a><br>/28/111640s3tf1zrfx3xr5ovp.jpg)</p><h3 id="游戏类业务的通信流程"><a href="#游戏类业务的通信流程" class="headerlink" title="游戏类业务的通信流程"></a>游戏类业务的通信流程</h3><p>游戏中的通信，一般和操作有关。这些操作一般分为两类：</p><ul><li><p>UI面板类操作</p></li><li><p>战斗场景操作</p></li></ul><p>这两者的最大区别，就是UI面板类操作一般无需让其他玩家看见。而战斗场景操作则需要广播给所有玩家看到。</p><p>![这里写图片描述](<a href="http://bbs.gameres.com/data/attachment/forum/201609/28/11164086n6b6">http://bbs.gameres.com/data/attachment/forum/201609/28/11164086n6b6</a><br>g18622zwaf.jpg)<br>![这里写图片描述](<a href="http://bbs.gameres.com/data/attachment/forum/201609/28/111641rayh26">http://bbs.gameres.com/data/attachment/forum/201609/28/111641rayh26</a><br>grdjt72lrw.jpg)</p><p>在第二种情况下，一般就不是客户端主动发起，而是服务器端直接推送实际数据，然后客户端直接显示这些数据。这个模式和简单的“推送”还不一样，而应该更进一步，是一种<br>从服务器端发起的，向客户端“同步”数据的请求。</p><p>因此，一个好的游戏服务器端框架，应该是能同时支持请求-响应模型和“推送同步”模型的。</p><h3 id="电子商务-一般互联网类业务的数据处理流程"><a href="#电子商务-一般互联网类业务的数据处理流程" class="headerlink" title="电子商务/一般互联网类业务的数据处理流程"></a>电子商务/一般互联网类业务的数据处理流程</h3><p>Memcache、Redis、MySQL在一般互联网业务中的应用非常广泛。而且基本上能很好的应对各种常见的应用场景，包括类似BBS的社区、新闻门户、电子商务<br>类系统。在企业内部信息系统中（Intranet），这一类数据软件也能发挥非常好的功效。由于电子商务类是其中最复杂的系统，所以我在这里以此为例说明，一般数据处<br>理的流程是如何的。</p><p>![这里写图片描述](<a href="http://bbs.gameres.com/data/attachment/forum/201609/28/11164109w8k0">http://bbs.gameres.com/data/attachment/forum/201609/28/11164109w8k0</a><br>802e0li008.jpg)</p><p>假设我们浏览了一个网店，选中了一个商品，点击了下单这个流程，实际上需要的后台流程可能是下图所示：</p><p>![](<a href="http://bbs.gameres.com/data/attachment/forum/201609/28/111641yg8vvs0y6gn7g">http://bbs.gameres.com/data/attachment/forum/201609/28/111641yg8vvs0y6gn7g</a><br>yh7.gif)</p><p>从上面的分析大概可以总结出几个特点：</p><p>一、忍受延迟：每个操作的延迟要求较低，操作频率不会太高。一般我们页面在5秒内打开，都不会引起太多客户的抗议。所以，就算我们处理一个请求的时候，后台进行多次的<br>进程间调用，产生的延迟和带宽消耗也是可以忍受的。</p><p>二、在线交互少：互联网业务大多数是基于浏览器的，所以在线用户之间很少实时交互。</p><p>三、数据分散：一般来说，互联网应用的数据可以在多个不同的业务系统中共用，但是需要专门的业务模块来做管理，以维持数据的一致性。</p><p>四、数据变更面广：系统需要持续处理很多数据变更，互联网业务有很大一部分数据是来源于普通用户、网络编辑、店主等等使用者，在使用的过程中，他们会大量的修改系统所<br>存储的数据。</p><p>以上四个特点，导致了我们一般会把后台要处理的数据，分别用Cache系统和DB系统来处理。并且，我们一般会按业务功能划分模块，同时也划分业务系统。由于延迟和在<br>线交互的需求较弱，所以使用大量进程来做模块隔离，依然是非常可行的，总体来说，就是一种比较“分散”的数据使用方式。</p><h3 id="游戏类业务的数据处理流程"><a href="#游戏类业务的数据处理流程" class="headerlink" title="游戏类业务的数据处理流程"></a>游戏类业务的数据处理流程</h3><p>在各种游戏中，MMORPG是数据处理最为复杂的一类，也是最典型的一种“重服务器端”的游戏类型，因此可以作为游戏业务中通用性的参考标准。在MMORPG中，我们<br>可以发现，数据的处理需求，和一般互联网业务大相径庭，它体现出的是一种明显的“集中”式的数据处理需求。我们可以从一般MMORPG的服务器架构中体现出来：</p><p>![](<a href="http://bbs.gameres.com/data/attachment/forum/201609/28/111641ezyefv6z6hq4y">http://bbs.gameres.com/data/attachment/forum/201609/28/111641ezyefv6z6hq4y</a><br>23v.gif)</p><p>在游戏业务中，一般我们都会发现以下的特点：</p><p>一、延迟敏感：游戏中用户会产生大量操作，都要求“实时”进行反馈，所以一般都不能忍受1秒以上的延迟，在大量动作类型的游戏中，一般都会要求服务器的反馈时延在50<br>ms左右。因此游戏开发者都习惯于尽量减少后台进程间的交互，尽管这对提高系统吞吐量很不利。所以大部分游戏服务器端都有一个所谓“GameServer”，里面运行<br>了游戏70%以上的功能。</p><p>二、大量实时交互：在线游戏的特点，就是很多玩家可以通过服务器“看见”彼此，能实时的互动。因此我们必须要把用户的在线数据，集中到一起，才能提供互相操作的可能；<br>而且A用户操作B用户的数据，是最常见的数据操作，所谓战斗玩法，就是互相修改对方的数据的过程。</p><p>三、数据集中：游戏是一个几乎完全虚拟的世界，在游戏中的数据，实际上很少能在其他系统中产生价值。而游戏逻辑也禁止通过游戏以外的方式，修改游戏的数据。所以游戏中<br>的数据，一般都会集中存放在单独的数据库中。由于没有数据共用的需求，所以也不需要把GameServer里面集中的逻辑划分出很多单独的进程模块来。</p><p>四、数据变更少：实际上游戏的数据变更还是很快的，比如游戏中的每次中弹，都要减少HP的数值。但是游戏里的数据，一般都遵守这样一个规则：“变化越快的数据，重要性<br>越低”。也就是说，游戏中是可以容忍一定程度的数据不一致和不完整的。而游戏中的数据，一般会分成两类：玩家存档和游戏设置。对于玩家存档来说，其单条数据量一般不大<br>，但会有大量的记录数，因为每个玩家都会有一个存档。但是其读取、修改，一般很典型的和玩家的登录、登出、升级等业务逻辑密切关联，所以其缓存时机是比较容易根据业务<br>逻辑来把握的。而对于游戏设置数据来说，几乎只有升级游戏版本的时候才会修改，大部分运行时是只读的，其缓存简单的读入内存就解决问题了。</p><p>一般的缓存系统的特点在游戏中的问题</p><p>根据以上的分析，我们可以看到，普通的缓存系统，如memcache和Redis，实际上其特点是不太适合游戏业务的：</p><ul><li><p>一般跨进程的缓存系统，无法解决游戏要求的低延迟问题。级别是同机房，每次数据存取都需要10-20ms的时间，对于游戏战斗中大量的数据读、写来说，是很难接受的。（但是一些回合制战斗、低频操作还是有用的）</p></li><li><p>通用型的缓存系统或者数据库，一般都比较难集结多个进程，形成一个完整的数据存储网格。这让玩家间的互相交互产生了额外的难度，开发者必须先想办法确定玩家的数据在哪个后台进程上，然后才能去读写。一般的数据库或缓存系统，为了保证数据的一致性或者完整性，往往会需要牺牲一些分布式的能力。而这种牺牲在游戏业务中，其实是一种浪费，因为游戏的很多数据都无需这种能力。</p></li><li><p>通用性数据系统一般不依赖于特定的语言，所以很少能直接把某种“对象”存入到数据系统中。在游戏开发中，需要存储的数据结构数量往往是非常大量的：一个普通的游戏，基本上都会超过100种数据结构。对于每个数据结构，都去建表或者编写序列化/反序列化配置，是一种非常累人的工作。–明明在代码中，已经用编程语言定义了他们的结构，还要重复的搞一次。</p></li></ul><p>根据上面说的这些问题，我们实际上是需要另外一种完全不同设计思想的数据系统。</p><p>对于游戏业务来说，一个好用的数据系统，应该包括这样一些特点：</p><ul><li><p>可以利用GameServer进程内的内存进行自动化的缓存管理。由于GameServer进程往往集中了大部分的逻辑运算，所以大部分的数据缓存也应该在这个进程中，这样才能符合游戏所需的延迟要求。</p></li><li><p>自动进行数据落地和容灾管理。由于游戏数据中有大量的“过程数据”，所以其一致性和完整性要求会稍微低于其他业务，所以应该利用这一点，让GameServer本身也可以是分布式的程序，从而提高系统整体的吞吐量。</p></li><li><p>具备良好的编程易用性。最好是能直接存取编程中的对象，避免反复对数据结构的描述，节省大量的开发时间。</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>游戏服务器和普通互联网业务服务器端，最大的区别实际上就在于“状态”。游戏服务器的状态是实时快速变化的、可以容忍丢失的、需要大量广播同步的；普通互联网业务服务<br>器的状态一般是持久化的、不容忍丢失的、只和特定客户端相关的。所以一个好的游戏服务器框架，在通讯和数据这两个基本层面，会和一般我们所接触的开源组件有很大的差异<br>。这也是作为游戏服务器端开发者，需要去共同建设行业标准的地方。</p>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    <category term="大学时期CSDN" scheme="https://shiyi.threebody.xyz/categories/%E5%A4%A7%E5%AD%A6%E6%97%B6%E6%9C%9FCSDN/"/>
    
    
    <category term="游戏开发" scheme="https://shiyi.threebody.xyz/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>各类游戏对应的服务端架构</title>
    <link href="https://shiyi.threebody.xyz/posts/22612.html"/>
    <id>https://shiyi.threebody.xyz/posts/22612.html</id>
    <published>2017-02-24T14:48:00.000Z</published>
    <updated>2022-12-08T15:35:14.153Z</updated>
    
    <content type="html"><![CDATA[<h2 id="卡牌、跑酷等弱交互服务端"><a href="#卡牌、跑酷等弱交互服务端" class="headerlink" title="卡牌、跑酷等弱交互服务端"></a>卡牌、跑酷等弱交互服务端</h2><p>卡牌跑酷类因为交互弱，玩家和玩家之间不需要实时面对面PK，打一下对方的离线数据，计算下排行榜，买卖下道具即可，所以实现往往使用简单的 HTTP服务器：</p><p>![这里写图片描述](<a href="http://img.blog.csdn.net/20170224223228952?watermark/2/text/aHR0cDo">http://img.blog.csdn.net/20170224223228952?watermark/2/text/aHR0cDo</a><br>vL2Jsb2cuY3Nkbi5uZXQvdG9fYmVfYmV0dGVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFC<br>MA==/dissolve/70/gravity/SouthEast)</p><p>登录时可以使用非对称加密（RSA, DH），服务器根据客户端uid，当前时间戳还有服务端私钥，计算哈希得到的加密 key 并发送给客户端。之后双方都用<br>HTTP通信，并用那个key进行RC4加密。客户端收到key和时间戳后保存在内存，用于之后通信，服务端不需要保存 key，因为每次都可以根据客户端传上来的<br>uid 和 时间戳 以及服务端自己的私钥计算得到。用模仿 TLS的行为，来保证多次 HTTP请求间的客户端身份，并通过时间戳保证同一人两次登录密钥不同。</p><p>每局开始时，访问一下，请求一下关卡数据，玩完了又提交一下，验算一下是否合法，获得什么奖励，数据库用单台 MySQL或者 MongoDB即可，后端的 Redi<br>s做缓存（可选）。如果要实现通知，那么让客户端定时15秒轮询一下服务器，如果有消息就取下来，如果没消息可以逐步放长轮询时间，比如30秒；如果有消息，就缩短轮<br>询时间到10秒，5秒，即便两人聊天，延迟也能自适应。</p><p>此类服务器用来实现一款三国类策略或者卡牌及酷跑的游戏已经绰绰有余，这类游戏因为逻辑简单，玩家之间交互不强，使用<br>HTTP来开发的话，开发速度快，调试只需要一个浏览器就可以把逻辑调试清楚了。</p><h2 id="类型2：第一代游戏服务器-1978"><a href="#类型2：第一代游戏服务器-1978" class="headerlink" title="类型2：第一代游戏服务器 1978"></a>类型2：第一代游戏服务器 1978</h2><p>1978年，英国著名的财经学校University of Essex的学生 Roy<br>Trubshaw编写了世界上第一个MUD程序《MUD1》，在University of Essex于1980年接入<br>ARPANET之后加入了不少外部的玩家，甚至包括国外的玩家。《MUD1》程序的源代码在<br>ARPANET共享之后出现了众多的改编版本，至此MUD才在全世界广泛流行起来。不断完善的 MUD1的基础上产生了开源的<br>MudOS（1991），成为众多网游的鼻祖：</p><p>![这里写图片描述](<a href="http://img.blog.csdn.net/20170224223334437?watermark/2/text/aHR0cDo">http://img.blog.csdn.net/20170224223334437?watermark/2/text/aHR0cDo</a><br>vL2Jsb2cuY3Nkbi5uZXQvdG9fYmVfYmV0dGVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFC<br>MA==/dissolve/70/gravity/SouthEast)</p><p>MUDOS采用 C语言开发，因为玩家和玩家之间有比较强的交互（聊天，交易，PK），MUDOS使用单线程无阻塞套接字来服务所有玩家，所有玩家的请求都发到同一个<br>线程去处理，主线程每隔1秒钟更新一次所有对象（网络收发，更新对象状态机，处理超时，刷新地图，刷新NPC）。</p><p>游戏世界采用房间的形式组织起来，每个房间有东南西北四个方向可以移动到下一个房间，由于欧美最早的网游都是地牢迷宫形式的，因此场景的基本单位被成为 “房间”。M<br>UDOS使用一门称为LPC的脚本语言来描述整个世界（包括房间拓扑，配置，NPC，以及各种剧情）。游戏里面的高级玩家（巫师），可以不断的通过修改脚本来为游戏添<br>加房间以及增加剧情。早年 MUD1上线时只有17个房间，Roy Trubshaw毕业以后交给他的师弟 Richard Battle，在 Richard<br>Battle手上，不断的添加各种玩法到一百多个房间，终于让 MUD发扬光大。</p><p>用户使用 Telnet之类的客户端用 Tcp协议连接到 MUDOS上，使用纯文字进行游戏，每条指令用回车进行分割。比如 1995年国内第一款<br>MUD游戏《侠客行》，你敲入：”go east”，游戏就会提示你：“后花园 -<br>这里是归云庄的后花园，种满了花草，几个庄丁正在浇花。此地乃是含羞草生长之地。这里唯一的出口是 north。这里有：花待 阿牧（A<br>mu），还有二位庄丁（Zhuang Ding）”，然后你继续用文字操作，查看阿牧的信息：“look a mu”，系统提示：“花待 阿牧（A mu）他是陆乘风<br>的弟子，受命在此看管含羞草。他看起来三十多岁，生得眉清目秀，端正大方，一表人才。他的武艺看上去【不是很高】，出手似乎【极轻】”。然后你可以选择击败他获得含羞<br>草，但是你吃了含羞草却又可能会中毒死亡。在早期网上资源贫乏的时候，这样的游戏有很强的代入感。</p><p>用户数据保存在文件中，每个用户登录时，从文本文件里把用户的数据全部加载进来，操作全部在内存里面进行，无需马上刷回磁盘。用户退出了，或者每隔5分钟检查到数据改<br>动了，都会保存会磁盘。这样的系统在当时每台服务器承载个4000人同时游戏，不是特别大的问题。从1991年的<br>MUDOS发布后，全球各地都在为他改进，扩充，退出新版本，随着 Windows图形机能的增强。1997游戏《UO》在<br>MUDOS的基础上为角色增加的x,y坐标，为每个房间增加了地图，并且为每个角色增加了动画，形成了第一代的图形网络游戏。</p><p>因为游戏内容基本可以通过 LPC脚本进行定制，所以MUDOS也成为名副其实的第一款服务端引擎，引擎一次性开发出来，然后制作不同游戏内容。后续国内的《万王之王<br>》等游戏，很多都是跟《UO》一样，直接在 MUDOS上进行二次开发，加入房间的地图还有角色的坐标等要素，该架构一直为国内的第一代<br>MMORPG提供了稳固的支持，直到 2003年，还有游戏基于 MUDOS开发。</p><p>虽然后面图形化增加了很多东西，但是这些MMORPG后端的本质还是<br>MUDOS。随着游戏内容的越来越复杂，架构变得越来越吃不消了，各种负载问题慢慢浮上水面，于是有了我们的第二代游戏服务器。</p><h2 id="类型3：第二代游戏服务器-2003"><a href="#类型3：第二代游戏服务器-2003" class="headerlink" title="类型3：第二代游戏服务器 2003"></a>类型3：第二代游戏服务器 2003</h2><p>2000年后，网游已经脱离最初的文字MUD，进入全面图形化年代。最先承受不住的其实是很多小文件，用户上下线，频繁的读取写入用户数据，导致负载越来越大。随着在<br>线人数的增加和游戏数据的增加，服务器变得不抗重负。同时早期 EXT磁盘分区比较脆弱，稍微停电，容易发生大面积数据丢失。因此第一步就是拆分文件存储到数据库去。</p><p>![这里写图片描述](<a href="http://img.blog.csdn.net/20170224223605113?watermark/2/text/aHR0cDo">http://img.blog.csdn.net/20170224223605113?watermark/2/text/aHR0cDo</a><br>vL2Jsb2cuY3Nkbi5uZXQvdG9fYmVfYmV0dGVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFC<br>MA==/dissolve/70/gravity/SouthEast)</p><p>此时游戏服务端已经脱离陈旧的 MUDOS体系，各个公司在参考 MUDOS结构的情况下，开始自己用 C在重新开发自己的游戏服务端。并且脚本也抛弃了<br>LPC，采用扩展性更好的 Python或者<br>Lua来代替。由于主逻辑使用单线程模型，随着游戏内容的增加，传统单服务器的结构进一步成为瓶颈。于是有人开始拆分游戏世界，变为下面的模型：</p><p>![这里写图片描述](<a href="http://img.blog.csdn.net/20170224223638801?watermark/2/text/aHR0cDo">http://img.blog.csdn.net/20170224223638801?watermark/2/text/aHR0cDo</a><br>vL2Jsb2cuY3Nkbi5uZXQvdG9fYmVfYmV0dGVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFC<br>MA==/dissolve/70/gravity/SouthEast)</p><p>游戏服务器压力拆分后得意缓解，但是两台游戏服务器同时访问数据库，大量重复访问，大量数据交换，使得数据库成为下一个瓶颈。于是形成了数据库前端代理（DB<br>Proxy），游戏服务器不直接访问数据库而是访问代理，再有代理访问数据库，同时提供内存级别的cache。早年<br>MySQL4之前没有提供存储过程，这个前端代理一般和<br>MySQL跑在同一台上，它转化游戏服务器发过来的高级数据操作指令，拆分成具体的数据库操作，一定程度上代替了存储过程：</p><p>![这里写图片描述](<a href="http://img.blog.csdn.net/20170224223734332?watermark/2/text/aHR0cDo">http://img.blog.csdn.net/20170224223734332?watermark/2/text/aHR0cDo</a><br>vL2Jsb2cuY3Nkbi5uZXQvdG9fYmVfYmV0dGVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFC<br>MA==/dissolve/70/gravity/SouthEast)</p><p>但是这样的结构并没有持续太长时间，因为玩家切换场景经常要切换连接，中间的状态容易错乱。而且游戏服务器多了以后，相互之间数据交互又会变得比较麻烦，于是人们拆分<br>了网络功能，独立出一个网关服务 Gate（有的地方叫 Session，有的地方叫 LinkSvr之类的，名字不同而已）：</p><p>![这里写图片描述](<a href="http://img.blog.csdn.net/20170224223806926?watermark/2/text/aHR0cDo">http://img.blog.csdn.net/20170224223806926?watermark/2/text/aHR0cDo</a><br>vL2Jsb2cuY3Nkbi5uZXQvdG9fYmVfYmV0dGVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFC<br>MA==/dissolve/70/gravity/SouthEast)</p><p>把网络功能单独提取出来，让用户统一去连接一个网关服务器，再有网关服务器转发数据到后端游戏服务器。而游戏服务器之间数据交换也统一连接到网管进行交换。这样类型的<br>服务器基本能稳定的为玩家提供游戏服务，一台网关服务1-2万人，后面的游戏服务器每台服务5k-<br>1w，依游戏类型和复杂度不同而已，图中隐藏了很多不重要的服务器，如登录和管理。这是目前应用最广的一个模型，到今天任然很多新项目会才用这样的结构来搭建。</p><p>人都是有惯性的，按照先前的经验，似乎把<br>MUDOS拆分的越开性能越好。于是大家继续想，网关可以拆分呀，基础服务如聊天交易，可以拆分呀，还可以提供web接口，数据库可以拆分呀，于是有了下面的模型：</p><p>![这里写图片描述](<a href="http://img.blog.csdn.net/20170224223843835?watermark/2/text/aHR0cDo">http://img.blog.csdn.net/20170224223843835?watermark/2/text/aHR0cDo</a><br>vL2Jsb2cuY3Nkbi5uZXQvdG9fYmVfYmV0dGVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFC<br>MA==/dissolve/70/gravity/SouthEast)</p><p>这样的模型好用么？确实有成功游戏使用类似这样的架构，并且发挥了它的性能优势，比如一些大型 MMORPG。但是有两个挑战：每增加一级服务器，状态机复杂度可能会<br>翻倍，导致研发和找bug的成本上升；并且对开发组挑战比较大，一旦项目时间吃紧，开发人员经验不足，很容易弄挂。</p><p>比如我见过某上海一线游戏公司的一个 RPG上来就要上这样的架构，我看了下他们团队成员的经验，问了下他们的上线日期，劝他们用前面稍微简单一点的模型。人家自信得<br>很，认为有成功项目是这么做的，他们也要这么做，自己很想实现一套。于是他们义无反顾的开始编码，项目做了一年多，然后，就没有然后了。</p><p>现今在游戏成功率不高的情况下，一开始上一套比较复杂的架构需要考虑投资回报率，比如你的游戏上线半年内 PCU会去到多少？如果一个 APRG游戏，每组服务器5千<br>人都到不了的话，那么选择一套更为贴近实际情况的结构更为经济。即使后面你的项目真的超过5千人朝着1万人目标奔的话，相信那个时候你的项目已经挣大钱了<br>，你数着钱加着班去逐步迭代，一次次拆分它，相信心里也是乐开花的。</p><p>上面这些类型基本都是从拆分 MUDOS开始，将<br>MUDOS中的各个部件从单机一步步拆成分布式。虽然今天任然很多新项目在用上面某一种类似的结构，或者自己又做了其他热点模块的拆分。因为他们本质上都是对<br>MUDOS的分解，故将他们归纳为第二代游戏服务器。</p><h2 id="类型4：第三代游戏服务器-2007"><a href="#类型4：第三代游戏服务器-2007" class="headerlink" title="类型4：第三代游戏服务器 2007"></a>类型4：第三代游戏服务器 2007</h2><p>从魔兽世界开始无缝世界地图已经深入人心，比较以往游戏玩家走个几步还需要切换场景，每次切换就要等待<br>LOADING个几十秒是一件十分破坏游戏体验的事情。于是对于 2005年以后的大型<br>MMORPG来说，无缝地图已成为一个标准配置。比较以往按照地图来切割游戏而言，无缝世界并不存在一块地图上面的人有且只由一台服务器处理了：</p><p>![这里写图片描述](<a href="http://img.blog.csdn.net/20170224224000477?watermark/2/text/aHR0cDo">http://img.blog.csdn.net/20170224224000477?watermark/2/text/aHR0cDo</a><br>vL2Jsb2cuY3Nkbi5uZXQvdG9fYmVfYmV0dGVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFC<br>MA==/dissolve/70/gravity/SouthEast)</p><p>每台 Node服务器用来管理一块地图区域，由 NodeMaster（NM）来为他们提供总体管理。更高层次的<br>World则提供大陆级别的管理服务。这里省略若干细节服务器，比如传统数据库前端，登录服务器，日志和监控等，统统用<br>ADMIN概括。在这样的结构下，玩家从一块区域走向另外一块区域需要简单处理一下：</p><p>![这里写图片描述](<a href="http://img.blog.csdn.net/20170224224040931?watermark/2/text/aHR0cDo">http://img.blog.csdn.net/20170224224040931?watermark/2/text/aHR0cDo</a><br>vL2Jsb2cuY3Nkbi5uZXQvdG9fYmVfYmV0dGVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFC<br>MA==/dissolve/70/gravity/SouthEast)</p><p>玩家1完全由节点A控制，玩家3完全由节点B控制。而处在两个节点边缘的2号玩家，则同时由A和B提供服务。玩家2从A移动到B的过程中，会同时向A请求左边的情况，<br>并向B请求右边的情况。但是此时玩家2还是属于A管理。直到玩家2彻底离开AB边界很远，才彻底交由B管理。按照这样的逻辑将世界地图分割为一块一块的区域，交由不同<br>的 Node去管理。</p><p>对于一个 Node所负责的区域，地理上没必要连接在一起，比如大陆的四周边缘部分和高山部分的区块人比较少，可以统一交给一个Node去管理，而这些区块在地理上并<br>没有联系在一起的必要性。一个 Node到底管理哪些区块，可以根据游戏实时运行的负载情况，定时维护的时候进行更改 NodeMaster 上面的配置。</p><p>于是碰到第一个问题是很多 Node服务器需要和玩家进行通信，需要问管理服务器特定UID为多少的玩家到底在哪台 Gate上，以前按场景切割的服务器这个问题不大<br>，问了一次以后就可以缓存起来了，但是现在服务器种类增加不少，玩家又会飘来飘去，按UID查找玩家比较麻烦；另外一方面 GATE需要动态根据坐标计算和哪些<br>Node通信，导致逻辑越来越厚，于是把：“用户对象”从负责连接管理的 GATE中切割出来势在必行于是有了下面的模型：</p><p>![这里写图片描述](<a href="http://img.blog.csdn.net/20170224224117349?watermark/2/text/aHR0cDo">http://img.blog.csdn.net/20170224224117349?watermark/2/text/aHR0cDo</a><br>vL2Jsb2cuY3Nkbi5uZXQvdG9fYmVfYmV0dGVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFC<br>MA==/dissolve/70/gravity/SouthEast)</p><p>网关服务器再次退回到精简的网络转发功能，而用户逻辑则由按照 UID划分的 OBJ服务器来承担，GATE是按照网络接入时的负载来分布，而<br>OBJ则是按照资源的编号（UID）来分布，这样和一个用户通信直接根据 UID计算出 OBJ服务器编号发送数据即可。而新独立出来的<br>OBJ则提供了更多高层次的服务：</p><ul><li>对象移动：管理具体玩家在不同的 Node所管辖的区域之间的移动，并同需要的 Node进行沟通。</li><li>数据广播：Node可以给每个用户设置若干 TAG，然后通知 Object Master 按照TAG广播。</li><li>对象消息：通用消息推送，给某个用户发送数据，直接告诉 OBJ，不需要直接和 GATE打交道。</li><li>好友聊天：角色之间聊天直接走 OBJ/OBJ MASTER。</li></ul><p>整个服务器主体分为三层以后，NODE专注场景，OBJ专注玩家对象，GATE专注网络。这样的模型在无缝场景服务器中得到广泛的应用。但是随着时间的推移，负载问题<br>也越来越明显，做个活动，远来不活跃的区域变得十分活跃，靠每周维护来调整还是比较笨重的，于是有了动态负载均衡。</p><p>动态负载均衡有两种方法，第一种是按照负载，由 Node Master 定时动态移动修改一下各个 Node的边界，而不同的玩家对象按照先前的方法从一台<br>Node上迁移到另外一台 Node上：</p><p>![这里写图片描述](<a href="http://img.blog.csdn.net/20170224224237256?watermark/2/text/aHR0cDo">http://img.blog.csdn.net/20170224224237256?watermark/2/text/aHR0cDo</a><br>vL2Jsb2cuY3Nkbi5uZXQvdG9fYmVfYmV0dGVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFC<br>MA==/dissolve/70/gravity/SouthEast)</p><p>这样 Node Master定时查找地图上的热点区域，计算新的场景切割方式，然后告诉其他服务器开始调整，具体处理方式还是和上面对象跨越边界移动的方法一样。</p><p>但是上面这种方式实现相对复杂一些，于是人们设计出了更为简单直接的一种新方法：</p><p>![这里写图片描述](<a href="http://img.blog.csdn.net/20170224224324803?watermark/2/text/aHR0cDo">http://img.blog.csdn.net/20170224224324803?watermark/2/text/aHR0cDo</a><br>vL2Jsb2cuY3Nkbi5uZXQvdG9fYmVfYmV0dGVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFC<br>MA==/dissolve/70/gravity/SouthEast)</p><p>还是将地图按照标准尺寸均匀切割成静态的网格，每个格子由一个具体的Node负责，但是根据负载情况，能够实时的迁移到其他<br>Node上。在迁移分为三个阶段：准备，切换，完成。三个状态由Node Master负责维护。准备阶段新的 Node开始同步老<br>Node上面该网格的数据，完成后告诉NM；NM确认OK后同时通知新旧 Node完成切换。完成切换后，如果 Obj服务器还在和老的 Node进行通信，老的<br>Node将会对它进行纠正，得到纠正的 OBJ将修正自己的状态，和新的 Node进行通信。</p><p>很多无缝动态负载均衡的服务端宣称自己支持无限的人数，但不意味着 MMORPG游戏的人数上限真的可以无限扩充，因为这样的体系会受制于网络带宽和客户端性能。带宽<br>决定了同一个区域最大广播上限，而客户端性能决定了同一个屏幕到底可以绘制多少个角色。</p><p>从无缝地图引入了分布式对象模型开始，已经完全脱离 MUDOS体系，成为一种新的服务端模型。又由于动态负载均衡的引入，让无缝服务器如虎添翼，容纳着超过上一代游<br>戏服务器数倍的人数上限，并提供了更好的游戏体验，我们称其为第三代游戏服务端架构。网游以大型多人角色扮演为开端，RPG网游在相当长的时间里一度占据90%以上，<br>使得基于 MMORPG的服务端架构得到了蓬勃的发展，然而随着玩家对RPG的疲惫，各种非MMORPG游戏如雨后春笋般的出现在人们眼前，受到市场的欢迎。</p><h2 id="类型5：战网游戏服务器"><a href="#类型5：战网游戏服务器" class="headerlink" title="类型5：战网游戏服务器"></a>类型5：战网游戏服务器</h2><p>经典战网服务端和 RPG游戏有两个区别：RPG是分区分服的，北京区的用户和广州区的用户老死不相往来。而战网，虽然每局游戏一般都是<br>8人以内，但全国只有一套服务器，所有的玩家都可以在一起游戏，而玩家和玩家之使用 P2P的方式连接在一起，组成一局游戏：</p><p>![这里写图片描述](<a href="http://img.blog.csdn.net/20170224224448023?watermark/2/text/aHR0cDo">http://img.blog.csdn.net/20170224224448023?watermark/2/text/aHR0cDo</a><br>vL2Jsb2cuY3Nkbi5uZXQvdG9fYmVfYmV0dGVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFC<br>MA==/dissolve/70/gravity/SouthEast)</p><p>玩家通过 Match Making 服务器使用：创建、加入、自动匹配、邀请 等方式组成一局游戏。服务器会选择一个人做 Host，其他人<br>P2P连接到做主的玩家上来。STUN是帮助玩家之间建立 P2P的牵引服务器，而由于 P2P联通情况大概只有 75%，实在联不通的玩家会通过<br>Forward进行转发。</p><p>大量的连接对战，体育竞技游戏采用类似的结构。P2P有网状模型（所有玩家互相连接），和星状模型（所有玩家连接一个主玩家）。复杂的游戏状态在网状模型下难以形成一<br>致，因此星状P2P模型经受住了历史的考验。除去游戏数据，支持语音的战网系统也会将所有人的语音数据发送到做主的那个玩家机器上，通过混音去重再编码的方式返回给所<br>有用户。</p><p>战网类游戏，以竞技、体育、动作等类型的游戏为主，较慢节奏的 RPG（包括ARPG）有本质上的区别，而激烈的游戏过程必然带来到较<br>RPG复杂的多的同步策略，这样的同步机制往往带来的是很多游戏结果由客户端直接计算得出，那在到处都是破解的今天，如何保证游戏结果的公正呢？</p><p>主要方法就是投票法，所有客户端都会独立计算，然后传递给服务器。如果结果相同就更新记录，如果结果不一致，会采取类似投票的方式确定最终结果。同时记录本剧游戏的所<br>有输入，在可能的情况下，找另外闲散的游戏客户端验算整局游戏是否为该结果。并且记录经常有作弊嫌疑的用户，供运营人员封号时参考。</p><h2 id="类型7：休闲游戏服务器"><a href="#类型7：休闲游戏服务器" class="headerlink" title="类型7：休闲游戏服务器"></a>类型7：休闲游戏服务器</h2><p>休闲游戏同战网服务器类似，都是全区架构，不同的是有房间服务器，还有具体的游戏服务器，游戏主体不再以玩家 P2P进行，而是连接到专门的游戏服务器处理：</p><p>![这里写图片描述](<a href="http://img.blog.csdn.net/20170224224617523?watermark/2/text/aHR0cDo">http://img.blog.csdn.net/20170224224617523?watermark/2/text/aHR0cDo</a><br>vL2Jsb2cuY3Nkbi5uZXQvdG9fYmVfYmV0dGVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFC<br>MA==/dissolve/70/gravity/SouthEast)</p><p>和战网一样的全区架构，用户数据不能象分区的 RPG那样一次性load到内存，然后在内存里面直接修改。全区架构下，为了应对一个用户同时玩几个游戏，用户数据需要<br>区分基本数据和不同的游戏数据，而游戏数据又需要区分积分数据、和文档数据。胜平负之类的积分可以直接提交增量修改，而更为普遍的文档类数据则需要提供读写令牌，写令<br>牌只有一块，读令牌有很多块。同帐号同一个游戏同时在两台电脑上玩时，最先开始的那个游戏获得写令牌，可以操作任意的用户数据。而后开始的那个游戏除了可以提交胜平负<br>积分的增量改变外，对用户数据采用只读的方式，保证游戏能运行下去，但是会提示用户，游戏数据锁定。</p><h2 id="类型8：现代动作类网游"><a href="#类型8：现代动作类网游" class="headerlink" title="类型8：现代动作类网游"></a>类型8：现代动作类网游</h2><p>从早期的韩国动作游戏开始，传统的战网动作类游戏和 RPG游戏开始尝试融合。单纯的动作游戏玩家容易疲倦，留存也没有 RPG那么高；而单纯<br>RPG战斗却又慢节奏的乏味，无法满足很多玩家激烈对抗的期望，于是二者开始融合成为新一代的：动作 + 城镇<br>模式。玩家在城镇中聚集，然后以开副本的方式几个人出去以动作游戏的玩法来完成各种 RPG任务。本质就是一套<br>RPG服务端+副本服务端。由于每次副本时人物可以控制在8人以内，因此可以获得更为实时的游戏体验，让玩家玩的更加爽快。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>说了那么多的游戏服务器类型，其实也差不多了，剩下的类型大家拼凑一下其实也就是这个样子而已。游戏服务端经历了那么多结构上的变迁，内部开发模式是否依然不变？究竟<br>是继续延续传统的开发方式？还是有了更多突破性的方法？经历那么多次架构变迁，后面是否有共通的逻辑？未来的发展还会存在哪些困难？游戏服务端开发如何达到最终的彼岸<br>？</p><p>转自 <a href="https://www.zhihu.com/question/29779732/answer/45791817"> 知乎：端游、手游服务端常用的架构是什么样的？</a></p>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    <category term="大学时期CSDN" scheme="https://shiyi.threebody.xyz/categories/%E5%A4%A7%E5%AD%A6%E6%97%B6%E6%9C%9FCSDN/"/>
    
    
    <category term="游戏开发" scheme="https://shiyi.threebody.xyz/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>TCP协议-TCP服务特点和头部结构</title>
    <link href="https://shiyi.threebody.xyz/posts/11603.html"/>
    <id>https://shiyi.threebody.xyz/posts/11603.html</id>
    <published>2017-02-19T18:22:00.000Z</published>
    <updated>2022-12-08T15:35:14.149Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TCP服务特点"><a href="#TCP服务特点" class="headerlink" title="TCP服务特点"></a>TCP服务特点</h2><p>** 面向连接、基于字节流和可靠传输 ** 。</p><h3 id="TCP的面向连接是什么意思？"><a href="#TCP的面向连接是什么意思？" class="headerlink" title="TCP的面向连接是什么意思？"></a>TCP的面向连接是什么意思？</h3><p>通信双方都必须 ** 先建立连接 ** ，然后才能 ** 开始数据的读写 ** ，双方都必须为该连接分配必要的内核资源，以管理连接的状态和连接上数据的传输。<br>同时，TCP连接是全双工的，就是说， ** 双方数据的读写，可以通过一个连接进行，完成数据交换之后，通信双方都必须断开连接，以释放系统资源 **<br>。而且，TCP连接是一对一的，所以，基于广播和多播的应用程序不能使用TCP服务，而无连接协议UDP，倒非常适合广播和多播。</p><h3 id="字节流服务和通信报区别"><a href="#字节流服务和通信报区别" class="headerlink" title="字节流服务和通信报区别"></a>字节流服务和通信报区别</h3><p>主要体现在通信双方是否执行相同次数的读写操作。</p><p>![这里写图片描述](<a href="http://img.blog.csdn.net/20170220000621489?watermark/2/text/aHR0cDo">http://img.blog.csdn.net/20170220000621489?watermark/2/text/aHR0cDo</a><br>vL2Jsb2cuY3Nkbi5uZXQvdG9fYmVfYmV0dGVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFC<br>MA==/dissolve/70/gravity/SouthEast)</p><p>如图所示，当发送端应用程序同时执行多次写操作时，TCP模块必须先将这些数据放入发送缓冲区中，当TCP模块真正发送数据时，发送缓冲区中这些数据才会被封装成一个<br>或多个TCP报文段发出，简言之， ** TCP模块发出的报文段个数与发送端应用程序执行的写操作次数之间没有固定的数量关系 ** 。<br>同时，当接收端收到一个或多个TCP报文段后，TCP模块要将它们携带的应用数据根据的TCP报文段的序号依次放入接收缓冲区中，同时通知应用程序读取数据。接收端应<br>用程序可以将接收缓冲区中的数据一次读出，也可以多次读出，这取决于用户指定的应用程序读缓冲区大小，简言之， **<br>接收端应用程序执行的读操作次数与TCP模块接收到的TCP报文段个数也没有固定的数量关系。 **<br>总而言之就是， ** 发送端执行的写操作数量和接收端执行的读操作数量之间没有任何的数量关系 ** 。<br>通信双方数据传输是没有边界的，这也就是TCP的字节流的概念。<br>![这里写图片描述](<a href="http://img.blog.csdn.net/20170220000632880?watermark/2/text/aHR0cDo">http://img.blog.csdn.net/20170220000632880?watermark/2/text/aHR0cDo</a><br>vL2Jsb2cuY3Nkbi5uZXQvdG9fYmVfYmV0dGVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFC<br>MA==/dissolve/70/gravity/SouthEast)<br>而UDP的数据报截然相反，发送端应用程序每执行一次写操作，接收端应用程序都必须执行一次对应的读操作。否则，就会发生丢包。并且，如果用户没有指定足够的应用数据<br>缓冲区来读取数据报，那么UDP数据报就会发生截断。</p><h3 id="TCP的可靠传输是由何支撑的："><a href="#TCP的可靠传输是由何支撑的：" class="headerlink" title="TCP的可靠传输是由何支撑的："></a>TCP的可靠传输是由何支撑的：</h3><h4 id="发送应答机制"><a href="#发送应答机制" class="headerlink" title="** 发送应答机制 **"></a>** 发送应答机制 **</h4><p>发送端发送的每个TCP报文段都必须得到接收端的应答，才认为这个TCP报文段传输成功。</p><h4 id="超时重传机制"><a href="#超时重传机制" class="headerlink" title="** 超时重传机制 **"></a>** 超时重传机制 **</h4><p>发送端在发出一个TCP报文段之后，就开始定时，如果在定时时间内没有收到应答，就会重新发送这个报文段。<br>同时，TCP报文段最终是以IP数据报发送的，而IP数据报到达接收端时可能乱序、重复，TCP协议还会对接收到的TCP报文段重排、整理，再交付给应用程序。<br>而UDP数据报服务则不可靠，需要上层协议处理数据的确认和超时重传。</p><h2 id="TCP头部结构"><a href="#TCP头部结构" class="headerlink" title="TCP头部结构"></a>TCP头部结构</h2><p>通过了解TCP头部结构，我们可以认识到传输层在TCP协议栈中的作用。<br>TCP头部信息用于指定通信源端端口，目标端端口，管理连接等这些任务。如下图所示：<br>![这里写图片描述](<a href="http://img.blog.csdn.net/20170220000451567?watermark/2/text/aHR0cDo">http://img.blog.csdn.net/20170220000451567?watermark/2/text/aHR0cDo</a><br>vL2Jsb2cuY3Nkbi5uZXQvdG9fYmVfYmV0dGVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFC<br>MA==/dissolve/70/gravity/SouthEast)</p><h4 id="32位序号"><a href="#32位序号" class="headerlink" title="** 32位序号 **"></a>** 32位序号 **</h4><blockquote><p>在一次TCP通信，从连接建立到释放连接的整个过程中，在某一个传输方向上的字节流的每个字节的编号就是由这个32位序号确认的。<br>在两个主机通信时，第一次发送的TCP报文段中，32位序号为系统给出的随机值，我们称它为初始序号(ISN)，在该传输方向上，后续的TCP报文段中，序号，将被系<br>统设置为ISN+该报文段所携带数据的第一个字节在整个字节流中位置的偏移。<br>另外一个传输方向上，亦然。</p></blockquote><h4 id="32位确认号"><a href="#32位确认号" class="headerlink" title="** 32位确认号 **"></a>** 32位确认号 **</h4><blockquote><p>TCP报文段中，发送方不仅携带自己的数据序号，还携带对通信另一方所发送的数据的确认。</p></blockquote><h4 id="4位头部长度"><a href="#4位头部长度" class="headerlink" title="** 4位头部长度 **"></a>** 4位头部长度 **</h4><blockquote><p>标识该TCP头部有多少个4字节，最大值是15，所以TCP头部最大长度是60个字节。</p></blockquote><h4 id="6位标志字段"><a href="#6位标志字段" class="headerlink" title="** 6位标志字段 **"></a>** 6位标志字段 **</h4><ul><li>** URG ** ：紧急指针是否有效。</li><li>** ACK ** ：确认号是否有效（我们称携带ACK标志的TCP报文段为确认报文段）。</li><li>** PSH ** ：push字段，提示接收端程序应该立即从TCP接收缓冲区中读走数据，为接收后续数据腾出空间，因为应用程序如果不把这些数据读走，这些数据会一直停留在TCP接收缓冲区中，这样会占用很大的内核资源。</li><li>** RST ** ：要求对方重新建立连接（复位报文段）</li><li>** SYN ** ：表示请求建立一个连接（同步报文段）</li><li>** FIN ** ：通知对方关闭连接（结束报文段）</li><li>** 16位窗口大小 **</li></ul><blockquote><p>是TCP流量控制的手段。这里的窗口指接收通报窗口（Receiver<br>window），提示本端TCP接收缓冲区还能容纳多少字节数据，这样对方就可以控制数据发送的速度。</p></blockquote><ul><li>16位校验和</li></ul><blockquote><p>由发送端填充，接收端对TCP报文段执行CRC算法，来检验数据是否损坏。该检验不仅包括头部，也包括数据部分。</p></blockquote><ul><li>16位紧急指针</li></ul><blockquote><p>表示最后一个紧急数据的下一字节序号。</p></blockquote><p>![这里写图片描述](<a href="http://img.blog.csdn.net/20170220000541380?watermark/2/text/aHR0cDo">http://img.blog.csdn.net/20170220000541380?watermark/2/text/aHR0cDo</a><br>vL2Jsb2cuY3Nkbi5uZXQvdG9fYmVfYmV0dGVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFC<br>MA==/dissolve/70/gravity/SouthEast)</p><h4 id="40选项"><a href="#40选项" class="headerlink" title="40选项"></a>40选项</h4><p>kind类型 length总长度 info具体信息（常见TCP选项具体信息如下）</p><p>![这里写图片描述](<a href="http://img.blog.csdn.net/20170220022113004?watermark/2/text/aHR0cDo">http://img.blog.csdn.net/20170220022113004?watermark/2/text/aHR0cDo</a><br>vL2Jsb2cuY3Nkbi5uZXQvdG9fYmVfYmV0dGVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFC<br>MA==/dissolve/70/gravity/SouthEast)</p><blockquote><p>0： ** 选项表结束选项 **<br>1： ** 空操作选项 ** 。无特殊含义，一般用于将TCP选项的总长度填充为4字节的整数倍。<br>2： ** 最大报文段长度选项 ** 。连接初始化时，通信双方使用该选项来协商最大报文段长度。TCP模块通常将最大报文段长度设为MTU-40，这里的40指2<br>0字节的TCP头部和20字节的TCP头部，这样一来，携带TCP报文段的IP数据报的长度就不会超过MTU。<br>** ps：MTU即 _ 最大传输单元 _ ，该参数通常与通信接口有关（网络接口卡、串口等）。 **<br>3： ** 窗口扩大因子选项 ** 。TCP连接初始化时，通信双方使用该选项协商接收通道窗口扩大因子的大小。因为在TCP协议中，接收通道窗口的大小是用16位<br>表示的，也就是65535个字节，但实际上TCP模块允许的接收通道窗口远不止这个数目，比这个大是为了提高通信的吞吐量，窗口扩大因子就是为了解决这个问题。<br>如果窗口大小位N，而窗口扩大因子为M，那么窗口实际大小就是N*(2^M)。窗口扩大因子选项只能出现在同步报文段中，当连接建立成功之后，该值将固定不变。<br>4： ** 选择性确认(SACK)选项 ** 。当TCP报文段发生丢失时，TCP模块就会重传最后被确认的TCP报文段之后的所有报文段，但这样的话，原先已经成<br>功发送的报文段也可能重复发送，就降低了TCP模块的性能。选择定确认选项就是为了解决这个问题，它让TCP模块儿只重新发送丢失的TCP报文段。<br>5： ** SACK实际工作的选项 ** 。告诉发送端，本端已经收到的不连续的数据块，从而让发送端根据此选项重新发送丢失的数据块。其中块左边沿表示不连续块的<br>第一个数据的序号，而块右边沿则表示不连续块的最后一个数据的序号的下一个序号。这样一对参数（块左边沿和块右边沿）之间的数据是没有收到的。因为一个块信息占用8字<br>节，所以TCP头部选项中实际上最多可以包含4个这样的不连续数据块（考虑选项类型和长度占用的2字节）。<br>8： ** 时间戳选项 ** 。提供比较准确的计算通信双方之间的回路时间的方法。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    <category term="大学时期CSDN" scheme="https://shiyi.threebody.xyz/categories/%E5%A4%A7%E5%AD%A6%E6%97%B6%E6%9C%9FCSDN/"/>
    
    
    <category term="网络" scheme="https://shiyi.threebody.xyz/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Linux内存管理机制</title>
    <link href="https://shiyi.threebody.xyz/posts/23478.html"/>
    <id>https://shiyi.threebody.xyz/posts/23478.html</id>
    <published>2017-02-15T20:07:00.000Z</published>
    <updated>2022-12-08T15:35:14.149Z</updated>
    
    <content type="html"><![CDATA[<p>在Linux中经常发现空闲内存很少，似乎所有的内存都被系统占用了，表面感觉是内存不够用了，其实不然。这是Linux内存管理的一个优秀特性，主要特点是，无论物<br>理内存有多大，Linux 都将其充份利用，将一些程序调用过的硬盘数据读入内存（buffer/cache），利用内存读写的高速特性来提高Linux系统的数据访<br>问性能。在这方面，区别于Windows的内存管理。本文从Linux的内存管理机制入手，简单介绍linux如何使用内存、监控内存，linux与windows内<br>存管理上的区别简介，linux内存使用的一大特点（buffer/cache的异同）。</p><h2 id="一、Linux内存管理机制"><a href="#一、Linux内存管理机制" class="headerlink" title="一、Linux内存管理机制"></a>一、Linux内存管理机制</h2><h3 id="物理内存和虚拟内存"><a href="#物理内存和虚拟内存" class="headerlink" title="物理内存和虚拟内存"></a>物理内存和虚拟内存</h3><p>我们知道，直接从物理内存读写数据要比从硬盘读写数据要快的多，因此，我们希望所有数据的读取和写入都在内存完成，而内存是有限的，这样就引出了物理内存与虚拟内存的<br>概念。</p><p>物理内存就是系统硬件提供的内存大小，是真正的内存，相对于物理内存，在linux下还有一个虚拟内存的概念，虚拟内存就是为了满足物理内存的不足而提出的策略，它是<br>利用磁盘空间虚拟出的一块逻辑内存，用作虚拟内存的磁盘空间被称为交换空间（Swap Space）。</p><p>作为物理内存的扩展，linux会在物理内存不足（注意这一条件，这一条件的量化分析请参考 <a href="https://www.douban.com/note/349467816/"><br>https://www.douban.com/note/349467816/</a> ）时，使用交换分区的虚拟内存，更详细的说，就是内核会将暂时不用的内存块信<br>息写到交换空间，这样以来，物理内存得到了释放，这块内存就可以用于其它目的，当需要用到原始的内容时，这些信息会被重新从交换空间读入物理内存。</p><p>Linux的内存管理采取的是分页存取机制（详细可参考 <a href="http://www.linuxeye.com/Linux/1931.html"> http://www.linuxeye.com/Linux/1931.html</a> ），为了保证物<br>理内存能得到充分的利用，内核会在适当的时候将物理内存中不经常使用的数据块自动交换到虚拟内存中，而将经常使用的信息保留到物理内存。</p><p>要深入了解linux内存运行机制，需要知道下面提到的几个方面：Linux系统会根据系统配置不时地进行页面交换操作，以保持一定量的空闲物理内存，有些配置下即使<br>并没有什么事情需要内存，Linux也会交换出暂时不用的内存页面。这可以避免等待交换所需的时间。相关的配置有/etc/sysctl.conf中的vm.swap<br>piness配置（配制方法请参考 <a href="http://www.vcaptain.com/?id=17"> http://www.vcaptain.com/?id=17</a> ），该参数的作用简单描述就是“当 swappiness 内容的值为 0<br>时，表示最大限度地使用物理内存，物理内存使用完毕后，才会使用 swap 分区；当 swappiness 内容的值为 100 时，表示积极地使用 swap<br>分区，并且把内存中的数据及时地置换到 swap 分区。Linux 系统初始安装完成时，其默认值为 60, 这表示空闲物理内存少于 60%<br>时开始启用内存置换算法，将内存中不常使用的数据置换到 swap 分区。”（具体如何起作用请参考 <a href="https://www.douban.com/note/349467816/"><br>https://www.douban.com/note/349467816/</a> ）</p><p>Linux 进行页面交换是有条件的，不是所有页面在不用时都交换到虚拟内存，linux内核根据”最近最经常使用“算法，仅仅将一些不经常使用的页面文件交换到虚拟<br>内存，有时我们会看到这么一个现象：linux物理内存还有很多，但是交换空间也使用了很多。其实，这并不奇怪，例如：一个占用很大内存的进程运行时，需<br>要耗费很多内存资源，此时就会有一些不常用页面文件被交换到虚拟内存中，但后来这个占用很多内存资源的进程结束并释放了很多内存时，刚才被交换出去的页面<br>文件并不会自动的交换进物理内存，除非有这个必要，那么此刻系统物理内存就会空闲很多，同时交换空间也在被使用，就出现了刚才所说的现象了。关于这点，不<br>用担心什么，只要知道是怎么一回事就可以了。<br>交换空间的页面在使用时会首先被交换到物理内存，如果此时没有足够的物理内存来容纳这些页<br>面，它们又会被马上交换出去，如此以来，虚拟内存中可能没有足够空间来存储这些交换页面，最终会导致linux出现假死机、服务异常等问题，linux虽<br>然可以在一段时间内自行恢复，但是恢复后的系统已经基本不可用了。</p><p>分配太多的Swap空间会浪费磁盘空间，而Swap空间太少，则系统会发生错误。<br>如果系统的物理内存用光了，系统就会跑得很慢，但仍能运行；如果Swap空间用光了，那么系统就会发生错误。例如，Web服务器能根据不同的请求数量衍生<br>出多个服务进程（或线程），如果Swap空间用完，则服务进程无法启动，通常会出现“application is out of<br>memory”的错误，严重时会造成服务进程的死锁。因此Swap空间的分配是很重要的。</p><p>因此，合理规划和设计Linux内存的使用，是非常重要的。</p><h2 id="二、linux和windows内存管理的区别"><a href="#二、linux和windows内存管理的区别" class="headerlink" title="二、linux和windows内存管理的区别"></a>二、linux和windows内存管理的区别</h2><p>Linux 优先使用物理内存，当物理内存还有空闲时，linux是不会释放内存的，即时占用内存的程序已经被关闭了（这部分内存就用来做缓存了）。也就是说，即时你<br>有很大的内存,用过一段时间后，也会被占满。这样做的好处是，启动那些刚开启过的程序、或是读取刚存取过得数据会比较快，对于服务器很有好处。<br>windows则总是给内存留下一定的空闲空间，即时内存有空闲也会让程序使用一些虚拟内存，这样做的好处是，启动新的程序比较快，直接分给它些空闲<br>内存就可以了，而linux下呢？由于内存经常处于全部被使用的状态，则要先清理出一块内存，再分配给新的程序使用，因此，新程序的启动会慢一些。</p><h2 id="三、buffers与cached"><a href="#三、buffers与cached" class="headerlink" title="三、buffers与cached"></a>三、buffers与cached</h2><p>异同点</p><p>在Linux<br>操作系统中，当应用程序需要读取文件中的数据时，操作系统先分配一些内存，将数据从磁盘读入到这些内存中，然后再将数据分发给应用程序；当需要往文件中写<br>数据时，操作系统先分配内存接收用户数据，然后再将数据从内存写到磁盘上。然而，如果有大量数据需要从磁盘读取到内存或者由内存写入磁盘时，系统的读写性<br>能就变得非常低下，因为无论是从磁盘读数据，还是写数据到磁盘，都是一个很消耗时间和资源的过程，在这种情况下，Linux引入了buffers和<br>cached机制。</p><p>buffers与cached都是内存操作，用来保存系统曾经打开过的文件以及文件属性信息，这样当操作系统需要读取某些文件时，会首先在buffers<br>与cached内存区查找，如果找到，直接读出传送给应用程序，如果没有找到需要数据，才从磁盘读取，这就是操作系统的缓存机制，通过缓存，大大提高了操<br>作系统的性能。但buffers与cached缓冲的内容却是不同的。</p><p>buffers是用来缓冲块设备做的，它只记录文件系统的元数据（metadata）以及 tracking in-flight pages，而cached是用来<br>给文件做缓冲。更通俗一点说：buffers主要用来存放目录里面有什么内容，文件的属性以及权限等等。而cached直接用来记忆我们打开过的文件和程序。</p><p>内存释放</p><p>linux系统中/proc是一个虚拟文件系统，我们可以通过对它的读写操作做为与kernel实体间进行通信的一种手段。也就是说可以通过修改/proc中的文件，<br>来对当前kernel的行为做出调整。那么我们可以通过调整/proc/sys/vm/drop_caches来释放内存。</p><h2 id="四、Linux-进程在内存数据结构"><a href="#四、Linux-进程在内存数据结构" class="headerlink" title="四、Linux 进程在内存数据结构"></a>四、Linux 进程在内存数据结构</h2><p>可以看到一个可执行程序在存储（没有调入内存）时分为代码段，数据段，未初始化数据段三部分：</p><ul><li><p>代码段：存放CPU执行的机器指令。通常代码区是共享的，即其它执行程序可调用它。假如机器中有数个进程运行相同的一个程序，那么它们就可以使用同一个代码段。</p></li><li><p>数据段：存放已初始化的全局变量，静态变量（包括全局和局部的），常量。static全局变量和static函数只能在当前文件中被调用。</p></li><li><p>未初始化数据区（uninitializeddata segment,BSS)：存放全局未初始化的变量。BSS的数据在程序开始执行之前被初始化为0或NULL。<br>代码区所在的地址空间最低，往上依次是数据区和BSS区，并且数据区和BSS区在内存中是紧挨着的。。<br>可执行程序在运行时又多出了两个区域：栈段（Stack）和堆段(Heap)。</p></li><li><p>栈区:由编译器自动释放，存放函数的参数值，局部变量等。每当一个函数被调用时，该函数的返回类型和一些调用的信息被存储到栈中。然后这个被调用的函数再为它的自动变量和临时变量在栈上分配空间。每调用一个函数一个新的栈就会被使用。栈区是从高地址位向低地址位增长的，是一块连续的内在区域，最大容量是由系统预先定义好的，申请的栈空间超过这个界限时会提示溢出，用户能从栈中获取的空间较小。</p></li><li><p>堆段:用于存放进程运行中被动态分配的内存段，位于BSS和栈中间的地址位。由程序员申请分配（malloc)和释放（free）。堆是从低地址位向高地址位增长，采用链式存储结构。频繁地malloc/free造成内存空间的不连续，产生碎片。当申请堆空间时库函数按照一定的算法搜索可用的足够大的空间。因此堆的效率比栈要低的多。</p></li></ul><p>这个5中内存区域中数据段、BSS和堆通常是被连续存储的——内存位置上是连续的，而代码段和栈往往会被独立存放。有趣的是堆和栈两个区域关系很“暧昧”，他们一个向<br>下“长”（i386体系结构中栈向下、堆向上），一个向上“长”，相对而生。但你不必担心他们会碰头，因为他们之间间隔很大（到底大到多少，你可以从下面的例子程序计<br>算一下），绝少有机会能碰到一起。</p><p>下图简要描述了进程内存区域的分布：<br>![这里写图片描述](<a href="http://img.blog.csdn.net/20170216040311862?watermark/2/text/aHR0cDo">http://img.blog.csdn.net/20170216040311862?watermark/2/text/aHR0cDo</a><br>vL2Jsb2cuY3Nkbi5uZXQvdG9fYmVfYmV0dGVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFC<br>MA==/dissolve/70/gravity/SouthEast)</p><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>Linux操作系统的内存运行原理，很大程度上是根据服务器的需求来设计的，例如系统的缓冲机制会把经常使用到的文件和数据缓存在cached<br>中，linux总是在力求缓存更多的数据和信息，这样再次需要这些数据时可以直接从内存中取，而不需要有一个漫长的磁盘操作，这种设计思路提高了系统的整 体性能。</p>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    <category term="大学时期CSDN" scheme="https://shiyi.threebody.xyz/categories/%E5%A4%A7%E5%AD%A6%E6%97%B6%E6%9C%9FCSDN/"/>
    
    
    <category term="Linux网络编程" scheme="https://shiyi.threebody.xyz/tags/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    <category term="Linux系统编程" scheme="https://shiyi.threebody.xyz/tags/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>TCP建立连接为什么是三次握手，为什么不是两次或四次?</title>
    <link href="https://shiyi.threebody.xyz/posts/60892.html"/>
    <id>https://shiyi.threebody.xyz/posts/60892.html</id>
    <published>2017-02-09T08:33:00.000Z</published>
    <updated>2022-12-08T15:35:14.149Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是三次握手"><a href="#什么是三次握手" class="headerlink" title="什么是三次握手"></a>什么是三次握手</h3><p>学过网络编程的人，应该都知道TCP建立连接的三次握手，下面简单描述一下这个过程。<br>![这里写图片描述](<a href="http://img.blog.csdn.net/20170209153734959?watermark/2/text/aHR0cDo">http://img.blog.csdn.net/20170209153734959?watermark/2/text/aHR0cDo</a><br>vL2Jsb2cuY3Nkbi5uZXQvdG9fYmVfYmV0dGVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFC<br>MA==/dissolve/70/gravity/SouthEast)</p><blockquote><p>** 如图所示 **<br>** 第一次握手 ** ：客户端发送TCP包，置SYN标志位为1，将初始序号X，保存在包头的序列号(Seq)里。<br>** 第二次握手 ** ：服务端回应确认包，置SYN标志位为1，置ACK为X+1，将初始序列号Y，保存在包头的序列号里。<br>** 第三次握手 ** ：客户端对服务端的确认包进行确认，置SYN标志位为0，置ACK为Y+1，置序列号为Z。</p></blockquote><h3 id="为什么不是两次"><a href="#为什么不是两次" class="headerlink" title="为什么不是两次"></a>为什么不是两次</h3><p>我们先来将三次握手这个过程捋一遍。(S-服务端，C-客户端)</p><blockquote><p>第一次握手后，S可以确认自己收报文与C发报文的功能都正常，而C呢，它什么都不能确认。<br>第二次握手后，C可以确认自己的收发报文与S的收发报文功能都正常，也就是认为连接已建立。<br>那么第三次呢，S也可以确认双方能够正常通信。</p></blockquote><p>假想一下，如果我们去掉了第三次呢？<br>因为我们不进行第三次握手，所以在S对C的请求进行回应(第二次握手)后，就会理所当然的认为连接已建立，而如果C并没有收到S的回应呢？此时，C仍认为连接未建立，<br>S会对已建立的连接保存必要的资源，如果大量的这种情况，S会崩溃。<br>** 因此第三次握手是必要的。 **</p><h3 id="为什么不是四次"><a href="#为什么不是四次" class="headerlink" title="为什么不是四次"></a>为什么不是四次</h3><p>首先，如果乐于思考的同学应该会对上面有这样的疑问：</p><pre><code class="hljs">既然没法确认第二次的握手，C是否可以收到，那么怎么确定第三次握手S就可以收到呢？</code></pre><p>不错，这根本没法确定，因为完全可靠的通信协议是根本不存在的，我们任何的通信协议都是在接受这样的现实情况之上进行的。<br>而三次握手后，C和S至少可以确认之前的通信情况，但无法确认之后的情况。<br>在这个道理上说，无论是四次还是五次或是更多次都是徒劳的。</p>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    <category term="大学时期CSDN" scheme="https://shiyi.threebody.xyz/categories/%E5%A4%A7%E5%AD%A6%E6%97%B6%E6%9C%9FCSDN/"/>
    
    
    <category term="网络" scheme="https://shiyi.threebody.xyz/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>三步实现自动注册工厂替代switch语句(c++)</title>
    <link href="https://shiyi.threebody.xyz/posts/34435.html"/>
    <id>https://shiyi.threebody.xyz/posts/34435.html</id>
    <published>2017-01-01T14:05:00.000Z</published>
    <updated>2022-12-08T15:35:14.153Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>在学长博客里看到了使用自动注册工厂替代switch语句的文章，想到可以将其用到自己的项目里，就照猫画虎学习着也实现了一个。<br>这里并不是用其替代创建派生类的传统Factory，而是为了替代服务器中的业务逻辑处理。<br>记得以前实现的第一个服务器项目：聊天室，里面在解包后，是一长串的switch语句，根据包里类型标志，来决定该如何处理，写起来舒服，可看起来，包括后期维护，实<br>在是太不方便，因为想使用自动注册工厂这种模式来解决这个问题。</p><pre><code class="hljs">我这里的自动注册工厂是针对服务器项目收到包之后进行逻辑处理的语句冗余问题。但思路与代码基本适用于绝大多数需要使用自动注册工厂的情况。</code></pre><h3 id="以前的方式"><a href="#以前的方式" class="headerlink" title="以前的方式"></a>以前的方式</h3><pre><code class="hljs">switch(type)&#123;    case 1:        do_login();    case 2:        do_register();    case 3:        do_something();    case ...    ........&#125;</code></pre><p>显然，在业务逻辑并不多的时候，这样的方式也无伤大雅，那么假设业务逻辑很多呢，switch语句该有多长，无论是维护还是阅读都很不便。<br>那么，我们来看下一种方式。</p><h3 id="自动注册工厂"><a href="#自动注册工厂" class="headerlink" title="自动注册工厂"></a>自动注册工厂</h3><h4 id="逻辑处理基类"><a href="#逻辑处理基类" class="headerlink" title="逻辑处理基类"></a>逻辑处理基类</h4><p>这里只简单的实现了基本的构造函数，和逻辑处理函数</p><pre><code class="hljs">class action&#123;public:    action()    &#123;        std::cout&lt;&lt;&quot;action&quot;&lt;&lt;std::endl;    &#125;    virtual void doAction()    &#123;        std::cout&lt;&lt;&quot;doAction&quot;&lt;&lt;std::endl;    &#125;&#125;;</code></pre><h4 id="登陆逻辑处理派生类"><a href="#登陆逻辑处理派生类" class="headerlink" title="登陆逻辑处理派生类"></a>登陆逻辑处理派生类</h4><pre><code class="hljs">class login_action : public action &#123;public:    login_action()    &#123;        std::cout&lt;&lt;&quot;login_action&quot;&lt;&lt;std::endl;    &#125;    void doAction()    &#123;        std::cout&lt;&lt;&quot;do_login_action&quot;&lt;&lt;std::endl;    &#125;&#125;;REGISTER_ACTION(login_action, &quot;login_action&quot;);</code></pre><h4 id="注册逻辑处理派生类"><a href="#注册逻辑处理派生类" class="headerlink" title="注册逻辑处理派生类"></a>注册逻辑处理派生类</h4><pre><code class="hljs">class register_action : public action&#123;public:    register_action()    &#123;        std::cout&lt;&lt;&quot;register_action&quot;&lt;&lt;std::endl;    &#125;    void doAction()    &#123;        std::cout&lt;&lt;&quot;do_register_action&quot;&lt;&lt;std::endl;    &#125;&#125;;REGISTER_ACTION(register_action, &quot;register_action&quot;);</code></pre><h4 id="工厂类"><a href="#工厂类" class="headerlink" title="工厂类"></a>工厂类</h4><p>这个类是我们自动注册工厂的核心类。</p><h5 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h5><p>首先，我们要将其设计为单例模式，为了规范，我们将其拷贝构造函数和移动构造函数都设置为私有的，令其不可拷贝与构造，类似于boost::noncopyable。<br>并定义一个私有变量，为map类型，键为string，值为可返回一个派生类对象的function。<br>如下:</p><pre><code class="hljs">&#123;public:private:    factory() = default;    factory(const factory&amp;) = delete;    factory(factory&amp;&amp;) = delete;    static factory &amp;get()    &#123;        static factory instance;        return instance;    &#125;    std::map&lt;std::string, std::function&lt;action*(void)&gt;&gt; m_map;&#125;;</code></pre><h5 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h5><p>在factory内实现一个内部类Register，便于扩展，我将其设置为了模板类型。<br>为什么要设置为内部类呢，因为设置为内部类我们就可以使用外部类的私有成员(我们为规范，将map设置为私有的)，同时也因为其与工厂类本身就是一体，写在一起也更合<br>逻辑。<br>构造函数：传入一个标志key，将其作为键写入map，值为一个lambda表达式，返回一个派生类对象指针。</p><pre><code class="hljs">    template &lt;typename F&gt;    struct Register    &#123;        Register(const std::string&amp; key)        &#123;            factory::get().m_map.emplace(key, []&#123;                return new F();            &#125;);        &#125;        template&lt;typename... Args&gt;        Register(const std::string&amp; key, Args... args)        &#123;            factory::get().m_map.emplace(key, [&amp;]&#123;                return new F(args...);            &#125;);        &#125;    &#125;;注：emplace操作是C++11新特性，新引入的的三个成员emlace_front、empace 和 emplace_back,这些操作构造而不是拷贝元素到容器中，这些操作分别对应push_front、insert 和push_back，允许我们将元素放在容器头部、一个指定的位置和容器尾部。(目的是减少一次拷贝)</code></pre><h5 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h5><p>使用宏来简化工厂注册步骤</p><pre><code class="hljs">#define REGISTER_ACTION_NAME(T) msg_name_##T##_#define REGISTER_ACTION(T, key, ...) \static factory::Register&lt;T&gt; REGISTER_ACTION_NAME(T)(key,##__VA_ARGS__)注:##起将左右字符衔接的作用   __VA_ARGS__ 是一个可变参数的宏，很少人知道这个宏，这个可变参数的宏是新的C99规范中新增的。   宏前面加上##的作用在于，当可变参数的个数为0时，这里的##起到把前面多余的&quot;,&quot;去掉的作用</code></pre><h4 id="工厂类完整代码"><a href="#工厂类完整代码" class="headerlink" title="工厂类完整代码"></a>工厂类完整代码</h4><pre><code class="hljs">class factory&#123;public:    template &lt;typename F&gt;    struct Register    &#123;        Register(const std::string&amp; key)        &#123;            factory::get().m_map.emplace(key, []&#123;                return new F();            &#125;);        &#125;        template&lt;typename... Args&gt;        Register(const std::string&amp; key, Args... args)        &#123;            factory::get().m_map.emplace(key, [&amp;]&#123;                return new F(args...);            &#125;);        &#125;    &#125;;    static action* produce(const std::string&amp; key)    &#123;        auto map = factory::get().m_map;        if(map.find(key) == map.end())        &#123;            throw std::invalid_argument(&quot;error&quot;);        &#125;        return map[key]();    &#125;private:    factory() = default;    factory(const factory&amp;) = delete;    factory(factory&amp;&amp;) = delete;    static factory &amp;get()    &#123;        static factory instance;        return instance;    &#125;    std::map&lt;std::string, std::function&lt;action*(void)&gt;&gt; m_map;&#125;;#define REGISTER_ACTION_NAME(T) msg_name_##T##_#define REGISTER_ACTION(T, key, ...) \static factory::Register&lt;T&gt; REGISTER_ACTION_NAME(T)(key,##__VA_ARGS__)</code></pre><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><pre><code class="hljs">int main()&#123;    action *login = factory::produce(&quot;login_action&quot;);    action *rter = factory::produce(&quot;register_action&quot;);    login-&gt;doAction();    rter-&gt;doAction();    delete(login);    delete(rter);&#125;</code></pre><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>![这里写图片描述](<a href="http://img.blog.csdn.net/20170101220315638?watermark/2/text/aHR0cDo">http://img.blog.csdn.net/20170101220315638?watermark/2/text/aHR0cDo</a><br>vL2Jsb2cuY3Nkbi5uZXQvdG9fYmVfYmV0dGVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFC<br>MA==/dissolve/70/gravity/SouthEast)</p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>我们在学习中可能业务逻辑并不会太多，也就是说，switch语句并不会影响什么，但我们应当在一开始时就养成这么一个好的习惯，用最好的方式去实现自己想要的功能。</p>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    <category term="大学时期CSDN" scheme="https://shiyi.threebody.xyz/categories/%E5%A4%A7%E5%AD%A6%E6%97%B6%E6%9C%9FCSDN/"/>
    
    
    <category term="C++" scheme="https://shiyi.threebody.xyz/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>clion配置cmake添加boost库</title>
    <link href="https://shiyi.threebody.xyz/posts/22771.html"/>
    <id>https://shiyi.threebody.xyz/posts/22771.html</id>
    <published>2017-01-01T09:36:00.000Z</published>
    <updated>2022-12-08T15:35:14.153Z</updated>
    
    <content type="html"><![CDATA[<p>今天发现xcode在文件名修改之后，该文件内补全就失效，网上寻法多次无果，无奈转向clion。<br>因为clion的项目构建是基于cmake的，想使用boost等第三方库就需要对其进行配置，故将配置内容保存于此。</p><pre><code class="hljs">cmake_minimum_required(VERSION 3.6)#设置项目名称project(demo)set(CMAKE_CXX_STANDARD 11)set(BOOST_ROOT &quot;/usr/local/include/boost&quot;)#添加头文件搜索路径include_directories(/usr/local/include)#添加库文件搜索路径link_directories(/usr/local/lib)#用于将当前目录下的所有源文件的名字保存在变量 DIR_SRCS 中aux_source_directory(. DIR_SRCS)add_executable(demo $&#123;DIR_SRCS&#125;)#在这里根据名字boost_thread去寻找libboost_thread.a文件target_link_libraries(demo boost_thread boost_system)</code></pre>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    <category term="大学时期CSDN" scheme="https://shiyi.threebody.xyz/categories/%E5%A4%A7%E5%AD%A6%E6%97%B6%E6%9C%9FCSDN/"/>
    
    
    <category term="C++" scheme="https://shiyi.threebody.xyz/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Boost.Asio网络库之io_service分析</title>
    <link href="https://shiyi.threebody.xyz/posts/888.html"/>
    <id>https://shiyi.threebody.xyz/posts/888.html</id>
    <published>2016-12-23T18:44:00.000Z</published>
    <updated>2022-12-08T15:35:14.145Z</updated>
    
    <content type="html"><![CDATA[<h3 id="io-service概述"><a href="#io-service概述" class="headerlink" title="io_service概述"></a>io_service概述</h3><p>几乎绝大多数用到Boost.Asio的代码里都会出现这样一个类： ** io_service **<br>。它应该算是Asio库里的核心类了，其本质是一个任务队列，但又不仅仅是个任务队列。</p><h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><p>io_service是个接口类(ps:这里解释一下，这里说接口类并不是指类似java的interface类，而是指其是对下层类做了一个包装，全部功能都是调用<br>下层类来完成)。</p><pre><code class="hljs">class io_service : private noncopyable&#123;private:     typedef detail::io_service_impl impl_type;    ...&#125;</code></pre><p>上述代码中的impl_type即是我们所说的下层类，io_service的所有操作都是由它代为执行的。<br>这么说，为了实现跨平台，我们在io_service提供统一的操作接口，而不管平台的差异，impl_type的实现上分为两部分，</p><pre><code class="hljs">window系平台：win_iocp_io_service非window系平台：task_io_service</code></pre><p>使用宏定义根据平台来决定将哪个类作为具体执行类，见源码</p><pre><code class="hljs">#if defined(BOOST_ASIO_HAS_IOCP)    typedef class win_iocp_io_service io_service_impl;    class win_iocp_overlapped_ptr;#else    typedef class task_io_service io_service_impl;#endif</code></pre><p>代码一目了然，不做赘述。<br>之前也学习过跨平台游戏引擎cocos2dx的部分源码，发现跨平台的开源库几乎都是类似的思想，用宏定义做到根据平台不同使用不同类来执行功能，在此之上提供接口，<br>屏蔽平台差异。<br>我们这里只讨论task_io_service对应的功能。</p><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>上面我们说过，io_service类的本质是一个任务队列，所谓任务队列，其实就是一个队列容器而已，其内部元素为void型的函数，我们将这些函数抽象看待为任务<br>。(ps:既然是任务队列的模式，就当然会有锁的存在，而这个锁也被许多asio的使用者看做是眼中钉肉中刺，)<br>io_service提供了不少方法，在这里我们具体讨论最常用也是最核心的三个方法</p><h3 id="run，run-one"><a href="#run，run-one" class="headerlink" title="run，run_one"></a>run，run_one</h3><p>run函数的功能是：执行队列的所有任务直到全部完成。<br>它应该是使用的最多的一个函数，因为当我们使用io_service注册异步事件后，需要执行run函数阻塞执行任务，否则程序可能会在任务未完成时就结束。<br>我们来看看其源码</p><pre><code class="hljs">std::size_t task_io_service::run(boost::system::error_code&amp; ec)&#123;    ec = boost::system::error_code();    if (outstanding_work_ == 0)    &#123;        stop();        return 0;    &#125;    thread_info this_thread;    this_thread.private_outstanding_work = 0;    thread_call_stack::context ctx(this, this_thread);    mutex::scoped_lock lock(mutex_);    std::size_t n = 0;    for (; do_run_one(lock, this_thread, ec); lock.lock())        if (n != (std::numeric_limits&lt;std::size_t&gt;::max)())            ++n;    return n;&#125;</code></pre><p>outstanding_work_是一个原子变量，通过对它的值的修改来控制run函数是否直接结束。</p><p>run_one由名字就可想而知了，它只执行任务队列里的一个任务。<br>在执行任务时，如果有空闲线程，直接使用该线程去执行任务(领导者追随者模式)，如果没有且监听事件的线程正在运行，则将阻塞时间变为0，即边监听边执行，待任务执行<br>完毕在阻塞在epoll_wait上。当任务执行完后，再将监听模式改为阻塞。</p><h3 id="poll，poll-one"><a href="#poll，poll-one" class="headerlink" title="poll，poll_one"></a>poll，poll_one</h3><p>这两组函数和run/run_one函数的功能完全一样，只是run/run_one函数执行是阻塞的，而poll函数是非阻塞的，所以在 **<br>使用poll函数时要特别注意变量或对象的生命周期 ** 。</p><h4 id="post"><a href="#post" class="headerlink" title="post"></a>post</h4><h4 id="stop"><a href="#stop" class="headerlink" title="stop"></a>stop</h4><p>退出，停止工作</p><h3 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h3>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    <category term="大学时期CSDN" scheme="https://shiyi.threebody.xyz/categories/%E5%A4%A7%E5%AD%A6%E6%97%B6%E6%9C%9FCSDN/"/>
    
    
    <category term="服务器开发" scheme="https://shiyi.threebody.xyz/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/"/>
    
    <category term="C++" scheme="https://shiyi.threebody.xyz/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>IDEA tomcat三步实现热部署</title>
    <link href="https://shiyi.threebody.xyz/posts/446.html"/>
    <id>https://shiyi.threebody.xyz/posts/446.html</id>
    <published>2016-12-17T18:19:00.000Z</published>
    <updated>2022-12-08T15:35:14.149Z</updated>
    
    <content type="html"><![CDATA[<h3 id="添加Artifacts选项"><a href="#添加Artifacts选项" class="headerlink" title="添加Artifacts选项"></a>添加Artifacts选项</h3><p>![这里写图片描述](<a href="http://img.blog.csdn.net/20161218015953248?watermark/2/text/aHR0cDo">http://img.blog.csdn.net/20161218015953248?watermark/2/text/aHR0cDo</a><br>vL2Jsb2cuY3Nkbi5uZXQvdG9fYmVfYmV0dGVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFC<br>MA==/dissolve/70/gravity/SouthEast)<br>添加Artifacts选项，XXXwar 和 XXXwar exploded二选一，若要热部署须选后者。</p><h3 id="设置tomcat部署方案"><a href="#设置tomcat部署方案" class="headerlink" title="设置tomcat部署方案"></a>设置tomcat部署方案</h3><p>![这里写图片描述](<a href="http://img.blog.csdn.net/20161218020604209?watermark/2/text/aHR0cDo">http://img.blog.csdn.net/20161218020604209?watermark/2/text/aHR0cDo</a><br>vL2Jsb2cuY3Nkbi5uZXQvdG9fYmVfYmV0dGVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFC<br>MA==/dissolve/70/gravity/SouthEast)</p><h3 id="设置tomcat服务选项"><a href="#设置tomcat服务选项" class="headerlink" title="设置tomcat服务选项"></a>设置tomcat服务选项</h3><p>![这里写图片描述](<a href="http://img.blog.csdn.net/20161218015626508?watermark/2/text/aHR0cDo">http://img.blog.csdn.net/20161218015626508?watermark/2/text/aHR0cDo</a><br>vL2Jsb2cuY3Nkbi5uZXQvdG9fYmVfYmV0dGVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFC<br>MA==/dissolve/70/gravity/SouthEast)</p><ol><li>On ‘Update’ action设置每次默认Run选项为Redeploy重新部署（相比重新启动要快一些了，但速度还是不太理想）</li></ol><p>On frame deactivation设置为Updata classes and<br>resources（每次切换桌面&lt;比如切换到浏览器&gt;都会更新类和资源），这样我们在更改jsp文件后，只需切换到浏览器，自动就会进行更新了，感觉很爽</p><ol start="2"><li>添加build选项</li></ol><h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><p>上面本人已通过对springMVC控制层进行更改及jsp更改尝试，亲测可行，至于spring的配置更改等等是否有效，还没有尝试，不敢妄言。</p>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    <category term="大学时期CSDN" scheme="https://shiyi.threebody.xyz/categories/%E5%A4%A7%E5%AD%A6%E6%97%B6%E6%9C%9FCSDN/"/>
    
    
    <category term="Web开发" scheme="https://shiyi.threebody.xyz/tags/Web%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC基于注解进行URL映射</title>
    <link href="https://shiyi.threebody.xyz/posts/29527.html"/>
    <id>https://shiyi.threebody.xyz/posts/29527.html</id>
    <published>2016-12-14T19:23:00.000Z</published>
    <updated>2022-12-08T15:35:14.149Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>![这里写图片描述](<a href="http://img.blog.csdn.net/20161215024919504?watermark/2/text/aHR0cDo">http://img.blog.csdn.net/20161215024919504?watermark/2/text/aHR0cDo</a><br>vL2Jsb2cuY3Nkbi5uZXQvdG9fYmVfYmV0dGVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFC<br>MA==/dissolve/70/gravity/SouthEast)<br>自己之前写了好几个web程序，都遵从这样的方式：地址栏输入的url，后台一定存在对应的servlet。<br>然而某天看着自己博客地址，链接由域名和自己用户名(如上图所示)，就忍不住开始想了，csdn那么多用户，总不可能有那么多servlet吧。<br>一定是进行了某种映射，于是去查了些资料，知道了如何去实现这样的效果。</p><h3 id="使用url映射的好处"><a href="#使用url映射的好处" class="headerlink" title="使用url映射的好处"></a>使用url映射的好处</h3><p>先说说好处，知道好处才有力气用。<br>1、缩短url，隐藏实际路径提高安全性 。<br>2、易于用户记忆和键入。<br>3、易于被搜索引擎收录。<br>4、保证用户的书签保存以及友情链接长期有效。(因为外现的url并不存在，实际更新维护时不会对虚拟url产生影响)</p><p>第一：易扩展，如上面说的用户名作为url的一部分，既方便用户记忆，代码结构也更直观<br>第二：便于搜索引擎对链接</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>步入主题，我们来看看SpringMVC怎样进行URL映射</p><h4 id="普通映射"><a href="#普通映射" class="headerlink" title="普通映射"></a>普通映射</h4><pre><code class="hljs">@RequestMapping(value = &quot;abcde&quot;)public String shi()&#123;    return &quot;&quot;;&#125;</code></pre><h4 id="多个url映射"><a href="#多个url映射" class="headerlink" title="多个url映射"></a>多个url映射</h4><pre><code class="hljs">@RequestMapping(value = &#123;&quot;abcde&quot;, &quot;fgh&quot;&#125;)public String shi()&#123;    return &quot;&quot;;&#125;</code></pre><h4 id="获取路径变量的url映射"><a href="#获取路径变量的url映射" class="headerlink" title="获取路径变量的url映射"></a>获取路径变量的url映射</h4><pre><code class="hljs">@RequestMapping(value = &quot;/&#123;name&#125;&quot;)    @ResponseBody    public Map shi(@PathVariable String name)    &#123;        HashMap s = new HashMap();        s.put(&quot;aaa&quot;, name);        return yi(name);    &#125;</code></pre><h4 id="基于通配风格的url映射"><a href="#基于通配风格的url映射" class="headerlink" title="基于通配风格的url映射"></a>基于通配风格的url映射</h4><h4 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h4><p>? 表示匹配一个字符，不能为空<br>比如@RequestMapping(value = “/a?”)</p><pre><code class="hljs">匹配：localhost:8080/aalocalhost:8080/ab  等等</code></pre><ul><li>表示匹配任意个字符但不能跨/</li></ul><p>比如@RequestMapping(value = “/a*”)</p><pre><code class="hljs">匹配：localhost:8080/aalocalhost:8080/abclocalhost:8080/acdelocalhost:8080/acde/  等等不能匹配localhost::8080/acde/s</code></pre><p>** 表示匹配任意个字符并且无/的限制</p><p>比如@RequestMapping(value = “/a/**”)</p><pre><code class="hljs">匹配：localhost:8080/aalocalhost:8080/abclocalhost:8080/acde/saflocalhost:8080/acde/saf/asf  等等</code></pre>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    <category term="大学时期CSDN" scheme="https://shiyi.threebody.xyz/categories/%E5%A4%A7%E5%AD%A6%E6%97%B6%E6%9C%9FCSDN/"/>
    
    
    <category term="Web开发" scheme="https://shiyi.threebody.xyz/tags/Web%E5%BC%80%E5%8F%91/"/>
    
    <category term="Java" scheme="https://shiyi.threebody.xyz/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC返回json数据(@ResponseBody注解的使用)</title>
    <link href="https://shiyi.threebody.xyz/posts/30797.html"/>
    <id>https://shiyi.threebody.xyz/posts/30797.html</id>
    <published>2016-12-14T18:22:00.000Z</published>
    <updated>2022-12-08T15:35:14.149Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近开始了一个web项目，深深感觉到web方面知识的混杂，越来越明白java为什么可以流行这么多年了，库啊，框架啊，一抓一大把，要多方便有多方便，开发效<br>率提升太高了。</p></blockquote><p>最初使用SpringMVC时，为其ModelAndView可以直接返回页面和数据感觉爽到不行，但是当只想返回数据而不返回页面时，该怎么办呢，难道还要每次自己<br>进行json格式转化吗，太麻烦了。</p><p>用ModelAndView显然不行，因为其必须要附带视图页面，如果没有，则会报下面错误。<br>![这里写图片描述](<a href="http://img.blog.csdn.net/20161215022056123?watermark/2/text/aHR0cDo">http://img.blog.csdn.net/20161215022056123?watermark/2/text/aHR0cDo</a><br>vL2Jsb2cuY3Nkbi5uZXQvdG9fYmVfYmV0dGVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFC<br>MA==/dissolve/70/gravity/SouthEast)</p><p>怎么办呢，我们可以使用@ResponseBody注解，方便的返回json数据<br>它会将内容或对象进行合适的格式转换作为 HTTP 响应正文返回</p><p>具体使用方法如下：</p><h3 id="库依赖"><a href="#库依赖" class="headerlink" title="库依赖"></a>库依赖</h3><pre><code class="hljs">&lt;!-- json --&gt;        &lt;dependency&gt;          &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;            &lt;artifactId&gt;jackson-core&lt;/artifactId&gt;            &lt;version&gt;$&#123;jackson.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;            &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;            &lt;version&gt;$&#123;jackson.version&#125;&lt;/version&gt;        &lt;/dependency&gt;</code></pre><h3 id="xml配置"><a href="#xml配置" class="headerlink" title="xml配置"></a>xml配置</h3><p>启动注解<br><code>&lt;mvc:annotation-driven/&gt;</code></p><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><p>controller</p><pre><code class="hljs">@RequestMapping(&quot;c&quot;)    @ResponseBody    public String d()    &#123;        HashMap s = new HashMap();        s.put(&quot;aaa&quot;, &quot;你好啊&quot;);        return s;    &#125;</code></pre><h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p>![这里写图片描述](<a href="http://img.blog.csdn.net/20161215022007607?watermark/2/text/aHR0cDo">http://img.blog.csdn.net/20161215022007607?watermark/2/text/aHR0cDo</a><br>vL2Jsb2cuY3Nkbi5uZXQvdG9fYmVfYmV0dGVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFC<br>MA==/dissolve/70/gravity/SouthEast)</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>如果返回的对象里的属性必须拥有get方法，因为要进行数据转化直接返回string时，不会进行json格式的转化</p>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    <category term="大学时期CSDN" scheme="https://shiyi.threebody.xyz/categories/%E5%A4%A7%E5%AD%A6%E6%97%B6%E6%9C%9FCSDN/"/>
    
    
    <category term="Web开发" scheme="https://shiyi.threebody.xyz/tags/Web%E5%BC%80%E5%8F%91/"/>
    
    <category term="Java" scheme="https://shiyi.threebody.xyz/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>boost:asio信号量signal_set源码分析及使用</title>
    <link href="https://shiyi.threebody.xyz/posts/10773.html"/>
    <id>https://shiyi.threebody.xyz/posts/10773.html</id>
    <published>2016-12-11T10:02:00.000Z</published>
    <updated>2022-12-08T15:35:14.153Z</updated>
    
    <content type="html"><![CDATA[<p>首先我们先看signal_set.hpp，可以看到下面代码</p><pre><code class="hljs">#include &lt;boost/asio/detail/config.hpp&gt;#include &lt;boost/asio/basic_signal_set.hpp&gt;namespace boost &#123;namespace asio &#123;/// Typedef for the typical usage of a signal set.typedef basic_signal_set&lt;&gt; signal_set;&#125; // namespace asio&#125; // namespace boost</code></pre><p>显然，我们使用的signal_set实际上是一个基础模板类basic_signal_set&lt;&gt;<br>再次跳转basic_signal_set.hpp</p><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><pre><code class="hljs">    explicit basic_signal_set(boost::asio::io_service&amp; io_service) : basic_io_object&lt;SignalSetService&gt;(io_service)    basic_signal_set(boost::asio::io_service&amp; io_service, int signal_number_1)    basic_signal_set(boost::asio::io_service&amp; io_service, int signal_number_1, int signal_number_2)    basic_signal_set(boost::asio::io_service&amp; io_service, int signal_number_1, int signal_number_2, int signal_number_3) : basic_io_object&lt;SignalSetService&gt;(io_service)</code></pre><p>显而易见，三个构造函数，都接受一个io_service和信号量的值，唯一区别就是信号量的数量不同。<br>一开始看到，奇怪为什么不弄个可变参数模板呢，不是更好，看到下面也就释然了，因为类signal_set已经提供了add函数来增加信号量，这里构造函数数量1~3<br>只是为更方便而已，至于参数模板，实际是完全没有必要的。</p><h3 id="为什么都要实现两种呢"><a href="#为什么都要实现两种呢" class="headerlink" title="为什么都要实现两种呢"></a>为什么都要实现两种呢</h3><p>两个函数：<br>add向集合中添加信号量<br>remove删除信号量</p><pre><code class="hljs">    void add(int signal_number)    &#123;        boost::system::error_code ec;        this-&gt;service.add(this-&gt;implementation, signal_number, ec);        boost::asio::detail::throw_error(ec, &quot;add&quot;);    &#125;    boost::system::error_code add(int signal_number, boost::system::error_code&amp; ec)    &#123;        return this-&gt;service.add(this-&gt;implementation, signal_number, ec);    &#125;    void remove(int signal_number)    boost::system::error_code remove(int signal_number,    boost::system::error_code&amp; ec)</code></pre><p>我们很容易发现，两个函数唯一的区别就是对错误的处理的方式b：错误码和异常抛出。<br>因此我们可以通过对错误码判断和捕获异常来进行错误处理。<br>我们的程序有同步和异步两种模式，在同步模式下，无论用哪种都可以，但在异步模式下，程序不会抛出异常，所以就只能使用错误码了。</p><h3 id="清空和取消的区别"><a href="#清空和取消的区别" class="headerlink" title="清空和取消的区别"></a>清空和取消的区别</h3><pre><code class="hljs">    void clear()    boost::system::error_code clear(boost::system::error_code&amp; ec)    void cancel()    boost::system::error_code cancel(boost::system::error_code&amp; ec)</code></pre><p>从字面意思我们很容易感觉到他们的区别，何谓清空，清空就是没有了，而取消不代表没有。(ps:光看命名就能猜的八九不离十的代码，可谓好代码)<br>仔细的看了代码：<br>clear: 清空(删除)集合中的所有信号量，并删除所有通知队列里的事件，如果集合本身为空，则抛出错误。<br>cancel:不改变集合中的信号量，向所有与信号有关的操作抛出错误码来终止其操作。</p><h2 id="async-wait"><a href="#async-wait" class="headerlink" title="async_wait"></a>async_wait</h2><pre><code class="hljs">template &lt;typename SignalHandler&gt;BOOST_ASIO_INITFN_RESULT_TYPE(SignalHandler, void (boost::system::error_code, int))async_wait(BOOST_ASIO_MOVE_ARG(SignalHandler) handler)&#123;    // If you get an error on the following line it means that your handler does    // not meet the documented type requirements for a SignalHandler.    BOOST_ASIO_SIGNAL_HANDLER_CHECK(SignalHandler, handler) type_check;    return this-&gt;service.async_wait(this-&gt;implementation, BOOST_ASIO_MOVE_CAST(SignalHandler)(handler));&#125;</code></pre><p>这个函数很重要，因为我们对signal_set的主要使用要靠这个函数。<br>该函数接受一个 void (boost::system::error_code, int)) 类型的函数句柄，随后会在所监听的信号发生时调用此函数。<br>函数内部实现，只有两句话</p><pre><code class="hljs">BOOST_ASIO_SIGNAL_HANDLER_CHECK(SignalHandler, handler) type_check;</code></pre><p>对函数进行类型检查，这个宏写的很复杂，看了好一会儿，坦白说，知晓其功能，但不明白每一句的意思，找时间要好好把这里钻个透。</p><pre><code class="hljs">return this-&gt;service.async_wait(this-&gt;implementation, BOOST_ASIO_MOVE_CAST(SignalHandler)(handler));</code></pre><p>尾递归委托下层接口完成任务。</p><h2 id="使用例子"><a href="#使用例子" class="headerlink" title="使用例子"></a>使用例子</h2><pre><code class="hljs">////  main.cpp//  AsioServer////  Created by shiyi on 2016/12/10.//  Copyright © 2016年 shiyi. All rights reserved.//#include &lt;iostream&gt;#include &lt;boost/asio.hpp&gt;#include &lt;boost/bind.hpp&gt;#include &lt;boost/thread.hpp&gt;using namespace boost;void signal_handler(const boost::system::error_code&amp; err, int signal)&#123;    switch (signal) &#123;        case SIGINT:            std::cout &lt;&lt; &quot;SIGNINT&quot; &lt;&lt; std::endl;            break;        case SIGTERM:            std::cout &lt;&lt; &quot;SIGNTERM&quot; &lt;&lt; std::endl;            break;        default:            break;    &#125;&#125;int main(int argc, const char * argv[]) &#123;    asio::io_service service;    asio::signal_set sigset(service, SIGINT, SIGTERM);    sigset.async_wait(signal_handler);    boost::system::error_code ec;    service.run(ec);    if(ec)    &#123;        std::cout &lt;&lt; boost::system::system_error(ec).what() &lt;&lt; std::endl;    &#125;    std::cout &lt;&lt; &quot;End&quot; &lt;&lt; std::endl;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    <category term="大学时期CSDN" scheme="https://shiyi.threebody.xyz/categories/%E5%A4%A7%E5%AD%A6%E6%97%B6%E6%9C%9FCSDN/"/>
    
    
    <category term="服务器开发" scheme="https://shiyi.threebody.xyz/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/"/>
    
    <category term="C++" scheme="https://shiyi.threebody.xyz/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>shared_ptr智能指针模板类的简单实现(c++11)</title>
    <link href="https://shiyi.threebody.xyz/posts/32049.html"/>
    <id>https://shiyi.threebody.xyz/posts/32049.html</id>
    <published>2016-12-10T20:51:00.000Z</published>
    <updated>2022-12-08T15:35:14.153Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>最近突然萌生把stl常用的库都通通自己过一遍的想法，算是对泛型编程的一次学习，也深入理解stl，还是对c++11知识的练习，就从智能指针开始吧。<br>另外，c++11让c++程序变得简洁优雅了许多，对这门语言有点爱不释手了。</p></blockquote><h2 id="智能指针原理"><a href="#智能指针原理" class="headerlink" title="智能指针原理"></a>智能指针原理</h2><blockquote><p>通过使用引用计数的方式来自动的对动态申请的内存进行释放，保证指针的生存期和安全性。<br>对智能指针初始化的时候，会将引用计数初始为1，之后每次拷贝或移动赋值时，都对其引用计数加1.<br>而在其生存期结束，要进行析构时，对其进行引用计数减一，如果引用计数为0，则释放原指针保存的空间。<br>以前总疑惑 ** 指向同一空间的智能指针也是不同的对象，怎么在一个智能指针析构时对指向同一位置的所有智能指针进行操作呢 ** 。<br>其实这个问题很简单， ** 如果引用计数的变量的空间是动态申请的呢，每个智能指针只保存其指针，那么一个智能指针析构时操作就很容易做到影响所有其他智能指针了。<br>**</p></blockquote><h2 id="智能指针需要哪些组成部分"><a href="#智能指针需要哪些组成部分" class="headerlink" title="智能指针需要哪些组成部分"></a>智能指针需要哪些组成部分</h2><h3 id="模拟指针行为"><a href="#模拟指针行为" class="headerlink" title="模拟指针行为"></a>模拟指针行为</h3><p>智能指针，当然是模拟指针行为的类，所以我们要对解引用运算符和箭头运算符进行重载</p><pre><code class="hljs"> T&amp; operator*();//解引用重载 T* operator-&gt;();</code></pre><h4 id="箭头运算符重载的特殊性"><a href="#箭头运算符重载的特殊性" class="headerlink" title="箭头运算符重载的特殊性"></a>箭头运算符重载的特殊性</h4><p>c++primer第五版上关于箭头运算符的原话是</p><blockquote><p>和大多数其他运算符一样(尽管这么做不太好)，我们能令operator*完成任何我们指定的操作。箭头运算符则不是这样，它永远 **<br>不能丢掉成员访问这个最基本的含义 ** 。当我们重载箭头时，可以改变的是从哪个对象当中获取成员，而 ** 箭头获取成员 ** 这一事实则永远不变</p></blockquote><p>也就是说，比如我们定义智能指针p；<br>那么在进行*p操作时，等同于对T&amp;操作<br>而p-&gt;abcde操作时，等于(*p)-&gt;abcde;</p><h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><h3 id="拷贝构造函数和拷贝赋值运算符重载"><a href="#拷贝构造函数和拷贝赋值运算符重载" class="headerlink" title="拷贝构造函数和拷贝赋值运算符重载"></a>拷贝构造函数和拷贝赋值运算符重载</h3><p>我们的引用计数更改就是在上述函数内完成的，当然需要自定义。<br>我在此三者基础上，还增加实现了移动赋值的两个函数，搞得有点像标准的三五法则了。<br>其实不然，因为我们这个程序所有传参中均不涉及深拷贝，所以我们并不需要用移动赋值，此处我只是以学习为目的，想使用右值引用和完美转发而已，读者切勿多想。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="hljs">////  Shared_ptr.hpp//  demo////  Created by shiyi on 2016/12/10.//  Copyright © 2016年 shiyi. All rights reserved.//#ifndef Shared_ptr_Hpp#define Shared_ptr_Hpp#include &lt;stdio.h&gt;#include &lt;iostream&gt;using namespace std;template &lt;typename T&gt;class Shared_ptr&#123;private:    size_t* m_count;    T* m_ptr;public:    //构造函数    Shared_ptr() : m_ptr(nullptr), m_count(new size_t)    &#123;&#125;    Shared_ptr( T* ptr ) : m_ptr(ptr), m_count(new size_t)    &#123;        cout&lt;&lt;&quot;空间申请：&quot;&lt;&lt;ptr&lt;&lt;endl;        *m_count = 1;    &#125;    //析构函数    ~Shared_ptr()    &#123;        --(*m_count);        if(*m_count == 0)        &#123;            cout&lt;&lt;&quot;空间释放：&quot;&lt;&lt;m_ptr&lt;&lt;endl;            delete m_ptr;            delete m_count;            m_ptr = nullptr;            m_count = nullptr;        &#125;    &#125;    //拷贝构造函数    Shared_ptr( const Shared_ptr&amp; ptr )    &#123;        m_count = ptr.m_count;        m_ptr = ptr.m_ptr;        ++(*m_count);    &#125;    //拷贝赋值运算符    void operator=( const Shared_ptr&amp; ptr )    &#123;        Shared_ptr(std::move(ptr));    &#125;    //移动构造函数    Shared_ptr( Shared_ptr&amp;&amp; ptr ) : m_ptr(ptr.m_ptr), m_count(ptr.m_count)    &#123;        ++(*m_count);    &#125;    //移动赋值运算符    void operator=( Shared_ptr&amp;&amp; ptr )    &#123;        Shared_ptr(std::move(ptr));    &#125;    //解引用运算符    T&amp; operator*()    &#123;        return *m_ptr;    &#125;    //箭头运算符    T* operator-&gt;()    &#123;        return m_ptr;    &#125;    //重载布尔值操作    operator bool()    &#123;        return m_ptr == nullptr;    &#125;    T* get()    &#123;        return m_ptr;    &#125;    size_t use_count()    &#123;        return *m_count;    &#125;    bool unique()    &#123;        return *m_count == 1;    &#125;    void swap( Shared_ptr&amp; ptr )    &#123;        std::swap(*this, ptr);    &#125;&#125;;#endif /* Shared_ptr_Hpp */</code></pre><h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><pre><code class="hljs">#include &quot;Shared_ptr.hpp&quot;using namespace std;int main()&#123;    Shared_ptr&lt;int&gt; p1(new int);    *p1 = 222;    cout&lt;&lt;&quot;值：&quot;&lt;&lt;*p1&lt;&lt;&quot; 引用计数：&quot;&lt;&lt;p1.use_count()&lt;&lt;endl;    &#123;        Shared_ptr&lt;int&gt; p2(p1);        *p2 = 333;        cout&lt;&lt;&quot;值：&quot;&lt;&lt;*p2&lt;&lt;&quot; 引用计数：&quot;&lt;&lt;p1.use_count()&lt;&lt;endl;        Shared_ptr&lt;int&gt; p3(p2);        *p3 = 444;        cout&lt;&lt;&quot;值：&quot;&lt;&lt;*p3&lt;&lt;&quot; 引用计数：&quot;&lt;&lt;p1.use_count()&lt;&lt;endl;    &#125;    cout&lt;&lt;&quot;引用计数：&quot;&lt;&lt;p1.use_count()&lt;&lt;endl;    Shared_ptr&lt;string&gt; q1(new string(&quot;我是string1&quot;));    cout&lt;&lt;(*(q1)).c_str()&lt;&lt;endl;    Shared_ptr&lt;string&gt; q2(new string(&quot;我是string2&quot;));    q2.swap(q1);    cout&lt;&lt;(*(q1)).c_str()&lt;&lt;endl;    return 0;&#125;</code></pre><h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><p>![这里写图片描述](<a href="http://img.blog.csdn.net/20161211044721300?watermark/2/text/aHR0cDo">http://img.blog.csdn.net/20161211044721300?watermark/2/text/aHR0cDo</a><br>vL2Jsb2cuY3Nkbi5uZXQvdG9fYmVfYmV0dGVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFC<br>MA==/dissolve/70/gravity/SouthEast)</p>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    <category term="大学时期CSDN" scheme="https://shiyi.threebody.xyz/categories/%E5%A4%A7%E5%AD%A6%E6%97%B6%E6%9C%9FCSDN/"/>
    
    
    <category term="C++" scheme="https://shiyi.threebody.xyz/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>boost:asio网络库初学之echo服务器客户端实现</title>
    <link href="https://shiyi.threebody.xyz/posts/21818.html"/>
    <id>https://shiyi.threebody.xyz/posts/21818.html</id>
    <published>2016-12-10T10:58:00.000Z</published>
    <updated>2022-12-08T15:35:14.153Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么想起来学网络库呢"><a href="#为什么想起来学网络库呢" class="headerlink" title="为什么想起来学网络库呢"></a>为什么想起来学网络库呢</h2><p>前一阵在网上看到这么一段话</p><blockquote><p>select 实在是太慢了.</p></blockquote><blockquote></blockquote><blockquote><p>在这种背景下, IBM 老大哥带领着MS老弟先搞了 IOCP . 然而开源的人有开源的做法, 在 NIH 综合症的影响下, BSD 的人敢为天下所不齿,<br>发明了 Kqueue. 同样在 NIH 综合症影响下, Linux 的一群 M* 的猴子捣鼓出了 epoll.</p></blockquote><blockquote></blockquote><blockquote><p>分裂, 让人头疼.</p></blockquote><blockquote></blockquote><blockquote><p>于是程序员们急需一个上天入地无所不能的法宝的法宝, 把这3家法宝给统御起来。</p></blockquote><p>实在太符合我的心情了，我就很需要这样一个法宝，让自己舒服一点。因为是macos系统，类Unix，在服务器开发方面，linux有的基本都有，差不多是一致的，但<br>就是没有Epoll！！！，这就有些麻烦了，上一次写网关服务器时候，开发过程是这样的：<br>用sublime远程连接云服务器，<br>再用终端ssh运行调试，<br>就这样循环往复，再加上还没有补全，适应了xcode的舒服，所以痛苦ing。</p><h2 id="说重点，为什么选择asio呢"><a href="#说重点，为什么选择asio呢" class="headerlink" title="说重点，为什么选择asio呢"></a>说重点，为什么选择asio呢</h2><blockquote><p>1.asio属于boost的一部分，有可能被加入c++标准库，其代码质量稳定性及可靠性已不言而喻。<br>2.还是c++的原因，其源码使用了大多c++11特性，想在对其源码的学习过程中，对自己的c++知识进行一次加深和巩固<br>3.其主要针对于异步Proactor模式，而此模式相比较Reactor模式，学习难度稍高，所以想借着学习库使用的同时，能对其源码进行学习，提高事件驱动编程的<br>能力。<br>4.当然是跨平台了。</p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><pre><code class="hljs">////  main.cpp//  AsioClient////  Created by shiyi on 2016/12/10.//  Copyright © 2016年 shiyi. All rights reserved.//#include &lt;iostream&gt;#include &lt;boost/asio.hpp&gt;#include &lt;boost/bind.hpp&gt;using namespace boost;int main(int argc, const char * argv[]) &#123;    asio::io_service service;//创建调度器    asio::ip::tcp::socket sock(service);//创建socket    asio::ip::tcp::endpoint ep(asio::ip::address::from_string(&quot;127.0.0.1&quot;), 6666);//创建目标地址对象    //异步连接    sock.async_connect(ep, [](const boost::system::error_code &amp;error)&#123;        if(error)        &#123;            std::cout &lt;&lt; error.message() &lt;&lt; std::endl;            return;        &#125;        std::cout &lt;&lt; &quot;connect succeed&quot; &lt;&lt; std::endl;    &#125;);    //如果不进行run调用的话，程序会直接结束，所以这里会等待async_connect结束，    //因此上面connect同步还是异步其实是一样的    service.run();    char data[512];    boost::system::error_code ec;    size_t len;    while(true)    &#123;        std::cin &gt;&gt; data;        //发送 如果不传入 ec(error_code)参数，则出错时会抛出异常，此时可以用try-catch进行捕获，如果也没捕获，程序会直接终止        len = sock.write_some(asio::buffer(data), ec);        if(ec)        &#123;            std::cout &lt;&lt; boost::system::system_error(ec).what() &lt;&lt; std::endl;            break;        &#125;        //接收        len = sock.read_some(asio::buffer(data), ec);        if(ec)        &#123;            std::cout &lt;&lt; boost::system::system_error(ec).what() &lt;&lt; std::endl;            break;        &#125;        std::cout &lt;&lt; data &lt;&lt; std::endl;    &#125;    return 0;&#125;</code></pre><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><pre><code class="hljs">////  main.cpp//  AsioServer////  Created by shiyi on 2016/12/10.//  Copyright © 2016年 shiyi. All rights reserved.//#include &lt;iostream&gt;#include &lt;boost/asio.hpp&gt;#include &lt;boost/bind.hpp&gt;#include &lt;boost/thread.hpp&gt;using namespace boost;using socket_ptr = boost::shared_ptr&lt;asio::ip::tcp::socket&gt;;//包装socket类型的智能指针void client_session(socket_ptr sock)&#123;    auto ep = sock-&gt;local_endpoint();    std::cout&lt;&lt;ep.address().to_string()&lt;&lt;&quot;连接&quot;&lt;&lt;std::endl;    char data[512];    boost::system::error_code ec;    size_t len;    while(true)    &#123;        len = sock-&gt;read_some(asio::buffer(data), ec);        if(ec)        &#123;            std::cout &lt;&lt; boost::system::system_error(ec).what() &lt;&lt; std::endl;            break;        &#125;        len = sock-&gt;write_some(asio::buffer(data), ec);        if(ec)        &#123;            std::cout &lt;&lt; boost::system::system_error(ec).what() &lt;&lt; std::endl;            break;        &#125;    &#125;    std::cout&lt;&lt;ep.address().to_string()&lt;&lt;&quot;关闭&quot;&lt;&lt;std::endl;&#125;int main(int argc, const char * argv[]) &#123;    asio::io_service service;//创建调度器    asio::ip::tcp::endpoint ep(asio::ip::address::from_string(&quot;127.0.0.1&quot;), 6666);    asio::ip::tcp::acceptor apt(service, ep);//创建连接器    while(true)    &#123;        socket_ptr sock(new asio::ip::tcp::socket(service));        apt.accept(*sock);//接收新的连接        boost::thread(boost::bind(client_session, sock));//开辟线程去处理该连接上的事务    &#125;&#125;</code></pre><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><h3 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h3><p>![这里写图片描述](<a href="http://img.blog.csdn.net/20161210185739981?watermark/2/text/aHR0cDo">http://img.blog.csdn.net/20161210185739981?watermark/2/text/aHR0cDo</a><br>vL2Jsb2cuY3Nkbi5uZXQvdG9fYmVfYmV0dGVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFC<br>MA==/dissolve/70/gravity/SouthEast)</p><h3 id="服务端-1"><a href="#服务端-1" class="headerlink" title="服务端"></a>服务端</h3><p>![这里写图片描述](<a href="http://img.blog.csdn.net/20161210185752888?watermark/2/text/aHR0cDo">http://img.blog.csdn.net/20161210185752888?watermark/2/text/aHR0cDo</a><br>vL2Jsb2cuY3Nkbi5uZXQvdG9fYmVfYmV0dGVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFC<br>MA==/dissolve/70/gravity/SouthEast)</p>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    <category term="大学时期CSDN" scheme="https://shiyi.threebody.xyz/categories/%E5%A4%A7%E5%AD%A6%E6%97%B6%E6%9C%9FCSDN/"/>
    
    
    <category term="服务器开发" scheme="https://shiyi.threebody.xyz/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/"/>
    
    <category term="C++" scheme="https://shiyi.threebody.xyz/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Mac Boost安装及使用(命令行和Xcode)</title>
    <link href="https://shiyi.threebody.xyz/posts/17125.html"/>
    <id>https://shiyi.threebody.xyz/posts/17125.html</id>
    <published>2016-12-09T18:14:00.000Z</published>
    <updated>2022-12-08T15:35:14.149Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol><li>下载boost安装包<br>官网下载地址<br><a href="https://sourceforge.net/projects/boost/files/boost/1.62.0/"> https://sourceforge.net/projects/boost/files/boost/1.62.0/</a></li></ol><p>2.解压并进入boost_1_62_0文件夹<br>3.执行boostrap.sh</p><blockquote><p>./boostrap.sh</p></blockquote><p>4.上一步执行成功后会生成b2脚本，执行它<br>./b2</p><blockquote><p>执行完毕后，头文件在boost_1_62_0/boost文件夹下<br>库文件在boost_1_62_0/stage/lib文件夹下</p></blockquote><blockquote></blockquote><blockquote><p>也可以直接执行<br>./b2 install<br>执行完毕后头文件在/usr/local/include下<br>库文件在/usr/local/lib下</p></blockquote><ol><li>至此安装完成</li></ol><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="测试程序"><a href="#测试程序" class="headerlink" title="测试程序"></a>测试程序</h3><p>直接包含一个头文件编译看是否通过即可</p><pre><code class="hljs">#include &lt;boost/asio.hpp&gt;int main()&#123;&#125;</code></pre><h3 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h3><p>g++使用第三方库编译是如下命令</p><pre><code class="hljs">    g++ a.cpp  -I 头文件路径 -L 库文件路径 -l 动态链接库</code></pre><p>对应到我们这里应该是</p><pre><code class="hljs">    g++ a.cpp  -I /usr/local/include -L /usr/local/lib -l boost_system -l boost_thread</code></pre><p>** 必须要加，-l boost_system -l boost_thread，否则会报错 **</p><blockquote></blockquote><blockquote><pre><code class="hljs">  Undefined symbols for architecture x86_64:</code></pre></blockquote><blockquote></blockquote><blockquote><p>“boost::system::system_category()”, referenced from:<br>boost::asio::error::get_system_category() in a-0e6774.o<br>___cxx_global_var_init.2 in a-0e6774.o<br>“boost::system::generic_category()”, referenced from:<br>___cxx_global_var_init in a-0e6774.o<br>___cxx_global_var_init.1 in a-0e6774.o<br>ld: symbol(s) not found for architecture x86_64<br>clang: error: linker command failed with exit code 1 (use -v to see<br>invocation)</p></blockquote><h3 id="Xcode"><a href="#Xcode" class="headerlink" title="Xcode"></a>Xcode</h3><ol><li>点击【项目工程文件】-》【Targets】-》【BuildSetting】-》【Search Paths】-》【Header Search Paths】输入 ** 头文件 ** 路径</li><li>点击【项目工程文件】-》【Targets】-》【BuildSetting】-》【Search Paths】-》【Library Search Paths】输入 ** 库文件 ** 路径</li><li>点击【项目工程文件】-》【Targets】-》【BuildSetting】-》【Linking】-》【Other Linker Flags】输入链接选项，输入-l boost_system -l boost_thread</li></ol><h3 id="大功告成"><a href="#大功告成" class="headerlink" title="大功告成"></a>大功告成</h3>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    <category term="大学时期CSDN" scheme="https://shiyi.threebody.xyz/categories/%E5%A4%A7%E5%AD%A6%E6%97%B6%E6%9C%9FCSDN/"/>
    
    
    <category term="Boost" scheme="https://shiyi.threebody.xyz/tags/Boost/"/>
    
  </entry>
  
</feed>
