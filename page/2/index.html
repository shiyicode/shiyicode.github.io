<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/favicon/apple-touch-icon.png"><link rel="icon" href="/favicon/favicon-32x32.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="theme-color" content="#2f4154"><meta name="author" content="Yi Shi"><meta name="keywords" content="shiyi, yishi, threebody, blog, golang"><meta name="description" content="Less is More"><meta property="og:type" content="website"><meta property="og:title" content="Yi Shi&#39;s Blog"><meta property="og:url" content="https://shiyi.threebody.xyz/page/2/index.html"><meta property="og:site_name" content="Yi Shi&#39;s Blog"><meta property="og:description" content="Less is More"><meta property="og:locale" content="zh_CN"><meta property="article:author" content="Yi Shi"><meta property="article:tag" content="shiyi, yishi, threebody, blog, golang"><meta name="twitter:card" content="summary_large_image"><title>Yi Shi&#39;s Blog</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"shiyi.threebody.xyz",root:"/",version:"1.9.3",typing:{enable:!0,typeSpeed:50,cursorChar:"",loop:!1,scope:["home"]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!0,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:4},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!0,follow_dnt:!0,baidu:"75eaaab59c4fa946437e9dea4f8fc07d",google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:1273342630,leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml"};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><script async>if(!Fluid.ctx.dnt){var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?75eaaab59c4fa946437e9dea4f8fc07d";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()}</script><script async>Fluid.ctx.dnt||Fluid.utils.createScript("//s4.cnzz.com/z_stat.php?id=1273342630&show=pic")</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Yi Shi's Blog" type="application/atom+xml">
</head><body><header><div class="header-inner" style="height:100vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>Yi Shi&#39;s Blog</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/books/"><i class="iconfont icon-book"></i> 读书</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/image/background.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.4)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="字斟句酌处，亦是与心推敲时"></span></div></div><div class="scroll-down-bar"><i class="iconfont icon-arrowdown"></i></div></div></div></div></div></header><main><div class="container nopadding-x-md"><div id="board" style="margin-top:0"><div class="container"><div class="row"><div class="col-12 col-md-10 m-auto"><div class="row mx-auto index-card"><article class="col-12 col-md-12 mx-auto index-info"><h1 class="index-header"><a href="/posts/51226.html" target="_self">8086汇编初学之贪吃蛇</a></h1><a class="index-excerpt index-excerpt__noimg" href="/posts/51226.html" target="_self"><div>前言一直没想过要去学习汇编，觉得需要用汇编的场合无非三种：1. 与硬件结合很紧密高级语言做不到2. 时空效率要求甚高算法层面已不能优化到3. 逆向破解等只能用某些途径看其汇编指令其余情况下，用汇编无异于有炮不用偏用鸟枪。本来准备等自己需求以上场合时再去学，但因为学校举办的汇编比赛，计算机学院都要参加，也算是一个由头，于是开始了我的第一个汇编程序。 运行效果代码只有400行，功能很简略，实现了最基本</div></a><div class="index-btm post-metas"><div class="post-meta mr-3"><i class="iconfont icon-date"></i> <time datetime="2016-12-08 04:35" pubdate>2016-12-08</time></div><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E5%A4%A7%E5%AD%A6%E6%97%B6%E6%9C%9FCSDN/" class="category-chain-item">大学时期CSDN</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/">#游戏开发</a> <a href="/tags/%E6%B1%87%E7%BC%96/">#汇编</a></div></div></article></div><div class="row mx-auto index-card"><article class="col-12 col-md-12 mx-auto index-info"><h1 class="index-header"><a href="/posts/36868.html" target="_self">linux服务器开发之网关服务器的实现</a></h1><a class="index-excerpt index-excerpt__noimg" href="/posts/36868.html" target="_self"><div>什么是网关服务器 初学linux服务器开发时，我们的服务器是很简单的，只需要一个程序完成与客户端的连接，接收客户端数据，数据处理，向客户端发送数据。但是在处理量很大的情况下，一台机器不能满足我们的需求，此时我们应该怎么办。我们可以将服务端的任务分摊到多台机器上完成，见下图 从图中可见，此时整个服务端主要分为了三部分。** 网关服务器：负责连接客户端与逻辑服务器，在两者间完成数据转发，使用负</div></a><div class="index-btm post-metas"><div class="post-meta mr-3"><i class="iconfont icon-date"></i> <time datetime="2016-12-05 21:50" pubdate>2016-12-05</time></div><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E5%A4%A7%E5%AD%A6%E6%97%B6%E6%9C%9FCSDN/" class="category-chain-item">大学时期CSDN</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/">#服务器开发</a> <a href="/tags/C/">#C++</a> <a href="/tags/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">#Linux网络编程</a></div></div></article></div><div class="row mx-auto index-card"><article class="col-12 col-md-12 mx-auto index-info"><h1 class="index-header"><a href="/posts/12582.html" target="_self">Epoll-ET模式读写之用户连接的封装</a></h1><a class="index-excerpt index-excerpt__noimg" href="/posts/12582.html" target="_self"><div>前言 服务端而言，对于每一个新的连接我们都需要去保存其基本信息，如ip地址，套接字fd，也需要赋予其唯一标识如用户名。这里，我们来谈谈对用户连接的封装。 用户连接需要哪些数据1. 套接字描述符 sockfd 执行读写操作时当然不可缺 2. 连接信息 sockaddr 基本信息的保存 3. 用户缓存区 Buffer 非阻塞读写不可缺 4. 唯一标识</div></a><div class="index-btm post-metas"><div class="post-meta mr-3"><i class="iconfont icon-date"></i> <time datetime="2016-12-03 16:36" pubdate>2016-12-03</time></div><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E5%A4%A7%E5%AD%A6%E6%97%B6%E6%9C%9FCSDN/" class="category-chain-item">大学时期CSDN</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/">#服务器开发</a> <a href="/tags/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">#Linux网络编程</a></div></div></article></div><div class="row mx-auto index-card"><article class="col-12 col-md-12 mx-auto index-info"><h1 class="index-header"><a href="/posts/20402.html" target="_self">Epoll-ET模式下非阻塞读写之Buffer的封装</a></h1><a class="index-excerpt index-excerpt__noimg" href="/posts/20402.html" target="_self"><div>先说说Epoll的ET模式 epoll默认的模式是LT，要说ET不得不提到LT，LT与ET的区别可以用一句话概括：LT模式下只要socket处于可读状态(添加EPOLLIN事件时)或可写状态(添加EPOLLOUT事件时)，就会一直返回其socket。ET模式下在第一次返回socket后，只有当socket由不可写到可写(添加EPOLLIN事件时)或由不可读到可读(添加EPOLLOUT事件时)，才会</div></a><div class="index-btm post-metas"><div class="post-meta mr-3"><i class="iconfont icon-date"></i> <time datetime="2016-12-03 03:44" pubdate>2016-12-03</time></div><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E5%A4%A7%E5%AD%A6%E6%97%B6%E6%9C%9FCSDN/" class="category-chain-item">大学时期CSDN</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/">#服务器开发</a> <a href="/tags/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">#Linux网络编程</a></div></div></article></div><div class="row mx-auto index-card"><article class="col-12 col-md-12 mx-auto index-info"><h1 class="index-header"><a href="/posts/31618.html" target="_self">linux之信号处理函数signal和sigaction</a></h1><a class="index-excerpt index-excerpt__noimg" href="/posts/31618.html" target="_self"><div>signal回调函数绑定信号(signal)是一种软件中断，它提供了一种处理异步事件的方法，也是进程间惟一的异步通信方式。那么我们很多场景下，需要对不同的信号进行捕获并做出响应操作。在linux上，我们有两种方式完成该操作： 1. signal#include &lt;signal.h&gt; signal(int, void (*)(int)); 第一个参数是我们要捕获的信号类型，第二个参数是</div></a><div class="index-btm post-metas"><div class="post-meta mr-3"><i class="iconfont icon-date"></i> <time datetime="2016-11-22 03:20" pubdate>2016-11-22</time></div><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E5%A4%A7%E5%AD%A6%E6%97%B6%E6%9C%9FCSDN/" class="category-chain-item">大学时期CSDN</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/">#服务器开发</a> <a href="/tags/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">#Linux网络编程</a></div></div></article></div><div class="row mx-auto index-card"><article class="col-12 col-md-12 mx-auto index-info"><h1 class="index-header"><a href="/posts/31126.html" target="_self">游戏后台开发九问(腾讯技术分享实录)</a></h1><a class="index-excerpt index-excerpt__noimg" href="/posts/31126.html" target="_self"><div>[导读]腾讯游戏讯，7月30日消息，第九届中国游戏商务大会网页游戏论坛30日在上海浦东嘉里大酒店展进行相关主题论坛活动。 30日，在上海chinajoy嘉里酒店进行了游戏开发者大会，腾讯游戏的研发部助力总经理聂志明进行了演讲。 他为大家演讲的题目是“游戏后台开发中的九个选择”，他解释，使用这个标题的原因，是因为我们在生活中总会遇到很多选择，这个道理同样适用在游戏开发中。 这九个选</div></a><div class="index-btm post-metas"><div class="post-meta mr-3"><i class="iconfont icon-date"></i> <time datetime="2016-11-21 14:21" pubdate>2016-11-21</time></div><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E5%A4%A7%E5%AD%A6%E6%97%B6%E6%9C%9FCSDN/" class="category-chain-item">大学时期CSDN</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/">#游戏开发</a></div></div></article></div><div class="row mx-auto index-card"><article class="col-12 col-md-12 mx-auto index-info"><h1 class="index-header"><a href="/posts/64027.html" target="_self">Linux 怎样实现非阻塞connect</a></h1><a class="index-excerpt index-excerpt__noimg" href="/posts/64027.html" target="_self"><div>前言 凡是接触过socket编程的，对connect函数一定不陌生。因为socket是面向连接的，所以在进行读写操作前我们首先要进行连接，而所谓连接也就是我们常说的三次握手，这个过程就是在connect函数中完成的。虽然connect函数本身不具备阻塞的功能，但是我们可以通过对socket进行设置和使用select函数可以设置阻塞时间的特性实现非阻塞。 为什么要非阻塞 第一，我们可以在conne</div></a><div class="index-btm post-metas"><div class="post-meta mr-3"><i class="iconfont icon-date"></i> <time datetime="2016-11-07 19:50" pubdate>2016-11-07</time></div><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E5%A4%A7%E5%AD%A6%E6%97%B6%E6%9C%9FCSDN/" class="category-chain-item">大学时期CSDN</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/">#服务器开发</a> <a href="/tags/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">#Linux网络编程</a></div></div></article></div><div class="row mx-auto index-card"><article class="col-12 col-md-12 mx-auto index-info"><h1 class="index-header"><a href="/posts/63134.html" target="_self">自制Lex-词法分析器生成器(C++)</a></h1><a class="index-excerpt index-excerpt__noimg" href="/posts/63134.html" target="_self"><div>前言 前一阵子，编译原理课实验内容是要去做一个词法分析器，实现后，觉得没有把 ** 正规表达式和NFA、DFA **这些知识用上，所以就产生了想自己去实现一个lex的想法，于是就有了这篇博文。如果还不知道词法分析器该怎么实现，可以去看 [ c语言词法分析初试(C++实现) ](c%E8%AF%AD%E8%A8%80%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E5%88</div></a><div class="index-btm post-metas"><div class="post-meta mr-3"><i class="iconfont icon-date"></i> <time datetime="2016-10-31 23:03" pubdate>2016-10-31</time></div><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E5%A4%A7%E5%AD%A6%E6%97%B6%E6%9C%9FCSDN/" class="category-chain-item">大学时期CSDN</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/">#编译原理</a></div></div></article></div><div class="row mx-auto index-card"><article class="col-12 col-md-12 mx-auto index-info"><h1 class="index-header"><a href="/posts/9932.html" target="_self">linux之创建守护进程</a></h1><a class="index-excerpt index-excerpt__noimg" href="/posts/9932.html" target="_self"><div>简介 守护进程是一种运行在后台的特殊进程，它 ** 独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件 ** 。其实，本质上守护进程和普通的进程并没有什么区别，只是我们规定了一种进程的编写规则，将其叫做守护进程，仅此而已。 特点1. 在后台运行 为了不让其阻塞终端，我们用fork()创建子进程，然后退出父进程，就可以完成在后台运行的目的。 2. 脱离控制终端，创建新的会话组和进程组</div></a><div class="index-btm post-metas"><div class="post-meta mr-3"><i class="iconfont icon-date"></i> <time datetime="2016-10-17 17:48" pubdate>2016-10-17</time></div><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E5%A4%A7%E5%AD%A6%E6%97%B6%E6%9C%9FCSDN/" class="category-chain-item">大学时期CSDN</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/">#服务器开发</a> <a href="/tags/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/">#Linux系统编程</a></div></div></article></div><div class="row mx-auto index-card"><article class="col-12 col-md-12 mx-auto index-info"><h1 class="index-header"><a href="/posts/32846.html" target="_self">linux之fcntl&amp;flock建议锁的操作</a></h1><a class="index-excerpt index-excerpt__noimg" href="/posts/32846.html" target="_self"><div>前言当我们要进行多进程编程的时候，经常存在多个进程需要访问同一个文件的情况，因此会产生进程间访问不一致的问题，那么我们可以用到fcntl函数，我们可以用它来对文件或者文件的一部分进行上锁。 #include &lt;unistd.h&gt; #include &lt;fcntl.h&gt; int fcntl(int fd, int cmd, ... /* arg */ );</div></a><div class="index-btm post-metas"><div class="post-meta mr-3"><i class="iconfont icon-date"></i> <time datetime="2016-10-12 22:33" pubdate>2016-10-12</time></div><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E5%A4%A7%E5%AD%A6%E6%97%B6%E6%9C%9FCSDN/" class="category-chain-item">大学时期CSDN</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/">#服务器开发</a> <a href="/tags/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/">#Linux系统编程</a></div></div></article></div><div class="row mx-auto index-card"><article class="col-12 col-md-12 mx-auto index-info"><h1 class="index-header"><a href="/posts/28691.html" target="_self">c语言词法分析初试(C++实现)</a></h1><a class="index-excerpt index-excerpt__noimg" href="/posts/28691.html" target="_self"><div>开篇 所谓词法分析，就是将源代码按照构词规则分解成一系列单词符号。单词是语言中具有独立意义的最小单位，包括关键字、标识符、运算符、界符和常量等。 分析 源程序分解的单词可以归为以下几类： 1. 关键字 c语言关键字有不少，这里只列举其中一部分：for，while，do，continue，if，else，char，int，double，return 2. 变量名 变量名的规则为：由字母数字以及</div></a><div class="index-btm post-metas"><div class="post-meta mr-3"><i class="iconfont icon-date"></i> <time datetime="2016-10-08 19:19" pubdate>2016-10-08</time></div><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E5%A4%A7%E5%AD%A6%E6%97%B6%E6%9C%9FCSDN/" class="category-chain-item">大学时期CSDN</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/">#编译原理</a></div></div></article></div><div class="row mx-auto index-card"><article class="col-12 col-md-12 mx-auto index-info"><h1 class="index-header"><a href="/posts/7094.html" target="_self">正规表达式转NFA(C++)</a></h1><a class="index-excerpt index-excerpt__noimg" href="/posts/7094.html" target="_self"><div>分析 表达式里包含五种符号：左括号，右括号，连接符，选择符，闭包符。连接符因为优先级最高，可以将其过滤掉，不予考虑。 闭包符* 首先来说闭包，无非两种情况：X* 或者 (…..)*两者都可以看做是从一个起始状态，经过诸多输入到达一个终止状态。如 1– X –&gt;2 和 1– (……) –&gt; 2。那么闭包符可以看做是以下操作：1 – ε –&gt; 22 – ε –&gt; 1即将首尾以</div></a><div class="index-btm post-metas"><div class="post-meta mr-3"><i class="iconfont icon-date"></i> <time datetime="2016-10-02 02:56" pubdate>2016-10-02</time></div><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E5%A4%A7%E5%AD%A6%E6%97%B6%E6%9C%9FCSDN/" class="category-chain-item">大学时期CSDN</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/">#编译原理</a></div></div></article></div><div class="row mx-auto index-card"><article class="col-12 col-md-12 mx-auto index-info"><h1 class="index-header"><a href="/posts/43695.html" target="_self">JavaWeb ServletContext/application初试总结</a></h1><a class="index-excerpt index-excerpt__noimg" href="/posts/43695.html" target="_self"><div>简介：ServletContext/application 为什么将其两者放在一起介绍呢，因为他们可以被看做是同一个类，只是名字起得不同而已。ServletContext是在Servlet中使用，而application则作为内置对象用于jsp中。他们的作用域是 ** 整个tomcat的从启动到关闭的过程 ** 。我们可以将其看做是JavaWeb应用里的全局变量。 功能 所谓功能，也就是说，我们</div></a><div class="index-btm post-metas"><div class="post-meta mr-3"><i class="iconfont icon-date"></i> <time datetime="2016-09-26 18:46" pubdate>2016-09-26</time></div><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E5%A4%A7%E5%AD%A6%E6%97%B6%E6%9C%9FCSDN/" class="category-chain-item">大学时期CSDN</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/Web%E5%BC%80%E5%8F%91/">#Web开发</a></div></div></article></div><div class="row mx-auto index-card"><article class="col-12 col-md-12 mx-auto index-info"><h1 class="index-header"><a href="/posts/11961.html" target="_self">IDEA使用maven创建web项目卡住解决办法</a></h1><a class="index-excerpt index-excerpt__noimg" href="/posts/11961.html" target="_self"><div>解决方法 如下图所示：在Properties中添加一个参数archetypeCatalog=internal，不加这个参数，在maven生成骨架的时候将会非常慢，有时候会直接卡住。 理由 archetypeCatalog表示插件使用的archetype元数据，不加这个参数时默认为remote，local，即中央仓库archetype元数据，由于中央仓库的archetype太多了，所以导致很慢，指</div></a><div class="index-btm post-metas"><div class="post-meta mr-3"><i class="iconfont icon-date"></i> <time datetime="2016-09-23 00:22" pubdate>2016-09-23</time></div><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E5%A4%A7%E5%AD%A6%E6%97%B6%E6%9C%9FCSDN/" class="category-chain-item">大学时期CSDN</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/Web%E5%BC%80%E5%8F%91/">#Web开发</a></div></div></article></div><div class="row mx-auto index-card"><article class="col-12 col-md-12 mx-auto index-info"><h1 class="index-header"><a href="/posts/28122.html" target="_self">网易游戏面试题</a></h1><a class="index-excerpt index-excerpt__noimg" href="/posts/28122.html" target="_self"><div>题意 思路 乍一看题，冒出来的思路是，将每个用户凡是在同一个群的两个用户看做是一条无向边，这样所有群的所有用户之间的联系就转化为了一张图，然后以官方用户(id=1)为起点，计算所有可以到达的节点的总数，dfs即可，按着这个思路正准备开始写，发现id max为100000，二维数组是开不了了，临界表的话未免也太繁琐了。才突然意识到我们只需要对所有用户之间的连通性进行判断，至于具体的连通顺序根本不需要</div></a><div class="index-btm post-metas"><div class="post-meta mr-3"><i class="iconfont icon-date"></i> <time datetime="2016-09-19 23:30" pubdate>2016-09-19</time></div><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E5%A4%A7%E5%AD%A6%E6%97%B6%E6%9C%9FCSDN/" class="category-chain-item">大学时期CSDN</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/%E5%B9%B6%E5%B7%AE%E9%9B%86/">#并差集</a></div></div></article></div><div class="row mx-auto index-card"><article class="col-12 col-md-12 mx-auto index-info"><h1 class="index-header"><a href="/posts/64340.html" target="_self">JDBC数据库操作封装(PreparedStatement)</a></h1><a class="index-excerpt index-excerpt__noimg" href="/posts/64340.html" target="_self"><div>之前有用过老师给的实现好的JDBC封装类，今天自己看着书按自己思路实现了一遍，并将Statement改为了PreparedStatement。 代码import com.sun.tools.javac.util.List; import java.sql.*; import java.util.ArrayList; import java.util.HashMap; import java.u</div></a><div class="index-btm post-metas"><div class="post-meta mr-3"><i class="iconfont icon-date"></i> <time datetime="2016-09-19 20:04" pubdate>2016-09-19</time></div><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E5%A4%A7%E5%AD%A6%E6%97%B6%E6%9C%9FCSDN/" class="category-chain-item">大学时期CSDN</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/Java/">#Java</a></div></div></article></div><div class="row mx-auto index-card"><article class="col-12 col-md-12 mx-auto index-info"><h1 class="index-header"><a href="/posts/3962.html" target="_self">Mysql查询重复数据并按条件删除重复行</a></h1><a class="index-excerpt index-excerpt__noimg" href="/posts/3962.html" target="_self"><div>在对游戏进行合区的过程中, 存在一个情况,那就是当一个账号在两个区都存在角色的时候, 需要按照条件对重复角色进行删除,比如以等级为条件, 只保留等级高的. 解决方案用mysql语句, 两条就可以解决: 首先, 第一条语句 create temporary table temp as select user_id,max(level) as MAXID from user group by</div></a><div class="index-btm post-metas"><div class="post-meta mr-3"><i class="iconfont icon-date"></i> <time datetime="2016-09-02 14:28" pubdate>2016-09-02</time></div><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E5%A4%A7%E5%AD%A6%E6%97%B6%E6%9C%9FCSDN/" class="category-chain-item">大学时期CSDN</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/">#游戏开发</a></div></div></article></div><div class="row mx-auto index-card"><article class="col-12 col-md-12 mx-auto index-info"><h1 class="index-header"><a href="/posts/25065.html" target="_self">java程序操作命令行</a></h1><a class="index-excerpt index-excerpt__noimg" href="/posts/25065.html" target="_self"><div>使用 在写java项目时, 有些特殊情况下需要用到操作命令行, 以前用过好几次, 都是用的时候从网上找, 用完又忘记, 用一次找一次,所以这次干脆将其保存在这里. /** * Created by shiyi on 16/8/30. */ import java.io.BufferedReader; import java.io.InputStreamReader; public clas</div></a><div class="index-btm post-metas"><div class="post-meta mr-3"><i class="iconfont icon-date"></i> <time datetime="2016-08-31 15:38" pubdate>2016-08-31</time></div><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E5%A4%A7%E5%AD%A6%E6%97%B6%E6%9C%9FCSDN/" class="category-chain-item">大学时期CSDN</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/Java/">#Java</a></div></div></article></div><div class="row mx-auto index-card"><article class="col-12 col-md-12 mx-auto index-info"><h1 class="index-header"><a href="/posts/41280.html" target="_self">步步为营-墙棋AI人机对战(Android)</a></h1><a class="index-excerpt index-excerpt__noimg" href="/posts/41280.html" target="_self"><div>放纵了三天了，之前写了一半懒得去动的墙棋，反而在这几天间隙断断续续完成了，也是挺可笑的。 简介-关于墙棋 路墙棋（Quoridor），或译墙棋、步步为营，是由Mirko Marchesi（米尔科·迈凯西）设计、GigamicGames发行的两到四人对战的棋类游戏(桌面游戏)，并在1997年被门萨国际评选为门萨推荐的游戏。1998年游戏杂志（GamesMagazine）年度游戏大奖。 先</div></a><div class="index-btm post-metas"><div class="post-meta mr-3"><i class="iconfont icon-date"></i> <time datetime="2016-08-01 19:30" pubdate>2016-08-01</time></div><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E5%A4%A7%E5%AD%A6%E6%97%B6%E6%9C%9FCSDN/" class="category-chain-item">大学时期CSDN</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/">#游戏开发</a> <a href="/tags/Android/">#Android</a></div></div></article></div><div class="row mx-auto index-card"><article class="col-12 col-md-12 mx-auto index-info"><h1 class="index-header"><a href="/posts/25241.html" target="_self">cocos2dx实现简单卡牌翻转效果</a></h1><a class="index-excerpt index-excerpt__noimg" href="/posts/25241.html" target="_self"><div>将两张图片放入图层，将其中一个图片x的比例设置为0，即隐藏起来。分别给两个图片绑定点击监听事件，事件触发后执行缩放动作。将自身x比例设置为0，完成后将另一张图片x比例设置为1。详见代码注释。 bool HelloWorld::init() &#123; ////////////////////////////// // 1. super init first if (</div></a><div class="index-btm post-metas"><div class="post-meta mr-3"><i class="iconfont icon-date"></i> <time datetime="2016-07-23 03:04" pubdate>2016-07-23</time></div><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E5%A4%A7%E5%AD%A6%E6%97%B6%E6%9C%9FCSDN/" class="category-chain-item">大学时期CSDN</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/Cocos2d-X%E5%BC%80%E5%8F%91/">#Cocos2d-X开发</a></div></div></article></div><nav aria-label="navigation"><span class="pagination" id="pagination"><a class="extend prev" rel="prev" href="/"><i class="iconfont icon-arrowleft"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/#board">3</a><a class="page-number" href="/page/4/#board">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/#board">9</a><a class="extend next" rel="next" href="/page/3/#board"><i class="iconfont icon-arrowright"></i></a></span></nav></div></div></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="beian"><span><a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">陕ICP备16019529号-2</a></span></div><span id="cnzz_stat_icon_1273342630" style="display:none"></span></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!0,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t,e){var i=Fluid.plugins.typing,n=e.getElementById("subtitle");n&&i&&i(n.getAttribute("data-typed-text"))}(window,document)</script><script src="/js/img-lazyload.js"></script><script src="/js/local-search.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>